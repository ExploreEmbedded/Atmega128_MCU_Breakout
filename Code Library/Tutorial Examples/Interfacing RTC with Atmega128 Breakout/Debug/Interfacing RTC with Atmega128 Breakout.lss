
Interfacing RTC with Atmega128 Breakout.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000028  00800100  00001190  00001224  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001190  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000010  00800128  00800128  0000124c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000124c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000127c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000198  00000000  00000000  000012b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d97  00000000  00000000  00001450  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007e0  00000000  00000000  000031e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f85  00000000  00000000  000039c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000448  00000000  00000000  0000494c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007e2  00000000  00000000  00004d94  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001744  00000000  00000000  00005576  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000180  00000000  00000000  00006cba  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	5a c0       	rjmp	.+180    	; 0xb6 <__ctors_end>
       2:	00 00       	nop
       4:	76 c0       	rjmp	.+236    	; 0xf2 <__bad_interrupt>
       6:	00 00       	nop
       8:	74 c0       	rjmp	.+232    	; 0xf2 <__bad_interrupt>
       a:	00 00       	nop
       c:	72 c0       	rjmp	.+228    	; 0xf2 <__bad_interrupt>
       e:	00 00       	nop
      10:	70 c0       	rjmp	.+224    	; 0xf2 <__bad_interrupt>
      12:	00 00       	nop
      14:	6e c0       	rjmp	.+220    	; 0xf2 <__bad_interrupt>
      16:	00 00       	nop
      18:	6c c0       	rjmp	.+216    	; 0xf2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	6a c0       	rjmp	.+212    	; 0xf2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	68 c0       	rjmp	.+208    	; 0xf2 <__bad_interrupt>
      22:	00 00       	nop
      24:	66 c0       	rjmp	.+204    	; 0xf2 <__bad_interrupt>
      26:	00 00       	nop
      28:	64 c0       	rjmp	.+200    	; 0xf2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	62 c0       	rjmp	.+196    	; 0xf2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	60 c0       	rjmp	.+192    	; 0xf2 <__bad_interrupt>
      32:	00 00       	nop
      34:	5e c0       	rjmp	.+188    	; 0xf2 <__bad_interrupt>
      36:	00 00       	nop
      38:	5c c0       	rjmp	.+184    	; 0xf2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	5a c0       	rjmp	.+180    	; 0xf2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	58 c0       	rjmp	.+176    	; 0xf2 <__bad_interrupt>
      42:	00 00       	nop
      44:	56 c0       	rjmp	.+172    	; 0xf2 <__bad_interrupt>
      46:	00 00       	nop
      48:	54 c0       	rjmp	.+168    	; 0xf2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	52 c0       	rjmp	.+164    	; 0xf2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	50 c0       	rjmp	.+160    	; 0xf2 <__bad_interrupt>
      52:	00 00       	nop
      54:	4e c0       	rjmp	.+156    	; 0xf2 <__bad_interrupt>
      56:	00 00       	nop
      58:	4c c0       	rjmp	.+152    	; 0xf2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	4a c0       	rjmp	.+148    	; 0xf2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	48 c0       	rjmp	.+144    	; 0xf2 <__bad_interrupt>
      62:	00 00       	nop
      64:	46 c0       	rjmp	.+140    	; 0xf2 <__bad_interrupt>
      66:	00 00       	nop
      68:	44 c0       	rjmp	.+136    	; 0xf2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	42 c0       	rjmp	.+132    	; 0xf2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	40 c0       	rjmp	.+128    	; 0xf2 <__bad_interrupt>
      72:	00 00       	nop
      74:	3e c0       	rjmp	.+124    	; 0xf2 <__bad_interrupt>
      76:	00 00       	nop
      78:	3c c0       	rjmp	.+120    	; 0xf2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	3a c0       	rjmp	.+116    	; 0xf2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	38 c0       	rjmp	.+112    	; 0xf2 <__bad_interrupt>
      82:	00 00       	nop
      84:	36 c0       	rjmp	.+108    	; 0xf2 <__bad_interrupt>
      86:	00 00       	nop
      88:	34 c0       	rjmp	.+104    	; 0xf2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	9f 00       	.word	0x009f	; ????
      8e:	ba 00       	.word	0x00ba	; ????
      90:	d5 00       	.word	0x00d5	; ????
      92:	f0 00       	.word	0x00f0	; ????
      94:	0b 01       	movw	r0, r22
      96:	26 01       	movw	r4, r12
      98:	43 01       	movw	r8, r6
      9a:	70 01       	movw	r14, r0
      9c:	8b 01       	movw	r16, r22
      9e:	a6 01       	movw	r20, r12
      a0:	c1 01       	movw	r24, r2
      a2:	dc 01       	movw	r26, r24
      a4:	f7 01       	movw	r30, r14
      a6:	14 02       	muls	r17, r20
      a8:	40 02       	muls	r20, r16
      aa:	42 02       	muls	r20, r18
      ac:	44 02       	muls	r20, r20
      ae:	46 02       	muls	r20, r22
      b0:	48 02       	muls	r20, r24
      b2:	4a 02       	muls	r20, r26
      b4:	4c 02       	muls	r20, r28

000000b6 <__ctors_end>:
      b6:	11 24       	eor	r1, r1
      b8:	1f be       	out	0x3f, r1	; 63
      ba:	cf ef       	ldi	r28, 0xFF	; 255
      bc:	d0 e1       	ldi	r29, 0x10	; 16
      be:	de bf       	out	0x3e, r29	; 62
      c0:	cd bf       	out	0x3d, r28	; 61

000000c2 <__do_copy_data>:
      c2:	11 e0       	ldi	r17, 0x01	; 1
      c4:	a0 e0       	ldi	r26, 0x00	; 0
      c6:	b1 e0       	ldi	r27, 0x01	; 1
      c8:	e0 e9       	ldi	r30, 0x90	; 144
      ca:	f1 e1       	ldi	r31, 0x11	; 17
      cc:	00 e0       	ldi	r16, 0x00	; 0
      ce:	0b bf       	out	0x3b, r16	; 59
      d0:	02 c0       	rjmp	.+4      	; 0xd6 <__do_copy_data+0x14>
      d2:	07 90       	elpm	r0, Z+
      d4:	0d 92       	st	X+, r0
      d6:	a8 32       	cpi	r26, 0x28	; 40
      d8:	b1 07       	cpc	r27, r17
      da:	d9 f7       	brne	.-10     	; 0xd2 <__do_copy_data+0x10>

000000dc <__do_clear_bss>:
      dc:	21 e0       	ldi	r18, 0x01	; 1
      de:	a8 e2       	ldi	r26, 0x28	; 40
      e0:	b1 e0       	ldi	r27, 0x01	; 1
      e2:	01 c0       	rjmp	.+2      	; 0xe6 <.do_clear_bss_start>

000000e4 <.do_clear_bss_loop>:
      e4:	1d 92       	st	X+, r1

000000e6 <.do_clear_bss_start>:
      e6:	a8 33       	cpi	r26, 0x38	; 56
      e8:	b2 07       	cpc	r27, r18
      ea:	e1 f7       	brne	.-8      	; 0xe4 <.do_clear_bss_loop>
      ec:	4f d6       	rcall	.+3230   	; 0xd8c <main>
      ee:	0c 94 c6 08 	jmp	0x118c	; 0x118c <_exit>

000000f2 <__bad_interrupt>:
      f2:	86 cf       	rjmp	.-244    	; 0x0 <__vectors>

000000f4 <DELAY_us>:
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
      f4:	00 97       	sbiw	r24, 0x00	; 0
      f6:	31 f0       	breq	.+12     	; 0x104 <DELAY_us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      f8:	25 e0       	ldi	r18, 0x05	; 5
      fa:	2a 95       	dec	r18
      fc:	f1 f7       	brne	.-4      	; 0xfa <DELAY_us+0x6>
      fe:	00 00       	nop
    {
        _delay_us(1);
		us_count--;
     100:	01 97       	sbiw	r24, 0x01	; 1
     102:	f8 cf       	rjmp	.-16     	; 0xf4 <DELAY_us>
    }
}
     104:	08 95       	ret

00000106 <DELAY_ms>:
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
     106:	00 97       	sbiw	r24, 0x00	; 0
     108:	41 f0       	breq	.+16     	; 0x11a <DELAY_ms+0x14>
     10a:	ef e9       	ldi	r30, 0x9F	; 159
     10c:	ff e0       	ldi	r31, 0x0F	; 15
     10e:	31 97       	sbiw	r30, 0x01	; 1
     110:	f1 f7       	brne	.-4      	; 0x10e <DELAY_ms+0x8>
     112:	00 c0       	rjmp	.+0      	; 0x114 <DELAY_ms+0xe>
     114:	00 00       	nop
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
     116:	01 97       	sbiw	r24, 0x01	; 1
     118:	f6 cf       	rjmp	.-20     	; 0x106 <DELAY_ms>
    }
}
     11a:	08 95       	ret

0000011c <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     11c:	98 2f       	mov	r25, r24
     11e:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     120:	e8 2f       	mov	r30, r24
     122:	e6 95       	lsr	r30
     124:	e6 95       	lsr	r30
     126:	e6 95       	lsr	r30
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
     128:	4e 2f       	mov	r20, r30
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	47 30       	cpi	r20, 0x07	; 7
     12e:	51 05       	cpc	r21, r1
     130:	08 f0       	brcs	.+2      	; 0x134 <GPIO_PinDirection+0x18>
     132:	c5 c0       	rjmp	.+394    	; 0x2be <GPIO_PinDirection+0x1a2>
     134:	fa 01       	movw	r30, r20
     136:	ea 5b       	subi	r30, 0xBA	; 186
     138:	ff 4f       	sbci	r31, 0xFF	; 255
     13a:	0c 94 bd 08 	jmp	0x117a	; 0x117a <__tablejump2__>
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
     13e:	4a b3       	in	r20, 0x1a	; 26
     140:	66 23       	and	r22, r22
     142:	59 f0       	breq	.+22     	; 0x15a <GPIO_PinDirection+0x3e>
     144:	21 e0       	ldi	r18, 0x01	; 1
     146:	30 e0       	ldi	r19, 0x00	; 0
     148:	b9 01       	movw	r22, r18
     14a:	02 c0       	rjmp	.+4      	; 0x150 <GPIO_PinDirection+0x34>
     14c:	66 0f       	add	r22, r22
     14e:	77 1f       	adc	r23, r23
     150:	9a 95       	dec	r25
     152:	e2 f7       	brpl	.-8      	; 0x14c <GPIO_PinDirection+0x30>
     154:	cb 01       	movw	r24, r22
     156:	84 2b       	or	r24, r20
     158:	0b c0       	rjmp	.+22     	; 0x170 <GPIO_PinDirection+0x54>
     15a:	21 e0       	ldi	r18, 0x01	; 1
     15c:	30 e0       	ldi	r19, 0x00	; 0
     15e:	b9 01       	movw	r22, r18
     160:	02 c0       	rjmp	.+4      	; 0x166 <GPIO_PinDirection+0x4a>
     162:	66 0f       	add	r22, r22
     164:	77 1f       	adc	r23, r23
     166:	9a 95       	dec	r25
     168:	e2 f7       	brpl	.-8      	; 0x162 <GPIO_PinDirection+0x46>
     16a:	cb 01       	movw	r24, r22
     16c:	80 95       	com	r24
     16e:	84 23       	and	r24, r20
     170:	8a bb       	out	0x1a, r24	; 26
     172:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
     174:	47 b3       	in	r20, 0x17	; 23
     176:	66 23       	and	r22, r22
     178:	59 f0       	breq	.+22     	; 0x190 <GPIO_PinDirection+0x74>
     17a:	21 e0       	ldi	r18, 0x01	; 1
     17c:	30 e0       	ldi	r19, 0x00	; 0
     17e:	b9 01       	movw	r22, r18
     180:	02 c0       	rjmp	.+4      	; 0x186 <GPIO_PinDirection+0x6a>
     182:	66 0f       	add	r22, r22
     184:	77 1f       	adc	r23, r23
     186:	9a 95       	dec	r25
     188:	e2 f7       	brpl	.-8      	; 0x182 <GPIO_PinDirection+0x66>
     18a:	cb 01       	movw	r24, r22
     18c:	84 2b       	or	r24, r20
     18e:	0b c0       	rjmp	.+22     	; 0x1a6 <GPIO_PinDirection+0x8a>
     190:	21 e0       	ldi	r18, 0x01	; 1
     192:	30 e0       	ldi	r19, 0x00	; 0
     194:	b9 01       	movw	r22, r18
     196:	02 c0       	rjmp	.+4      	; 0x19c <GPIO_PinDirection+0x80>
     198:	66 0f       	add	r22, r22
     19a:	77 1f       	adc	r23, r23
     19c:	9a 95       	dec	r25
     19e:	e2 f7       	brpl	.-8      	; 0x198 <GPIO_PinDirection+0x7c>
     1a0:	cb 01       	movw	r24, r22
     1a2:	80 95       	com	r24
     1a4:	84 23       	and	r24, r20
     1a6:	87 bb       	out	0x17, r24	; 23
     1a8:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
     1aa:	44 b3       	in	r20, 0x14	; 20
     1ac:	66 23       	and	r22, r22
     1ae:	59 f0       	breq	.+22     	; 0x1c6 <GPIO_PinDirection+0xaa>
     1b0:	21 e0       	ldi	r18, 0x01	; 1
     1b2:	30 e0       	ldi	r19, 0x00	; 0
     1b4:	b9 01       	movw	r22, r18
     1b6:	02 c0       	rjmp	.+4      	; 0x1bc <GPIO_PinDirection+0xa0>
     1b8:	66 0f       	add	r22, r22
     1ba:	77 1f       	adc	r23, r23
     1bc:	9a 95       	dec	r25
     1be:	e2 f7       	brpl	.-8      	; 0x1b8 <GPIO_PinDirection+0x9c>
     1c0:	cb 01       	movw	r24, r22
     1c2:	84 2b       	or	r24, r20
     1c4:	0b c0       	rjmp	.+22     	; 0x1dc <GPIO_PinDirection+0xc0>
     1c6:	21 e0       	ldi	r18, 0x01	; 1
     1c8:	30 e0       	ldi	r19, 0x00	; 0
     1ca:	b9 01       	movw	r22, r18
     1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <GPIO_PinDirection+0xb6>
     1ce:	66 0f       	add	r22, r22
     1d0:	77 1f       	adc	r23, r23
     1d2:	9a 95       	dec	r25
     1d4:	e2 f7       	brpl	.-8      	; 0x1ce <GPIO_PinDirection+0xb2>
     1d6:	cb 01       	movw	r24, r22
     1d8:	80 95       	com	r24
     1da:	84 23       	and	r24, r20
     1dc:	84 bb       	out	0x14, r24	; 20
     1de:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
     1e0:	41 b3       	in	r20, 0x11	; 17
     1e2:	66 23       	and	r22, r22
     1e4:	59 f0       	breq	.+22     	; 0x1fc <GPIO_PinDirection+0xe0>
     1e6:	21 e0       	ldi	r18, 0x01	; 1
     1e8:	30 e0       	ldi	r19, 0x00	; 0
     1ea:	b9 01       	movw	r22, r18
     1ec:	02 c0       	rjmp	.+4      	; 0x1f2 <GPIO_PinDirection+0xd6>
     1ee:	66 0f       	add	r22, r22
     1f0:	77 1f       	adc	r23, r23
     1f2:	9a 95       	dec	r25
     1f4:	e2 f7       	brpl	.-8      	; 0x1ee <GPIO_PinDirection+0xd2>
     1f6:	cb 01       	movw	r24, r22
     1f8:	84 2b       	or	r24, r20
     1fa:	0b c0       	rjmp	.+22     	; 0x212 <GPIO_PinDirection+0xf6>
     1fc:	21 e0       	ldi	r18, 0x01	; 1
     1fe:	30 e0       	ldi	r19, 0x00	; 0
     200:	b9 01       	movw	r22, r18
     202:	02 c0       	rjmp	.+4      	; 0x208 <GPIO_PinDirection+0xec>
     204:	66 0f       	add	r22, r22
     206:	77 1f       	adc	r23, r23
     208:	9a 95       	dec	r25
     20a:	e2 f7       	brpl	.-8      	; 0x204 <GPIO_PinDirection+0xe8>
     20c:	cb 01       	movw	r24, r22
     20e:	80 95       	com	r24
     210:	84 23       	and	r24, r20
     212:	81 bb       	out	0x11, r24	; 17
     214:	08 95       	ret
#endif      


#ifdef DDRE
    case 4:
        util_UpdateBit(DDRE,enm_pinNumber,v_pinDirn_u8);
     216:	42 b1       	in	r20, 0x02	; 2
     218:	66 23       	and	r22, r22
     21a:	59 f0       	breq	.+22     	; 0x232 <GPIO_PinDirection+0x116>
     21c:	21 e0       	ldi	r18, 0x01	; 1
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	b9 01       	movw	r22, r18
     222:	02 c0       	rjmp	.+4      	; 0x228 <GPIO_PinDirection+0x10c>
     224:	66 0f       	add	r22, r22
     226:	77 1f       	adc	r23, r23
     228:	9a 95       	dec	r25
     22a:	e2 f7       	brpl	.-8      	; 0x224 <GPIO_PinDirection+0x108>
     22c:	cb 01       	movw	r24, r22
     22e:	84 2b       	or	r24, r20
     230:	0b c0       	rjmp	.+22     	; 0x248 <GPIO_PinDirection+0x12c>
     232:	21 e0       	ldi	r18, 0x01	; 1
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	b9 01       	movw	r22, r18
     238:	02 c0       	rjmp	.+4      	; 0x23e <GPIO_PinDirection+0x122>
     23a:	66 0f       	add	r22, r22
     23c:	77 1f       	adc	r23, r23
     23e:	9a 95       	dec	r25
     240:	e2 f7       	brpl	.-8      	; 0x23a <GPIO_PinDirection+0x11e>
     242:	cb 01       	movw	r24, r22
     244:	80 95       	com	r24
     246:	84 23       	and	r24, r20
     248:	82 b9       	out	0x02, r24	; 2
     24a:	08 95       	ret
#endif 

        
#ifdef DDRF
    case 5:
        util_UpdateBit(DDRF,enm_pinNumber,v_pinDirn_u8);
     24c:	40 91 61 00 	lds	r20, 0x0061
     250:	66 23       	and	r22, r22
     252:	59 f0       	breq	.+22     	; 0x26a <GPIO_PinDirection+0x14e>
     254:	21 e0       	ldi	r18, 0x01	; 1
     256:	30 e0       	ldi	r19, 0x00	; 0
     258:	b9 01       	movw	r22, r18
     25a:	02 c0       	rjmp	.+4      	; 0x260 <GPIO_PinDirection+0x144>
     25c:	66 0f       	add	r22, r22
     25e:	77 1f       	adc	r23, r23
     260:	9a 95       	dec	r25
     262:	e2 f7       	brpl	.-8      	; 0x25c <GPIO_PinDirection+0x140>
     264:	cb 01       	movw	r24, r22
     266:	84 2b       	or	r24, r20
     268:	0b c0       	rjmp	.+22     	; 0x280 <GPIO_PinDirection+0x164>
     26a:	21 e0       	ldi	r18, 0x01	; 1
     26c:	30 e0       	ldi	r19, 0x00	; 0
     26e:	b9 01       	movw	r22, r18
     270:	02 c0       	rjmp	.+4      	; 0x276 <GPIO_PinDirection+0x15a>
     272:	66 0f       	add	r22, r22
     274:	77 1f       	adc	r23, r23
     276:	9a 95       	dec	r25
     278:	e2 f7       	brpl	.-8      	; 0x272 <GPIO_PinDirection+0x156>
     27a:	cb 01       	movw	r24, r22
     27c:	80 95       	com	r24
     27e:	84 23       	and	r24, r20
     280:	80 93 61 00 	sts	0x0061, r24
     284:	08 95       	ret
#endif 

        
#ifdef DDRG       
    case 6:
        util_UpdateBit(DDRG,enm_pinNumber,v_pinDirn_u8);
     286:	40 91 64 00 	lds	r20, 0x0064
     28a:	66 23       	and	r22, r22
     28c:	59 f0       	breq	.+22     	; 0x2a4 <GPIO_PinDirection+0x188>
     28e:	21 e0       	ldi	r18, 0x01	; 1
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	b9 01       	movw	r22, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <GPIO_PinDirection+0x17e>
     296:	66 0f       	add	r22, r22
     298:	77 1f       	adc	r23, r23
     29a:	9a 95       	dec	r25
     29c:	e2 f7       	brpl	.-8      	; 0x296 <GPIO_PinDirection+0x17a>
     29e:	cb 01       	movw	r24, r22
     2a0:	84 2b       	or	r24, r20
     2a2:	0b c0       	rjmp	.+22     	; 0x2ba <GPIO_PinDirection+0x19e>
     2a4:	21 e0       	ldi	r18, 0x01	; 1
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	b9 01       	movw	r22, r18
     2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <GPIO_PinDirection+0x194>
     2ac:	66 0f       	add	r22, r22
     2ae:	77 1f       	adc	r23, r23
     2b0:	9a 95       	dec	r25
     2b2:	e2 f7       	brpl	.-8      	; 0x2ac <GPIO_PinDirection+0x190>
     2b4:	cb 01       	movw	r24, r22
     2b6:	80 95       	com	r24
     2b8:	84 23       	and	r24, r20
     2ba:	80 93 64 00 	sts	0x0064, r24
     2be:	08 95       	ret

000002c0 <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     2c0:	98 2f       	mov	r25, r24
     2c2:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     2c4:	e8 2f       	mov	r30, r24
     2c6:	e6 95       	lsr	r30
     2c8:	e6 95       	lsr	r30
     2ca:	e6 95       	lsr	r30
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
     2cc:	4e 2f       	mov	r20, r30
     2ce:	50 e0       	ldi	r21, 0x00	; 0
     2d0:	47 30       	cpi	r20, 0x07	; 7
     2d2:	51 05       	cpc	r21, r1
     2d4:	08 f0       	brcs	.+2      	; 0x2d8 <GPIO_PinWrite+0x18>
     2d6:	c4 c0       	rjmp	.+392    	; 0x460 <GPIO_PinWrite+0x1a0>
     2d8:	fa 01       	movw	r30, r20
     2da:	e3 5b       	subi	r30, 0xB3	; 179
     2dc:	ff 4f       	sbci	r31, 0xFF	; 255
     2de:	4d c7       	rjmp	.+3738   	; 0x117a <__tablejump2__>
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
     2e0:	4b b3       	in	r20, 0x1b	; 27
     2e2:	66 23       	and	r22, r22
     2e4:	59 f0       	breq	.+22     	; 0x2fc <GPIO_PinWrite+0x3c>
     2e6:	21 e0       	ldi	r18, 0x01	; 1
     2e8:	30 e0       	ldi	r19, 0x00	; 0
     2ea:	b9 01       	movw	r22, r18
     2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <GPIO_PinWrite+0x32>
     2ee:	66 0f       	add	r22, r22
     2f0:	77 1f       	adc	r23, r23
     2f2:	9a 95       	dec	r25
     2f4:	e2 f7       	brpl	.-8      	; 0x2ee <GPIO_PinWrite+0x2e>
     2f6:	cb 01       	movw	r24, r22
     2f8:	84 2b       	or	r24, r20
     2fa:	0b c0       	rjmp	.+22     	; 0x312 <GPIO_PinWrite+0x52>
     2fc:	21 e0       	ldi	r18, 0x01	; 1
     2fe:	30 e0       	ldi	r19, 0x00	; 0
     300:	b9 01       	movw	r22, r18
     302:	02 c0       	rjmp	.+4      	; 0x308 <GPIO_PinWrite+0x48>
     304:	66 0f       	add	r22, r22
     306:	77 1f       	adc	r23, r23
     308:	9a 95       	dec	r25
     30a:	e2 f7       	brpl	.-8      	; 0x304 <GPIO_PinWrite+0x44>
     30c:	cb 01       	movw	r24, r22
     30e:	80 95       	com	r24
     310:	84 23       	and	r24, r20
     312:	8b bb       	out	0x1b, r24	; 27
     314:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
     316:	48 b3       	in	r20, 0x18	; 24
     318:	66 23       	and	r22, r22
     31a:	59 f0       	breq	.+22     	; 0x332 <GPIO_PinWrite+0x72>
     31c:	21 e0       	ldi	r18, 0x01	; 1
     31e:	30 e0       	ldi	r19, 0x00	; 0
     320:	b9 01       	movw	r22, r18
     322:	02 c0       	rjmp	.+4      	; 0x328 <GPIO_PinWrite+0x68>
     324:	66 0f       	add	r22, r22
     326:	77 1f       	adc	r23, r23
     328:	9a 95       	dec	r25
     32a:	e2 f7       	brpl	.-8      	; 0x324 <GPIO_PinWrite+0x64>
     32c:	cb 01       	movw	r24, r22
     32e:	84 2b       	or	r24, r20
     330:	0b c0       	rjmp	.+22     	; 0x348 <GPIO_PinWrite+0x88>
     332:	21 e0       	ldi	r18, 0x01	; 1
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	b9 01       	movw	r22, r18
     338:	02 c0       	rjmp	.+4      	; 0x33e <GPIO_PinWrite+0x7e>
     33a:	66 0f       	add	r22, r22
     33c:	77 1f       	adc	r23, r23
     33e:	9a 95       	dec	r25
     340:	e2 f7       	brpl	.-8      	; 0x33a <GPIO_PinWrite+0x7a>
     342:	cb 01       	movw	r24, r22
     344:	80 95       	com	r24
     346:	84 23       	and	r24, r20
     348:	88 bb       	out	0x18, r24	; 24
     34a:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
     34c:	45 b3       	in	r20, 0x15	; 21
     34e:	66 23       	and	r22, r22
     350:	59 f0       	breq	.+22     	; 0x368 <GPIO_PinWrite+0xa8>
     352:	21 e0       	ldi	r18, 0x01	; 1
     354:	30 e0       	ldi	r19, 0x00	; 0
     356:	b9 01       	movw	r22, r18
     358:	02 c0       	rjmp	.+4      	; 0x35e <GPIO_PinWrite+0x9e>
     35a:	66 0f       	add	r22, r22
     35c:	77 1f       	adc	r23, r23
     35e:	9a 95       	dec	r25
     360:	e2 f7       	brpl	.-8      	; 0x35a <GPIO_PinWrite+0x9a>
     362:	cb 01       	movw	r24, r22
     364:	84 2b       	or	r24, r20
     366:	0b c0       	rjmp	.+22     	; 0x37e <GPIO_PinWrite+0xbe>
     368:	21 e0       	ldi	r18, 0x01	; 1
     36a:	30 e0       	ldi	r19, 0x00	; 0
     36c:	b9 01       	movw	r22, r18
     36e:	02 c0       	rjmp	.+4      	; 0x374 <GPIO_PinWrite+0xb4>
     370:	66 0f       	add	r22, r22
     372:	77 1f       	adc	r23, r23
     374:	9a 95       	dec	r25
     376:	e2 f7       	brpl	.-8      	; 0x370 <GPIO_PinWrite+0xb0>
     378:	cb 01       	movw	r24, r22
     37a:	80 95       	com	r24
     37c:	84 23       	and	r24, r20
     37e:	85 bb       	out	0x15, r24	; 21
     380:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
     382:	42 b3       	in	r20, 0x12	; 18
     384:	66 23       	and	r22, r22
     386:	59 f0       	breq	.+22     	; 0x39e <GPIO_PinWrite+0xde>
     388:	21 e0       	ldi	r18, 0x01	; 1
     38a:	30 e0       	ldi	r19, 0x00	; 0
     38c:	b9 01       	movw	r22, r18
     38e:	02 c0       	rjmp	.+4      	; 0x394 <GPIO_PinWrite+0xd4>
     390:	66 0f       	add	r22, r22
     392:	77 1f       	adc	r23, r23
     394:	9a 95       	dec	r25
     396:	e2 f7       	brpl	.-8      	; 0x390 <GPIO_PinWrite+0xd0>
     398:	cb 01       	movw	r24, r22
     39a:	84 2b       	or	r24, r20
     39c:	0b c0       	rjmp	.+22     	; 0x3b4 <GPIO_PinWrite+0xf4>
     39e:	21 e0       	ldi	r18, 0x01	; 1
     3a0:	30 e0       	ldi	r19, 0x00	; 0
     3a2:	b9 01       	movw	r22, r18
     3a4:	02 c0       	rjmp	.+4      	; 0x3aa <GPIO_PinWrite+0xea>
     3a6:	66 0f       	add	r22, r22
     3a8:	77 1f       	adc	r23, r23
     3aa:	9a 95       	dec	r25
     3ac:	e2 f7       	brpl	.-8      	; 0x3a6 <GPIO_PinWrite+0xe6>
     3ae:	cb 01       	movw	r24, r22
     3b0:	80 95       	com	r24
     3b2:	84 23       	and	r24, r20
     3b4:	82 bb       	out	0x12, r24	; 18
     3b6:	08 95       	ret
#endif   


#ifdef PORTE
    case 4:
        util_UpdateBit(PORTE,enm_pinNumber,v_pinValue_u8);
     3b8:	43 b1       	in	r20, 0x03	; 3
     3ba:	66 23       	and	r22, r22
     3bc:	59 f0       	breq	.+22     	; 0x3d4 <GPIO_PinWrite+0x114>
     3be:	21 e0       	ldi	r18, 0x01	; 1
     3c0:	30 e0       	ldi	r19, 0x00	; 0
     3c2:	b9 01       	movw	r22, r18
     3c4:	02 c0       	rjmp	.+4      	; 0x3ca <GPIO_PinWrite+0x10a>
     3c6:	66 0f       	add	r22, r22
     3c8:	77 1f       	adc	r23, r23
     3ca:	9a 95       	dec	r25
     3cc:	e2 f7       	brpl	.-8      	; 0x3c6 <GPIO_PinWrite+0x106>
     3ce:	cb 01       	movw	r24, r22
     3d0:	84 2b       	or	r24, r20
     3d2:	0b c0       	rjmp	.+22     	; 0x3ea <GPIO_PinWrite+0x12a>
     3d4:	21 e0       	ldi	r18, 0x01	; 1
     3d6:	30 e0       	ldi	r19, 0x00	; 0
     3d8:	b9 01       	movw	r22, r18
     3da:	02 c0       	rjmp	.+4      	; 0x3e0 <GPIO_PinWrite+0x120>
     3dc:	66 0f       	add	r22, r22
     3de:	77 1f       	adc	r23, r23
     3e0:	9a 95       	dec	r25
     3e2:	e2 f7       	brpl	.-8      	; 0x3dc <GPIO_PinWrite+0x11c>
     3e4:	cb 01       	movw	r24, r22
     3e6:	80 95       	com	r24
     3e8:	84 23       	and	r24, r20
     3ea:	83 b9       	out	0x03, r24	; 3
     3ec:	08 95       	ret
#endif        

        
#ifdef PORTF        
    case 5:
        util_UpdateBit(PORTF,enm_pinNumber,v_pinValue_u8);
     3ee:	40 91 62 00 	lds	r20, 0x0062
     3f2:	66 23       	and	r22, r22
     3f4:	59 f0       	breq	.+22     	; 0x40c <GPIO_PinWrite+0x14c>
     3f6:	21 e0       	ldi	r18, 0x01	; 1
     3f8:	30 e0       	ldi	r19, 0x00	; 0
     3fa:	b9 01       	movw	r22, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <GPIO_PinWrite+0x142>
     3fe:	66 0f       	add	r22, r22
     400:	77 1f       	adc	r23, r23
     402:	9a 95       	dec	r25
     404:	e2 f7       	brpl	.-8      	; 0x3fe <GPIO_PinWrite+0x13e>
     406:	cb 01       	movw	r24, r22
     408:	84 2b       	or	r24, r20
     40a:	0b c0       	rjmp	.+22     	; 0x422 <GPIO_PinWrite+0x162>
     40c:	21 e0       	ldi	r18, 0x01	; 1
     40e:	30 e0       	ldi	r19, 0x00	; 0
     410:	b9 01       	movw	r22, r18
     412:	02 c0       	rjmp	.+4      	; 0x418 <GPIO_PinWrite+0x158>
     414:	66 0f       	add	r22, r22
     416:	77 1f       	adc	r23, r23
     418:	9a 95       	dec	r25
     41a:	e2 f7       	brpl	.-8      	; 0x414 <GPIO_PinWrite+0x154>
     41c:	cb 01       	movw	r24, r22
     41e:	80 95       	com	r24
     420:	84 23       	and	r24, r20
     422:	80 93 62 00 	sts	0x0062, r24
     426:	08 95       	ret
#endif        

        
#ifdef PORTG        
    case 6:
        util_UpdateBit(PORTG,enm_pinNumber,v_pinValue_u8);
     428:	40 91 65 00 	lds	r20, 0x0065
     42c:	66 23       	and	r22, r22
     42e:	59 f0       	breq	.+22     	; 0x446 <GPIO_PinWrite+0x186>
     430:	21 e0       	ldi	r18, 0x01	; 1
     432:	30 e0       	ldi	r19, 0x00	; 0
     434:	b9 01       	movw	r22, r18
     436:	02 c0       	rjmp	.+4      	; 0x43c <GPIO_PinWrite+0x17c>
     438:	66 0f       	add	r22, r22
     43a:	77 1f       	adc	r23, r23
     43c:	9a 95       	dec	r25
     43e:	e2 f7       	brpl	.-8      	; 0x438 <GPIO_PinWrite+0x178>
     440:	cb 01       	movw	r24, r22
     442:	84 2b       	or	r24, r20
     444:	0b c0       	rjmp	.+22     	; 0x45c <GPIO_PinWrite+0x19c>
     446:	21 e0       	ldi	r18, 0x01	; 1
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	02 c0       	rjmp	.+4      	; 0x452 <GPIO_PinWrite+0x192>
     44e:	66 0f       	add	r22, r22
     450:	77 1f       	adc	r23, r23
     452:	9a 95       	dec	r25
     454:	e2 f7       	brpl	.-8      	; 0x44e <GPIO_PinWrite+0x18e>
     456:	cb 01       	movw	r24, r22
     458:	80 95       	com	r24
     45a:	84 23       	and	r24, r20
     45c:	80 93 65 00 	sts	0x0065, r24
     460:	08 95       	ret

00000462 <GPIO_PinRead>:
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
     462:	28 2f       	mov	r18, r24
     464:	27 70       	andi	r18, 0x07	; 7
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
     466:	e8 2f       	mov	r30, r24
     468:	e6 95       	lsr	r30
     46a:	e6 95       	lsr	r30
     46c:	e6 95       	lsr	r30
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
     46e:	8e 2f       	mov	r24, r30
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	87 30       	cpi	r24, 0x07	; 7
     474:	91 05       	cpc	r25, r1
     476:	d0 f4       	brcc	.+52     	; 0x4ac <GPIO_PinRead+0x4a>
     478:	fc 01       	movw	r30, r24
     47a:	ec 5a       	subi	r30, 0xAC	; 172
     47c:	ff 4f       	sbci	r31, 0xFF	; 255
     47e:	7d c6       	rjmp	.+3322   	; 0x117a <__tablejump2__>
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
     480:	89 b3       	in	r24, 0x19	; 25
     482:	0c c0       	rjmp	.+24     	; 0x49c <GPIO_PinRead+0x3a>
        break;
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
     484:	86 b3       	in	r24, 0x16	; 22
     486:	0a c0       	rjmp	.+20     	; 0x49c <GPIO_PinRead+0x3a>
        break;
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
     488:	83 b3       	in	r24, 0x13	; 19
     48a:	08 c0       	rjmp	.+16     	; 0x49c <GPIO_PinRead+0x3a>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     48c:	80 b3       	in	r24, 0x10	; 16
     48e:	06 c0       	rjmp	.+12     	; 0x49c <GPIO_PinRead+0x3a>
#endif   


#ifdef PINE    
    case 4: 
        returnStatus = util_IsBitSet(PINE,enm_pinNumber);
     490:	81 b1       	in	r24, 0x01	; 1
     492:	04 c0       	rjmp	.+8      	; 0x49c <GPIO_PinRead+0x3a>
#endif        


#ifdef PINF
    case 5:
        returnStatus = util_IsBitSet(PINF,enm_pinNumber);
     494:	80 b1       	in	r24, 0x00	; 0
     496:	02 c0       	rjmp	.+4      	; 0x49c <GPIO_PinRead+0x3a>
#endif

        
#ifdef PING
    case 6:
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
     498:	80 91 63 00 	lds	r24, 0x0063
     49c:	90 e0       	ldi	r25, 0x00	; 0
     49e:	02 c0       	rjmp	.+4      	; 0x4a4 <GPIO_PinRead+0x42>
     4a0:	95 95       	asr	r25
     4a2:	87 95       	ror	r24
     4a4:	2a 95       	dec	r18
     4a6:	e2 f7       	brpl	.-8      	; 0x4a0 <GPIO_PinRead+0x3e>
     4a8:	81 70       	andi	r24, 0x01	; 1
        break;
     4aa:	08 95       	ret
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
     4ac:	80 e0       	ldi	r24, 0x00	; 0
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
}
     4ae:	08 95       	ret

000004b0 <I2C_Init>:

 * description :This function is used to initialize the I2C module
------------------------------------------------------------------------------------*/
void I2C_Init()
{
    TWSR=0x00; //set presca1er bits to zero
     4b0:	10 92 71 00 	sts	0x0071, r1
    TWBR=0x46; //SCL frequency is 50K for 16Mhz
     4b4:	86 e4       	ldi	r24, 0x46	; 70
     4b6:	80 93 70 00 	sts	0x0070, r24
    TWCR=0x04; //enab1e TWI module
     4ba:	84 e0       	ldi	r24, 0x04	; 4
     4bc:	80 93 74 00 	sts	0x0074, r24
     4c0:	08 95       	ret

000004c2 <I2C_Start>:
                      ____|         |____________

 ***************************************************************************************************/
void I2C_Start()
{
    TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
     4c2:	84 ea       	ldi	r24, 0xA4	; 164
     4c4:	80 93 74 00 	sts	0x0074, r24
    while (!(TWCR & (1<<TWINT)));
     4c8:	80 91 74 00 	lds	r24, 0x0074
     4cc:	87 ff       	sbrs	r24, 7
     4ce:	fc cf       	rjmp	.-8      	; 0x4c8 <I2C_Start+0x6>
}
     4d0:	08 95       	ret

000004d2 <I2C_Stop>:

 ***************************************************************************************************/

void I2C_Stop(void)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
     4d2:	84 e9       	ldi	r24, 0x94	; 148
     4d4:	80 93 74 00 	sts	0x0074, r24
    DELAY_us(100) ; //wait for a short time
     4d8:	84 e6       	ldi	r24, 0x64	; 100
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	0b ce       	rjmp	.-1002   	; 0xf4 <DELAY_us>

000004de <I2C_Write>:


 ***************************************************************************************************/
void I2C_Write(uint8_t v_i2cData_u8)
{
    TWDR = v_i2cData_u8 ;
     4de:	80 93 73 00 	sts	0x0073, r24
    TWCR = ((1<< TWINT) | (1<<TWEN));
     4e2:	84 e8       	ldi	r24, 0x84	; 132
     4e4:	80 93 74 00 	sts	0x0074, r24
    while (!(TWCR & (1 <<TWINT)));
     4e8:	80 91 74 00 	lds	r24, 0x0074
     4ec:	87 ff       	sbrs	r24, 7
     4ee:	fc cf       	rjmp	.-8      	; 0x4e8 <I2C_Write+0xa>
}
     4f0:	08 95       	ret

000004f2 <I2C_Read>:


***************************************************************************************************/
uint8_t I2C_Read(uint8_t v_ackOption_u8)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (v_ackOption_u8<<TWEA));
     4f2:	20 e4       	ldi	r18, 0x40	; 64
     4f4:	82 9f       	mul	r24, r18
     4f6:	c0 01       	movw	r24, r0
     4f8:	11 24       	eor	r1, r1
     4fa:	84 68       	ori	r24, 0x84	; 132
     4fc:	80 93 74 00 	sts	0x0074, r24
    while ( !(TWCR & (1 <<TWINT)));
     500:	80 91 74 00 	lds	r24, 0x0074
     504:	87 ff       	sbrs	r24, 7
     506:	fc cf       	rjmp	.-8      	; 0x500 <I2C_Read+0xe>
    return TWDR;
     508:	80 91 73 00 	lds	r24, 0x0073
}
     50c:	08 95       	ret

0000050e <lcd_SendHigherNibble>:
            j++;
        }

        DELAY_ms(C_ScrollDelayTime_U8);
    }
    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);              // Finally enable the Cursor
     50e:	0f 93       	push	r16
     510:	1f 93       	push	r17
     512:	cf 93       	push	r28
     514:	c8 2f       	mov	r28, r24
     516:	84 fb       	bst	r24, 4
     518:	66 27       	eor	r22, r22
     51a:	60 f9       	bld	r22, 0
     51c:	08 e2       	ldi	r16, 0x28	; 40
     51e:	11 e0       	ldi	r17, 0x01	; 1
     520:	f8 01       	movw	r30, r16
     522:	82 85       	ldd	r24, Z+10	; 0x0a
     524:	cd de       	rcall	.-614    	; 0x2c0 <GPIO_PinWrite>
     526:	c5 fb       	bst	r28, 5
     528:	66 27       	eor	r22, r22
     52a:	60 f9       	bld	r22, 0
     52c:	f8 01       	movw	r30, r16
     52e:	83 85       	ldd	r24, Z+11	; 0x0b
     530:	c7 de       	rcall	.-626    	; 0x2c0 <GPIO_PinWrite>
     532:	c6 fb       	bst	r28, 6
     534:	66 27       	eor	r22, r22
     536:	60 f9       	bld	r22, 0
     538:	f8 01       	movw	r30, r16
     53a:	84 85       	ldd	r24, Z+12	; 0x0c
     53c:	c1 de       	rcall	.-638    	; 0x2c0 <GPIO_PinWrite>
     53e:	6c 2f       	mov	r22, r28
     540:	66 1f       	adc	r22, r22
     542:	66 27       	eor	r22, r22
     544:	66 1f       	adc	r22, r22
     546:	f8 01       	movw	r30, r16
     548:	85 85       	ldd	r24, Z+13	; 0x0d
     54a:	cf 91       	pop	r28
     54c:	1f 91       	pop	r17
     54e:	0f 91       	pop	r16
     550:	b7 ce       	rjmp	.-658    	; 0x2c0 <GPIO_PinWrite>

00000552 <lcd_SendCmdSignals>:
     552:	cf 93       	push	r28
     554:	df 93       	push	r29
     556:	c8 e2       	ldi	r28, 0x28	; 40
     558:	d1 e0       	ldi	r29, 0x01	; 1
     55a:	60 e0       	ldi	r22, 0x00	; 0
     55c:	8b 81       	ldd	r24, Y+3	; 0x03
     55e:	b0 de       	rcall	.-672    	; 0x2c0 <GPIO_PinWrite>
     560:	60 e0       	ldi	r22, 0x00	; 0
     562:	8c 81       	ldd	r24, Y+4	; 0x04
     564:	ad de       	rcall	.-678    	; 0x2c0 <GPIO_PinWrite>
     566:	61 e0       	ldi	r22, 0x01	; 1
     568:	8d 81       	ldd	r24, Y+5	; 0x05
     56a:	aa de       	rcall	.-684    	; 0x2c0 <GPIO_PinWrite>
     56c:	8a e0       	ldi	r24, 0x0A	; 10
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	c1 dd       	rcall	.-1150   	; 0xf4 <DELAY_us>
     572:	60 e0       	ldi	r22, 0x00	; 0
     574:	8d 81       	ldd	r24, Y+5	; 0x05
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	a2 ce       	rjmp	.-700    	; 0x2c0 <GPIO_PinWrite>

0000057c <lcd_SendLowerNibble>:
     57c:	0f 93       	push	r16
     57e:	1f 93       	push	r17
     580:	cf 93       	push	r28
     582:	c8 2f       	mov	r28, r24
     584:	68 2f       	mov	r22, r24
     586:	61 70       	andi	r22, 0x01	; 1
     588:	08 e2       	ldi	r16, 0x28	; 40
     58a:	11 e0       	ldi	r17, 0x01	; 1
     58c:	f8 01       	movw	r30, r16
     58e:	86 81       	ldd	r24, Z+6	; 0x06
     590:	97 de       	rcall	.-722    	; 0x2c0 <GPIO_PinWrite>
     592:	c1 fb       	bst	r28, 1
     594:	66 27       	eor	r22, r22
     596:	60 f9       	bld	r22, 0
     598:	f8 01       	movw	r30, r16
     59a:	87 81       	ldd	r24, Z+7	; 0x07
     59c:	91 de       	rcall	.-734    	; 0x2c0 <GPIO_PinWrite>
     59e:	c2 fb       	bst	r28, 2
     5a0:	66 27       	eor	r22, r22
     5a2:	60 f9       	bld	r22, 0
     5a4:	f8 01       	movw	r30, r16
     5a6:	80 85       	ldd	r24, Z+8	; 0x08
     5a8:	8b de       	rcall	.-746    	; 0x2c0 <GPIO_PinWrite>
     5aa:	c3 fb       	bst	r28, 3
     5ac:	66 27       	eor	r22, r22
     5ae:	60 f9       	bld	r22, 0
     5b0:	f8 01       	movw	r30, r16
     5b2:	81 85       	ldd	r24, Z+9	; 0x09
     5b4:	cf 91       	pop	r28
     5b6:	1f 91       	pop	r17
     5b8:	0f 91       	pop	r16
     5ba:	82 ce       	rjmp	.-764    	; 0x2c0 <GPIO_PinWrite>

000005bc <lcd_SendDataSignals>:
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	c8 e2       	ldi	r28, 0x28	; 40
     5c2:	d1 e0       	ldi	r29, 0x01	; 1
     5c4:	61 e0       	ldi	r22, 0x01	; 1
     5c6:	8b 81       	ldd	r24, Y+3	; 0x03
     5c8:	7b de       	rcall	.-778    	; 0x2c0 <GPIO_PinWrite>
     5ca:	60 e0       	ldi	r22, 0x00	; 0
     5cc:	8c 81       	ldd	r24, Y+4	; 0x04
     5ce:	78 de       	rcall	.-784    	; 0x2c0 <GPIO_PinWrite>
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	8d 81       	ldd	r24, Y+5	; 0x05
     5d4:	75 de       	rcall	.-790    	; 0x2c0 <GPIO_PinWrite>
     5d6:	8a e0       	ldi	r24, 0x0A	; 10
     5d8:	90 e0       	ldi	r25, 0x00	; 0
     5da:	8c dd       	rcall	.-1256   	; 0xf4 <DELAY_us>
     5dc:	60 e0       	ldi	r22, 0x00	; 0
     5de:	8d 81       	ldd	r24, Y+5	; 0x05
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	6d ce       	rjmp	.-806    	; 0x2c0 <GPIO_PinWrite>

000005e6 <lcd_BusyCheck>:
     5e6:	cf 93       	push	r28
     5e8:	80 91 2c 01 	lds	r24, 0x012C
     5ec:	8f 3f       	cpi	r24, 0xFF	; 255
     5ee:	09 f4       	brne	.+2      	; 0x5f2 <lcd_BusyCheck+0xc>
     5f0:	37 c0       	rjmp	.+110    	; 0x660 <lcd_BusyCheck+0x7a>
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	80 91 35 01 	lds	r24, 0x0135
     5f8:	91 dd       	rcall	.-1246   	; 0x11c <GPIO_PinDirection>
     5fa:	60 e0       	ldi	r22, 0x00	; 0
     5fc:	80 91 2b 01 	lds	r24, 0x012B
     600:	5f de       	rcall	.-834    	; 0x2c0 <GPIO_PinWrite>
     602:	61 e0       	ldi	r22, 0x01	; 1
     604:	80 91 2c 01 	lds	r24, 0x012C
     608:	5b de       	rcall	.-842    	; 0x2c0 <GPIO_PinWrite>
     60a:	60 e0       	ldi	r22, 0x00	; 0
     60c:	80 91 2d 01 	lds	r24, 0x012D
     610:	57 de       	rcall	.-850    	; 0x2c0 <GPIO_PinWrite>
     612:	8a e0       	ldi	r24, 0x0A	; 10
     614:	90 e0       	ldi	r25, 0x00	; 0
     616:	6e dd       	rcall	.-1316   	; 0xf4 <DELAY_us>
     618:	61 e0       	ldi	r22, 0x01	; 1
     61a:	80 91 2d 01 	lds	r24, 0x012D
     61e:	50 de       	rcall	.-864    	; 0x2c0 <GPIO_PinWrite>
     620:	8a e0       	ldi	r24, 0x0A	; 10
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	67 dd       	rcall	.-1330   	; 0xf4 <DELAY_us>
     626:	80 91 35 01 	lds	r24, 0x0135
     62a:	1b df       	rcall	.-458    	; 0x462 <GPIO_PinRead>
     62c:	c8 2f       	mov	r28, r24
     62e:	80 91 2a 01 	lds	r24, 0x012A
     632:	84 30       	cpi	r24, 0x04	; 4
     634:	71 f4       	brne	.+28     	; 0x652 <lcd_BusyCheck+0x6c>
     636:	60 e0       	ldi	r22, 0x00	; 0
     638:	80 91 2d 01 	lds	r24, 0x012D
     63c:	41 de       	rcall	.-894    	; 0x2c0 <GPIO_PinWrite>
     63e:	8a e0       	ldi	r24, 0x0A	; 10
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	58 dd       	rcall	.-1360   	; 0xf4 <DELAY_us>
     644:	61 e0       	ldi	r22, 0x01	; 1
     646:	80 91 2d 01 	lds	r24, 0x012D
     64a:	3a de       	rcall	.-908    	; 0x2c0 <GPIO_PinWrite>
     64c:	8a e0       	ldi	r24, 0x0A	; 10
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	51 dd       	rcall	.-1374   	; 0xf4 <DELAY_us>
     652:	c1 11       	cpse	r28, r1
     654:	da cf       	rjmp	.-76     	; 0x60a <lcd_BusyCheck+0x24>
     656:	61 e0       	ldi	r22, 0x01	; 1
     658:	80 91 35 01 	lds	r24, 0x0135
     65c:	cf 91       	pop	r28
     65e:	5e cd       	rjmp	.-1348   	; 0x11c <GPIO_PinDirection>
     660:	81 e0       	ldi	r24, 0x01	; 1
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	cf 91       	pop	r28
     666:	4f cd       	rjmp	.-1378   	; 0x106 <DELAY_ms>

00000668 <LCD_SetUp>:
     668:	8f 92       	push	r8
     66a:	9f 92       	push	r9
     66c:	af 92       	push	r10
     66e:	bf 92       	push	r11
     670:	cf 92       	push	r12
     672:	df 92       	push	r13
     674:	ef 92       	push	r14
     676:	ff 92       	push	r15
     678:	0f 93       	push	r16
     67a:	1f 93       	push	r17
     67c:	cf 93       	push	r28
     67e:	df 93       	push	r29
     680:	cd b7       	in	r28, 0x3d	; 61
     682:	de b7       	in	r29, 0x3e	; 62
     684:	98 2e       	mov	r9, r24
     686:	b6 2e       	mov	r11, r22
     688:	d4 2e       	mov	r13, r20
     68a:	ff 84       	ldd	r15, Y+15	; 0x0f
     68c:	18 89       	ldd	r17, Y+16	; 0x10
     68e:	80 93 2b 01 	sts	0x012B, r24
     692:	60 93 2c 01 	sts	0x012C, r22
     696:	40 93 2d 01 	sts	0x012D, r20
     69a:	20 93 2e 01 	sts	0x012E, r18
     69e:	00 93 2f 01 	sts	0x012F, r16
     6a2:	e0 92 30 01 	sts	0x0130, r14
     6a6:	c0 92 31 01 	sts	0x0131, r12
     6aa:	a0 92 32 01 	sts	0x0132, r10
     6ae:	80 92 33 01 	sts	0x0133, r8
     6b2:	f0 92 34 01 	sts	0x0134, r15
     6b6:	10 93 35 01 	sts	0x0135, r17
     6ba:	2f 3f       	cpi	r18, 0xFF	; 255
     6bc:	39 f0       	breq	.+14     	; 0x6cc <LCD_SetUp+0x64>
     6be:	0f 3f       	cpi	r16, 0xFF	; 255
     6c0:	29 f0       	breq	.+10     	; 0x6cc <LCD_SetUp+0x64>
     6c2:	8f ef       	ldi	r24, 0xFF	; 255
     6c4:	e8 16       	cp	r14, r24
     6c6:	11 f0       	breq	.+4      	; 0x6cc <LCD_SetUp+0x64>
     6c8:	c8 12       	cpse	r12, r24
     6ca:	04 c0       	rjmp	.+8      	; 0x6d4 <LCD_SetUp+0x6c>
     6cc:	84 e0       	ldi	r24, 0x04	; 4
     6ce:	80 93 2a 01 	sts	0x012A, r24
     6d2:	0f c0       	rjmp	.+30     	; 0x6f2 <LCD_SetUp+0x8a>
     6d4:	88 e0       	ldi	r24, 0x08	; 8
     6d6:	80 93 2a 01 	sts	0x012A, r24
     6da:	61 e0       	ldi	r22, 0x01	; 1
     6dc:	82 2f       	mov	r24, r18
     6de:	1e dd       	rcall	.-1476   	; 0x11c <GPIO_PinDirection>
     6e0:	61 e0       	ldi	r22, 0x01	; 1
     6e2:	80 2f       	mov	r24, r16
     6e4:	1b dd       	rcall	.-1482   	; 0x11c <GPIO_PinDirection>
     6e6:	61 e0       	ldi	r22, 0x01	; 1
     6e8:	8e 2d       	mov	r24, r14
     6ea:	18 dd       	rcall	.-1488   	; 0x11c <GPIO_PinDirection>
     6ec:	61 e0       	ldi	r22, 0x01	; 1
     6ee:	8c 2d       	mov	r24, r12
     6f0:	15 dd       	rcall	.-1494   	; 0x11c <GPIO_PinDirection>
     6f2:	61 e0       	ldi	r22, 0x01	; 1
     6f4:	89 2d       	mov	r24, r9
     6f6:	12 dd       	rcall	.-1500   	; 0x11c <GPIO_PinDirection>
     6f8:	61 e0       	ldi	r22, 0x01	; 1
     6fa:	8b 2d       	mov	r24, r11
     6fc:	0f dd       	rcall	.-1506   	; 0x11c <GPIO_PinDirection>
     6fe:	61 e0       	ldi	r22, 0x01	; 1
     700:	8d 2d       	mov	r24, r13
     702:	0c dd       	rcall	.-1512   	; 0x11c <GPIO_PinDirection>
     704:	61 e0       	ldi	r22, 0x01	; 1
     706:	8a 2d       	mov	r24, r10
     708:	09 dd       	rcall	.-1518   	; 0x11c <GPIO_PinDirection>
     70a:	61 e0       	ldi	r22, 0x01	; 1
     70c:	88 2d       	mov	r24, r8
     70e:	06 dd       	rcall	.-1524   	; 0x11c <GPIO_PinDirection>
     710:	61 e0       	ldi	r22, 0x01	; 1
     712:	8f 2d       	mov	r24, r15
     714:	03 dd       	rcall	.-1530   	; 0x11c <GPIO_PinDirection>
     716:	61 e0       	ldi	r22, 0x01	; 1
     718:	81 2f       	mov	r24, r17
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	ff 90       	pop	r15
     724:	ef 90       	pop	r14
     726:	df 90       	pop	r13
     728:	cf 90       	pop	r12
     72a:	bf 90       	pop	r11
     72c:	af 90       	pop	r10
     72e:	9f 90       	pop	r9
     730:	8f 90       	pop	r8
     732:	f4 cc       	rjmp	.-1560   	; 0x11c <GPIO_PinDirection>

00000734 <LCD_CmdWrite>:
     734:	cf 93       	push	r28
     736:	c8 2f       	mov	r28, r24
     738:	56 df       	rcall	.-340    	; 0x5e6 <lcd_BusyCheck>
     73a:	80 91 2a 01 	lds	r24, 0x012A
     73e:	88 30       	cpi	r24, 0x08	; 8
     740:	19 f4       	brne	.+6      	; 0x748 <LCD_CmdWrite+0x14>
     742:	8c 2f       	mov	r24, r28
     744:	1b df       	rcall	.-458    	; 0x57c <lcd_SendLowerNibble>
     746:	05 c0       	rjmp	.+10     	; 0x752 <LCD_CmdWrite+0x1e>
     748:	8c 2f       	mov	r24, r28
     74a:	e1 de       	rcall	.-574    	; 0x50e <lcd_SendHigherNibble>
     74c:	02 df       	rcall	.-508    	; 0x552 <lcd_SendCmdSignals>
     74e:	c2 95       	swap	r28
     750:	c0 7f       	andi	r28, 0xF0	; 240
     752:	8c 2f       	mov	r24, r28
     754:	dc de       	rcall	.-584    	; 0x50e <lcd_SendHigherNibble>
     756:	cf 91       	pop	r28
     758:	fc ce       	rjmp	.-520    	; 0x552 <lcd_SendCmdSignals>

0000075a <LCD_GoToLine>:
     75a:	90 91 28 01 	lds	r25, 0x0128
     75e:	89 17       	cp	r24, r25
     760:	50 f4       	brcc	.+20     	; 0x776 <LCD_GoToLine+0x1c>
     762:	10 92 36 01 	sts	0x0136, r1
     766:	80 93 37 01 	sts	0x0137, r24
     76a:	e8 2f       	mov	r30, r24
     76c:	f0 e0       	ldi	r31, 0x00	; 0
     76e:	e0 50       	subi	r30, 0x00	; 0
     770:	ff 4f       	sbci	r31, 0xFF	; 255
     772:	80 81       	ld	r24, Z
     774:	df cf       	rjmp	.-66     	; 0x734 <LCD_CmdWrite>
     776:	08 95       	ret

00000778 <LCD_Clear>:
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	dc df       	rcall	.-72     	; 0x734 <LCD_CmdWrite>
     77c:	80 e0       	ldi	r24, 0x00	; 0
     77e:	ed cf       	rjmp	.-38     	; 0x75a <LCD_GoToLine>

00000780 <LCD_Init>:
     780:	60 93 29 01 	sts	0x0129, r22
     784:	80 93 28 01 	sts	0x0128, r24
     788:	83 30       	cpi	r24, 0x03	; 3
     78a:	40 f0       	brcs	.+16     	; 0x79c <LCD_Init+0x1c>
     78c:	6f 70       	andi	r22, 0x0F	; 15
     78e:	80 e9       	ldi	r24, 0x90	; 144
     790:	86 0f       	add	r24, r22
     792:	80 93 02 01 	sts	0x0102, r24
     796:	60 53       	subi	r22, 0x30	; 48
     798:	60 93 03 01 	sts	0x0103, r22
     79c:	84 e6       	ldi	r24, 0x64	; 100
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	b2 dc       	rcall	.-1692   	; 0x106 <DELAY_ms>
     7a2:	80 91 2a 01 	lds	r24, 0x012A
     7a6:	88 30       	cpi	r24, 0x08	; 8
     7a8:	11 f4       	brne	.+4      	; 0x7ae <LCD_Init+0x2e>
     7aa:	88 e3       	ldi	r24, 0x38	; 56
     7ac:	1b c0       	rjmp	.+54     	; 0x7e4 <LCD_Init+0x64>
     7ae:	84 30       	cpi	r24, 0x04	; 4
     7b0:	d1 f4       	brne	.+52     	; 0x7e6 <LCD_Init+0x66>
     7b2:	80 e3       	ldi	r24, 0x30	; 48
     7b4:	ac de       	rcall	.-680    	; 0x50e <lcd_SendHigherNibble>
     7b6:	cd de       	rcall	.-614    	; 0x552 <lcd_SendCmdSignals>
     7b8:	84 e6       	ldi	r24, 0x64	; 100
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	a4 dc       	rcall	.-1720   	; 0x106 <DELAY_ms>
     7be:	80 e3       	ldi	r24, 0x30	; 48
     7c0:	a6 de       	rcall	.-692    	; 0x50e <lcd_SendHigherNibble>
     7c2:	c7 de       	rcall	.-626    	; 0x552 <lcd_SendCmdSignals>
     7c4:	88 ec       	ldi	r24, 0xC8	; 200
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	95 dc       	rcall	.-1750   	; 0xf4 <DELAY_us>
     7ca:	80 e3       	ldi	r24, 0x30	; 48
     7cc:	a0 de       	rcall	.-704    	; 0x50e <lcd_SendHigherNibble>
     7ce:	c1 de       	rcall	.-638    	; 0x552 <lcd_SendCmdSignals>
     7d0:	88 ec       	ldi	r24, 0xC8	; 200
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	8f dc       	rcall	.-1762   	; 0xf4 <DELAY_us>
     7d6:	80 e2       	ldi	r24, 0x20	; 32
     7d8:	9a de       	rcall	.-716    	; 0x50e <lcd_SendHigherNibble>
     7da:	bb de       	rcall	.-650    	; 0x552 <lcd_SendCmdSignals>
     7dc:	88 ec       	ldi	r24, 0xC8	; 200
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	89 dc       	rcall	.-1774   	; 0xf4 <DELAY_us>
     7e2:	88 e2       	ldi	r24, 0x28	; 40
     7e4:	a7 df       	rcall	.-178    	; 0x734 <LCD_CmdWrite>
     7e6:	8e e0       	ldi	r24, 0x0E	; 14
     7e8:	a5 df       	rcall	.-182    	; 0x734 <LCD_CmdWrite>
     7ea:	c6 cf       	rjmp	.-116    	; 0x778 <LCD_Clear>

000007ec <LCD_GoToNextLine>:
     7ec:	80 91 37 01 	lds	r24, 0x0137
     7f0:	8f 5f       	subi	r24, 0xFF	; 255
     7f2:	80 93 37 01 	sts	0x0137, r24
     7f6:	10 92 36 01 	sts	0x0136, r1
     7fa:	90 91 28 01 	lds	r25, 0x0128
     7fe:	89 17       	cp	r24, r25
     800:	10 f0       	brcs	.+4      	; 0x806 <LCD_GoToNextLine+0x1a>
     802:	10 92 37 01 	sts	0x0137, r1
     806:	e0 91 37 01 	lds	r30, 0x0137
     80a:	f0 e0       	ldi	r31, 0x00	; 0
     80c:	e0 50       	subi	r30, 0x00	; 0
     80e:	ff 4f       	sbci	r31, 0xFF	; 255
     810:	80 81       	ld	r24, Z
     812:	90 cf       	rjmp	.-224    	; 0x734 <LCD_CmdWrite>

00000814 <LCD_DisplayChar>:
     814:	cf 93       	push	r28
     816:	c8 2f       	mov	r28, r24
     818:	90 91 36 01 	lds	r25, 0x0136
     81c:	80 91 29 01 	lds	r24, 0x0129
     820:	98 17       	cp	r25, r24
     822:	50 f4       	brcc	.+20     	; 0x838 <LCD_DisplayChar+0x24>
     824:	ca 30       	cpi	r28, 0x0A	; 10
     826:	41 f0       	breq	.+16     	; 0x838 <LCD_DisplayChar+0x24>
     828:	de de       	rcall	.-580    	; 0x5e6 <lcd_BusyCheck>
     82a:	80 91 2a 01 	lds	r24, 0x012A
     82e:	88 30       	cpi	r24, 0x08	; 8
     830:	39 f4       	brne	.+14     	; 0x840 <LCD_DisplayChar+0x2c>
     832:	8c 2f       	mov	r24, r28
     834:	a3 de       	rcall	.-698    	; 0x57c <lcd_SendLowerNibble>
     836:	09 c0       	rjmp	.+18     	; 0x84a <LCD_DisplayChar+0x36>
     838:	d9 df       	rcall	.-78     	; 0x7ec <LCD_GoToNextLine>
     83a:	ca 30       	cpi	r28, 0x0A	; 10
     83c:	71 f0       	breq	.+28     	; 0x85a <LCD_DisplayChar+0x46>
     83e:	f4 cf       	rjmp	.-24     	; 0x828 <LCD_DisplayChar+0x14>
     840:	8c 2f       	mov	r24, r28
     842:	65 de       	rcall	.-822    	; 0x50e <lcd_SendHigherNibble>
     844:	bb de       	rcall	.-650    	; 0x5bc <lcd_SendDataSignals>
     846:	c2 95       	swap	r28
     848:	c0 7f       	andi	r28, 0xF0	; 240
     84a:	8c 2f       	mov	r24, r28
     84c:	60 de       	rcall	.-832    	; 0x50e <lcd_SendHigherNibble>
     84e:	b6 de       	rcall	.-660    	; 0x5bc <lcd_SendDataSignals>
     850:	80 91 36 01 	lds	r24, 0x0136
     854:	8f 5f       	subi	r24, 0xFF	; 255
     856:	80 93 36 01 	sts	0x0136, r24
     85a:	cf 91       	pop	r28
     85c:	08 95       	ret

0000085e <LCD_DisplayNumber.part.3>:
     85e:	af 92       	push	r10
     860:	bf 92       	push	r11
     862:	cf 92       	push	r12
     864:	df 92       	push	r13
     866:	ef 92       	push	r14
     868:	ff 92       	push	r15
     86a:	0f 93       	push	r16
     86c:	1f 93       	push	r17
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	1f 92       	push	r1
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	6b 01       	movw	r12, r22
     87a:	7c 01       	movw	r14, r24
     87c:	aa 24       	eor	r10, r10
     87e:	a3 94       	inc	r10
     880:	b1 2c       	mov	r11, r1
     882:	44 23       	and	r20, r20
     884:	e1 f0       	breq	.+56     	; 0x8be <LCD_DisplayNumber.part.3+0x60>
     886:	8f ef       	ldi	r24, 0xFF	; 255
     888:	84 0f       	add	r24, r20
     88a:	85 01       	movw	r16, r10
     88c:	02 c0       	rjmp	.+4      	; 0x892 <LCD_DisplayNumber.part.3+0x34>
     88e:	00 0f       	add	r16, r16
     890:	11 1f       	adc	r17, r17
     892:	8a 95       	dec	r24
     894:	e2 f7       	brpl	.-8      	; 0x88e <LCD_DisplayNumber.part.3+0x30>
     896:	01 2e       	mov	r0, r17
     898:	00 0c       	add	r0, r0
     89a:	22 0b       	sbc	r18, r18
     89c:	33 0b       	sbc	r19, r19
     89e:	0c 21       	and	r16, r12
     8a0:	1d 21       	and	r17, r13
     8a2:	2e 21       	and	r18, r14
     8a4:	3f 21       	and	r19, r15
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	01 2b       	or	r16, r17
     8aa:	02 2b       	or	r16, r18
     8ac:	03 2b       	or	r16, r19
     8ae:	09 f4       	brne	.+2      	; 0x8b2 <LCD_DisplayNumber.part.3+0x54>
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	80 5d       	subi	r24, 0xD0	; 208
     8b4:	49 83       	std	Y+1, r20	; 0x01
     8b6:	ae df       	rcall	.-164    	; 0x814 <LCD_DisplayChar>
     8b8:	49 81       	ldd	r20, Y+1	; 0x01
     8ba:	41 50       	subi	r20, 0x01	; 1
     8bc:	e2 cf       	rjmp	.-60     	; 0x882 <LCD_DisplayNumber.part.3+0x24>
     8be:	0f 90       	pop	r0
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
     8c4:	1f 91       	pop	r17
     8c6:	0f 91       	pop	r16
     8c8:	ff 90       	pop	r15
     8ca:	ef 90       	pop	r14
     8cc:	df 90       	pop	r13
     8ce:	cf 90       	pop	r12
     8d0:	bf 90       	pop	r11
     8d2:	af 90       	pop	r10
     8d4:	08 95       	ret

000008d6 <LCD_DisplayString>:
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	ec 01       	movw	r28, r24
     8dc:	89 91       	ld	r24, Y+
     8de:	88 23       	and	r24, r24
     8e0:	11 f0       	breq	.+4      	; 0x8e6 <LCD_DisplayString+0x10>
     8e2:	98 df       	rcall	.-208    	; 0x814 <LCD_DisplayChar>
     8e4:	fb cf       	rjmp	.-10     	; 0x8dc <LCD_DisplayString+0x6>
     8e6:	df 91       	pop	r29
     8e8:	cf 91       	pop	r28
     8ea:	08 95       	ret

000008ec <LCD_DisplayNumber>:
                8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
                9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
{
     8ec:	4f 92       	push	r4
     8ee:	5f 92       	push	r5
     8f0:	6f 92       	push	r6
     8f2:	7f 92       	push	r7
     8f4:	bf 92       	push	r11
     8f6:	cf 92       	push	r12
     8f8:	df 92       	push	r13
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	cd b7       	in	r28, 0x3d	; 61
     908:	de b7       	in	r29, 0x3e	; 62
     90a:	2a 97       	sbiw	r28, 0x0a	; 10
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	b8 2e       	mov	r11, r24
     918:	cb 01       	movw	r24, r22
     91a:	ba 01       	movw	r22, r20
     91c:	02 2f       	mov	r16, r18
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
     91e:	22 e0       	ldi	r18, 0x02	; 2
     920:	b2 12       	cpse	r11, r18
     922:	15 c0       	rjmp	.+42     	; 0x94e <LCD_DisplayNumber+0x62>
     924:	40 2f       	mov	r20, r16
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     926:	2a 96       	adiw	r28, 0x0a	; 10
     928:	0f b6       	in	r0, 0x3f	; 63
     92a:	f8 94       	cli
     92c:	de bf       	out	0x3e, r29	; 62
     92e:	0f be       	out	0x3f, r0	; 63
     930:	cd bf       	out	0x3d, r28	; 61
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	1f 91       	pop	r17
     938:	0f 91       	pop	r16
     93a:	ff 90       	pop	r15
     93c:	ef 90       	pop	r14
     93e:	df 90       	pop	r13
     940:	cf 90       	pop	r12
     942:	bf 90       	pop	r11
     944:	7f 90       	pop	r7
     946:	6f 90       	pop	r6
     948:	5f 90       	pop	r5
     94a:	4f 90       	pop	r4
     94c:	88 cf       	rjmp	.-240    	; 0x85e <LCD_DisplayNumber.part.3>
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
          LCD_DisplayChar(util_Dec2Ascii(i));
          v_numOfDigitsToDisplay_u8--;
        }        
    }    
    else if(v_number_u32==0)
     94e:	61 15       	cp	r22, r1
     950:	71 05       	cpc	r23, r1
     952:	81 05       	cpc	r24, r1
     954:	91 05       	cpc	r25, r1
     956:	49 f0       	breq	.+18     	; 0x96a <LCD_DisplayNumber+0x7e>
     958:	fe 01       	movw	r30, r28
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	6f 01       	movw	r12, r30
     95e:	7f 01       	movw	r14, r30
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     960:	4b 2c       	mov	r4, r11
     962:	51 2c       	mov	r5, r1
     964:	61 2c       	mov	r6, r1
     966:	71 2c       	mov	r7, r1
     968:	28 c0       	rjmp	.+80     	; 0x9ba <LCD_DisplayNumber+0xce>
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
     96a:	80 e3       	ldi	r24, 0x30	; 48
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     96c:	2a 96       	adiw	r28, 0x0a	; 10
     96e:	0f b6       	in	r0, 0x3f	; 63
     970:	f8 94       	cli
     972:	de bf       	out	0x3e, r29	; 62
     974:	0f be       	out	0x3f, r0	; 63
     976:	cd bf       	out	0x3d, r28	; 61
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	1f 91       	pop	r17
     97e:	0f 91       	pop	r16
     980:	ff 90       	pop	r15
     982:	ef 90       	pop	r14
     984:	df 90       	pop	r13
     986:	cf 90       	pop	r12
     988:	bf 90       	pop	r11
     98a:	7f 90       	pop	r7
     98c:	6f 90       	pop	r6
     98e:	5f 90       	pop	r5
     990:	4f 90       	pop	r4
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
     992:	40 cf       	rjmp	.-384    	; 0x814 <LCD_DisplayChar>
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToDisplay_u8 */
            if(v_number_u32!=0)
     994:	61 15       	cp	r22, r1
     996:	71 05       	cpc	r23, r1
     998:	81 05       	cpc	r24, r1
     99a:	91 05       	cpc	r25, r1
     99c:	99 f0       	breq	.+38     	; 0x9c4 <LCD_DisplayNumber+0xd8>
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     99e:	16 2f       	mov	r17, r22
     9a0:	a3 01       	movw	r20, r6
     9a2:	92 01       	movw	r18, r4
     9a4:	c8 d3       	rcall	.+1936   	; 0x1136 <__udivmodsi4>
     9a6:	ca 01       	movw	r24, r20
     9a8:	b9 01       	movw	r22, r18
     9aa:	b2 9e       	mul	r11, r18
     9ac:	10 19       	sub	r17, r0
     9ae:	11 24       	eor	r1, r1
     9b0:	f7 01       	movw	r30, r14
     9b2:	10 83       	st	Z, r17
     9b4:	ff ef       	ldi	r31, 0xFF	; 255
     9b6:	ef 1a       	sub	r14, r31
     9b8:	ff 0a       	sbc	r15, r31
     9ba:	1e 2d       	mov	r17, r14
     9bc:	1c 19       	sub	r17, r12
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
     9be:	10 17       	cp	r17, r16
     9c0:	48 f3       	brcs	.-46     	; 0x994 <LCD_DisplayNumber+0xa8>
     9c2:	0e c0       	rjmp	.+28     	; 0x9e0 <LCD_DisplayNumber+0xf4>
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
                v_number_u32=v_number_u32/v_numericSystem_u8;
            }
            else if( (v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
     9c4:	0b 30       	cpi	r16, 0x0B	; 11
     9c6:	60 f4       	brcc	.+24     	; 0x9e0 <LCD_DisplayNumber+0xf4>
            else
            {
                /* In case user expects more digits to be displayed than the actual digits in number,
                  then update the remaining digits with zero.
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
     9c8:	f7 01       	movw	r30, r14
     9ca:	10 82       	st	Z, r1
     9cc:	f3 cf       	rjmp	.-26     	; 0x9b4 <LCD_DisplayNumber+0xc8>
        }
        
         while(i!=0)
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     9ce:	fe 01       	movw	r30, r28
     9d0:	e1 0f       	add	r30, r17
     9d2:	f1 1d       	adc	r31, r1
     9d4:	80 81       	ld	r24, Z
     9d6:	8a 30       	cpi	r24, 0x0A	; 10
     9d8:	30 f0       	brcs	.+12     	; 0x9e6 <LCD_DisplayNumber+0xfa>
     9da:	89 5c       	subi	r24, 0xC9	; 201
     9dc:	1b df       	rcall	.-458    	; 0x814 <LCD_DisplayChar>
          i--;
     9de:	11 50       	subi	r17, 0x01	; 1
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
            }
        }
        
         while(i!=0)
     9e0:	11 11       	cpse	r17, r1
     9e2:	f5 cf       	rjmp	.-22     	; 0x9ce <LCD_DisplayNumber+0xe2>
     9e4:	02 c0       	rjmp	.+4      	; 0x9ea <LCD_DisplayNumber+0xfe>
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     9e6:	80 5d       	subi	r24, 0xD0	; 208
     9e8:	f9 cf       	rjmp	.-14     	; 0x9dc <LCD_DisplayNumber+0xf0>
          i--;
        }
    }
}
     9ea:	2a 96       	adiw	r28, 0x0a	; 10
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	de bf       	out	0x3e, r29	; 62
     9f2:	0f be       	out	0x3f, r0	; 63
     9f4:	cd bf       	out	0x3d, r28	; 61
     9f6:	df 91       	pop	r29
     9f8:	cf 91       	pop	r28
     9fa:	1f 91       	pop	r17
     9fc:	0f 91       	pop	r16
     9fe:	ff 90       	pop	r15
     a00:	ef 90       	pop	r14
     a02:	df 90       	pop	r13
     a04:	cf 90       	pop	r12
     a06:	bf 90       	pop	r11
     a08:	7f 90       	pop	r7
     a0a:	6f 90       	pop	r6
     a0c:	5f 90       	pop	r5
     a0e:	4f 90       	pop	r4
     a10:	08 95       	ret

00000a12 <LCD_DisplayFloatNumber>:
    Note: Float will be disabled by default as it takes huge controller resources
         It can be enabled by changing value of Enable_LCD_DisplayFloatNumber to 1 in lcd.h
***************************************************************************************************/
#if (Enable_LCD_DisplayFloatNumber == 1)  
void LCD_DisplayFloatNumber(double v_floatNum_f32)
{
     a12:	8f 92       	push	r8
     a14:	9f 92       	push	r9
     a16:	af 92       	push	r10
     a18:	bf 92       	push	r11
     a1a:	cf 92       	push	r12
     a1c:	df 92       	push	r13
     a1e:	ef 92       	push	r14
     a20:	ff 92       	push	r15
     a22:	6b 01       	movw	r12, r22
     a24:	7c 01       	movw	r14, r24
      1.Type cast the number to int to get the integer part.
      2.Display the extracted integer part followed by a decimal point(.)
      3.Later the integer part is made zero by subtracting with the extracted integer value.
      4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

    v_decNumber_u32 = (uint32_t) v_floatNum_f32;
     a26:	6a d2       	rcall	.+1236   	; 0xefc <__fixunssfsi>
     a28:	4b 01       	movw	r8, r22
     a2a:	5c 01       	movw	r10, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     a2c:	2f ef       	ldi	r18, 0xFF	; 255
     a2e:	ab 01       	movw	r20, r22
     a30:	bc 01       	movw	r22, r24
     a32:	8a e0       	ldi	r24, 0x0A	; 10
     a34:	5b df       	rcall	.-330    	; 0x8ec <LCD_DisplayNumber>

    LCD_DisplayChar('.');
     a36:	8e e2       	ldi	r24, 0x2E	; 46
     a38:	ed de       	rcall	.-550    	; 0x814 <LCD_DisplayChar>

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
     a3a:	c5 01       	movw	r24, r10
     a3c:	b4 01       	movw	r22, r8
     a3e:	8a d2       	rcall	.+1300   	; 0xf54 <__floatunsisf>
     a40:	9b 01       	movw	r18, r22
     a42:	ac 01       	movw	r20, r24
     a44:	c7 01       	movw	r24, r14
     a46:	b6 01       	movw	r22, r12
     a48:	f4 d1       	rcall	.+1000   	; 0xe32 <__subsf3>
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
     a4a:	20 e0       	ldi	r18, 0x00	; 0
     a4c:	34 e2       	ldi	r19, 0x24	; 36
     a4e:	44 e7       	ldi	r20, 0x74	; 116
     a50:	59 e4       	ldi	r21, 0x49	; 73
     a52:	0e d3       	rcall	.+1564   	; 0x1070 <__mulsf3>
     a54:	53 d2       	rcall	.+1190   	; 0xefc <__fixunssfsi>
     a56:	ab 01       	movw	r20, r22
     a58:	bc 01       	movw	r22, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     a5a:	2f ef       	ldi	r18, 0xFF	; 255
     a5c:	8a e0       	ldi	r24, 0x0A	; 10
}
     a5e:	ff 90       	pop	r15
     a60:	ef 90       	pop	r14
     a62:	df 90       	pop	r13
     a64:	cf 90       	pop	r12
     a66:	bf 90       	pop	r11
     a68:	af 90       	pop	r10
     a6a:	9f 90       	pop	r9
     a6c:	8f 90       	pop	r8

    LCD_DisplayChar('.');

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     a6e:	3e cf       	rjmp	.-388    	; 0x8ec <LCD_DisplayNumber>

00000a70 <LCD_Printf>:
        uint8_t v_Num_u8;
        LCD_Printf("num1:%u",(uint16_t)v_Num_u8); 
**************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
     a70:	cf 92       	push	r12
     a72:	df 92       	push	r13
     a74:	ef 92       	push	r14
     a76:	ff 92       	push	r15
     a78:	0f 93       	push	r16
     a7a:	1f 93       	push	r17
     a7c:	cf 93       	push	r28
     a7e:	df 93       	push	r29
     a80:	00 d0       	rcall	.+0      	; 0xa82 <LCD_Printf+0x12>
     a82:	00 d0       	rcall	.+0      	; 0xa84 <LCD_Printf+0x14>
     a84:	1f 92       	push	r1
     a86:	cd b7       	in	r28, 0x3d	; 61
     a88:	de b7       	in	r29, 0x3e	; 62
     a8a:	fe 01       	movw	r30, r28
     a8c:	70 96       	adiw	r30, 0x10	; 16
     a8e:	c1 90       	ld	r12, Z+
     a90:	d1 90       	ld	r13, Z+
    uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)  
    double v_floatNum_f32;
#endif

    va_start(argp, argList);
     a92:	8f 01       	movw	r16, r30

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     a94:	f6 01       	movw	r30, r12
     a96:	80 81       	ld	r24, Z
     a98:	88 23       	and	r24, r24
     a9a:	09 f4       	brne	.+2      	; 0xa9e <LCD_Printf+0x2e>
     a9c:	23 c1       	rjmp	.+582    	; 0xce4 <LCD_Printf+0x274>
    {

        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
     a9e:	85 32       	cpi	r24, 0x25	; 37
     aa0:	09 f0       	breq	.+2      	; 0xaa4 <LCD_Printf+0x34>
     aa2:	07 c1       	rjmp	.+526    	; 0xcb2 <LCD_Printf+0x242>
        {
            ptr++;
     aa4:	76 01       	movw	r14, r12
     aa6:	8f ef       	ldi	r24, 0xFF	; 255
     aa8:	e8 1a       	sub	r14, r24
     aaa:	f8 0a       	sbc	r15, r24
            ch = *ptr;
     aac:	f6 01       	movw	r30, r12
     aae:	81 81       	ldd	r24, Z+1	; 0x01
           if((ch>=0x30) && (ch<=0x39))
     ab0:	90 ed       	ldi	r25, 0xD0	; 208
     ab2:	98 0f       	add	r25, r24
     ab4:	9a 30       	cpi	r25, 0x0A	; 10
     ab6:	08 f0       	brcs	.+2      	; 0xaba <LCD_Printf+0x4a>
     ab8:	b4 c0       	rjmp	.+360    	; 0xc22 <LCD_Printf+0x1b2>
     aba:	20 e0       	ldi	r18, 0x00	; 0
            {
               v_numOfDigitsToDisp_u8 = 0;
               while((ch>=0x30) && (ch<=0x39))
     abc:	90 ed       	ldi	r25, 0xD0	; 208
     abe:	98 0f       	add	r25, r24
     ac0:	9a 30       	cpi	r25, 0x0A	; 10
     ac2:	58 f4       	brcc	.+22     	; 0xada <LCD_Printf+0x6a>
                {
                   v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
     ac4:	fa e0       	ldi	r31, 0x0A	; 10
     ac6:	2f 9f       	mul	r18, r31
     ac8:	90 0d       	add	r25, r0
     aca:	11 24       	eor	r1, r1
     acc:	29 2f       	mov	r18, r25
                   ptr++;
     ace:	8f ef       	ldi	r24, 0xFF	; 255
     ad0:	e8 1a       	sub	r14, r24
     ad2:	f8 0a       	sbc	r15, r24
                   ch = *ptr;
     ad4:	f7 01       	movw	r30, r14
     ad6:	80 81       	ld	r24, Z
     ad8:	f1 cf       	rjmp	.-30     	; 0xabc <LCD_Printf+0x4c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     ada:	88 35       	cpi	r24, 0x58	; 88
     adc:	09 f4       	brne	.+2      	; 0xae0 <LCD_Printf+0x70>
     ade:	a5 c0       	rjmp	.+330    	; 0xc2a <LCD_Printf+0x1ba>
     ae0:	70 f4       	brcc	.+28     	; 0xafe <LCD_Printf+0x8e>
     ae2:	84 34       	cpi	r24, 0x44	; 68
     ae4:	09 f4       	brne	.+2      	; 0xae8 <LCD_Printf+0x78>
     ae6:	4e c0       	rjmp	.+156    	; 0xb84 <LCD_Printf+0x114>
     ae8:	18 f4       	brcc	.+6      	; 0xaf0 <LCD_Printf+0x80>
     aea:	82 34       	cpi	r24, 0x42	; 66
     aec:	d9 f4       	brne	.+54     	; 0xb24 <LCD_Printf+0xb4>
     aee:	b9 c0       	rjmp	.+370    	; 0xc62 <LCD_Printf+0x1f2>
     af0:	83 35       	cpi	r24, 0x53	; 83
     af2:	09 f4       	brne	.+2      	; 0xaf6 <LCD_Printf+0x86>
     af4:	d4 c0       	rjmp	.+424    	; 0xc9e <LCD_Printf+0x22e>
     af6:	85 35       	cpi	r24, 0x55	; 85
     af8:	09 f4       	brne	.+2      	; 0xafc <LCD_Printf+0x8c>
     afa:	7a c0       	rjmp	.+244    	; 0xbf0 <LCD_Printf+0x180>
     afc:	c1 c0       	rjmp	.+386    	; 0xc80 <LCD_Printf+0x210>
     afe:	86 36       	cpi	r24, 0x66	; 102
     b00:	09 f4       	brne	.+2      	; 0xb04 <LCD_Printf+0x94>
     b02:	c0 c0       	rjmp	.+384    	; 0xc84 <LCD_Printf+0x214>
     b04:	40 f4       	brcc	.+16     	; 0xb16 <LCD_Printf+0xa6>
     b06:	83 36       	cpi	r24, 0x63	; 99
     b08:	81 f0       	breq	.+32     	; 0xb2a <LCD_Printf+0xba>
     b0a:	84 36       	cpi	r24, 0x64	; 100
     b0c:	19 f1       	breq	.+70     	; 0xb54 <LCD_Printf+0xe4>
     b0e:	82 36       	cpi	r24, 0x62	; 98
     b10:	09 f0       	breq	.+2      	; 0xb14 <LCD_Printf+0xa4>
     b12:	d1 c0       	rjmp	.+418    	; 0xcb6 <LCD_Printf+0x246>
     b14:	99 c0       	rjmp	.+306    	; 0xc48 <LCD_Printf+0x1d8>
     b16:	85 37       	cpi	r24, 0x75	; 117
     b18:	09 f4       	brne	.+2      	; 0xb1c <LCD_Printf+0xac>
     b1a:	56 c0       	rjmp	.+172    	; 0xbc8 <LCD_Printf+0x158>
     b1c:	88 37       	cpi	r24, 0x78	; 120
     b1e:	09 f4       	brne	.+2      	; 0xb22 <LCD_Printf+0xb2>
     b20:	76 c0       	rjmp	.+236    	; 0xc0e <LCD_Printf+0x19e>
     b22:	bb c0       	rjmp	.+374    	; 0xc9a <LCD_Printf+0x22a>
     b24:	83 34       	cpi	r24, 0x43	; 67
     b26:	08 f4       	brcc	.+2      	; 0xb2a <LCD_Printf+0xba>
     b28:	d8 c0       	rjmp	.+432    	; 0xcda <LCD_Printf+0x26a>
            {
            case 'C':
            case 'c':     /* Argument type is of char, hence read char data from the argp */
                ch = va_arg(argp, int);
     b2a:	68 01       	movw	r12, r16
     b2c:	f2 e0       	ldi	r31, 0x02	; 2
     b2e:	cf 0e       	add	r12, r31
     b30:	d1 1c       	adc	r13, r1
                LCD_DisplayChar(ch);
     b32:	f8 01       	movw	r30, r16
     b34:	80 81       	ld	r24, Z
     b36:	6e de       	rcall	.-804    	; 0x814 <LCD_DisplayChar>
     b38:	ba c0       	rjmp	.+372    	; 0xcae <LCD_Printf+0x23e>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b3a:	89 35       	cpi	r24, 0x59	; 89
     b3c:	00 f1       	brcs	.+64     	; 0xb7e <LCD_Printf+0x10e>
     b3e:	86 36       	cpi	r24, 0x66	; 102
     b40:	09 f4       	brne	.+2      	; 0xb44 <LCD_Printf+0xd4>
     b42:	a0 c0       	rjmp	.+320    	; 0xc84 <LCD_Printf+0x214>
     b44:	08 f0       	brcs	.+2      	; 0xb48 <LCD_Printf+0xd8>
     b46:	3d c0       	rjmp	.+122    	; 0xbc2 <LCD_Printf+0x152>
     b48:	83 36       	cpi	r24, 0x63	; 99
     b4a:	79 f3       	breq	.-34     	; 0xb2a <LCD_Printf+0xba>
     b4c:	84 36       	cpi	r24, 0x64	; 100
     b4e:	09 f0       	breq	.+2      	; 0xb52 <LCD_Printf+0xe2>
     b50:	78 c0       	rjmp	.+240    	; 0xc42 <LCD_Printf+0x1d2>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     b52:	2f ef       	ldi	r18, 0xFF	; 255
                ch = va_arg(argp, int);
                LCD_DisplayChar(ch);
                break;

            case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                v_num_s16 = va_arg(argp, int);
     b54:	68 01       	movw	r12, r16
     b56:	f2 e0       	ldi	r31, 0x02	; 2
     b58:	cf 0e       	add	r12, r31
     b5a:	d1 1c       	adc	r13, r1
     b5c:	f8 01       	movw	r30, r16
     b5e:	00 81       	ld	r16, Z
     b60:	11 81       	ldd	r17, Z+1	; 0x01
                if(v_num_s16<0)
     b62:	17 ff       	sbrs	r17, 7
     b64:	07 c0       	rjmp	.+14     	; 0xb74 <LCD_Printf+0x104>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
                   v_num_s16 = -v_num_s16;
     b66:	11 95       	neg	r17
     b68:	01 95       	neg	r16
     b6a:	11 09       	sbc	r17, r1
                   LCD_DisplayChar('-');
     b6c:	8d e2       	ldi	r24, 0x2D	; 45
     b6e:	2d 83       	std	Y+5, r18	; 0x05
     b70:	51 de       	rcall	.-862    	; 0x814 <LCD_DisplayChar>
     b72:	2d 81       	ldd	r18, Y+5	; 0x05
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
     b74:	a8 01       	movw	r20, r16
     b76:	11 0f       	add	r17, r17
     b78:	66 0b       	sbc	r22, r22
     b7a:	77 0b       	sbc	r23, r23
     b7c:	42 c0       	rjmp	.+132    	; 0xc02 <LCD_Printf+0x192>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b7e:	84 34       	cpi	r24, 0x44	; 68
     b80:	69 f5       	brne	.+90     	; 0xbdc <LCD_Printf+0x16c>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     b82:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
                break;
                
            case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                v_num_s32 = va_arg(argp, sint32_t);
     b84:	68 01       	movw	r12, r16
     b86:	f4 e0       	ldi	r31, 0x04	; 4
     b88:	cf 0e       	add	r12, r31
     b8a:	d1 1c       	adc	r13, r1
     b8c:	f8 01       	movw	r30, r16
     b8e:	40 81       	ld	r20, Z
     b90:	51 81       	ldd	r21, Z+1	; 0x01
     b92:	62 81       	ldd	r22, Z+2	; 0x02
     b94:	73 81       	ldd	r23, Z+3	; 0x03
                if(v_num_s32<0)
     b96:	77 ff       	sbrs	r23, 7
     b98:	34 c0       	rjmp	.+104    	; 0xc02 <LCD_Printf+0x192>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */
                   v_num_s32 = -v_num_s32;
     b9a:	70 95       	com	r23
     b9c:	60 95       	com	r22
     b9e:	50 95       	com	r21
     ba0:	41 95       	neg	r20
     ba2:	5f 4f       	sbci	r21, 0xFF	; 255
     ba4:	6f 4f       	sbci	r22, 0xFF	; 255
     ba6:	7f 4f       	sbci	r23, 0xFF	; 255
                   LCD_DisplayChar('-');
     ba8:	8d e2       	ldi	r24, 0x2D	; 45
     baa:	2d 83       	std	Y+5, r18	; 0x05
     bac:	49 83       	std	Y+1, r20	; 0x01
     bae:	5a 83       	std	Y+2, r21	; 0x02
     bb0:	6b 83       	std	Y+3, r22	; 0x03
     bb2:	7c 83       	std	Y+4, r23	; 0x04
     bb4:	2f de       	rcall	.-930    	; 0x814 <LCD_DisplayChar>
     bb6:	7c 81       	ldd	r23, Y+4	; 0x04
     bb8:	6b 81       	ldd	r22, Y+3	; 0x03
     bba:	5a 81       	ldd	r21, Y+2	; 0x02
     bbc:	49 81       	ldd	r20, Y+1	; 0x01
     bbe:	2d 81       	ldd	r18, Y+5	; 0x05
     bc0:	20 c0       	rjmp	.+64     	; 0xc02 <LCD_Printf+0x192>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     bc2:	85 37       	cpi	r24, 0x75	; 117
     bc4:	01 f5       	brne	.+64     	; 0xc06 <LCD_Printf+0x196>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     bc6:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToDisp_u8);              
                break;    

            case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                v_num_u16 = va_arg(argp, int);
     bc8:	68 01       	movw	r12, r16
     bca:	f2 e0       	ldi	r31, 0x02	; 2
     bcc:	cf 0e       	add	r12, r31
     bce:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
     bd0:	f8 01       	movw	r30, r16
     bd2:	40 81       	ld	r20, Z
     bd4:	51 81       	ldd	r21, Z+1	; 0x01
     bd6:	60 e0       	ldi	r22, 0x00	; 0
     bd8:	70 e0       	ldi	r23, 0x00	; 0
     bda:	13 c0       	rjmp	.+38     	; 0xc02 <LCD_Printf+0x192>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     bdc:	85 34       	cpi	r24, 0x45	; 69
     bde:	08 f4       	brcc	.+2      	; 0xbe2 <LCD_Printf+0x172>
     be0:	6f c0       	rjmp	.+222    	; 0xcc0 <LCD_Printf+0x250>
     be2:	83 35       	cpi	r24, 0x53	; 83
     be4:	09 f4       	brne	.+2      	; 0xbe8 <LCD_Printf+0x178>
     be6:	5b c0       	rjmp	.+182    	; 0xc9e <LCD_Printf+0x22e>
     be8:	85 35       	cpi	r24, 0x55	; 85
     bea:	09 f0       	breq	.+2      	; 0xbee <LCD_Printf+0x17e>
     bec:	49 c0       	rjmp	.+146    	; 0xc80 <LCD_Printf+0x210>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     bee:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;
            
            case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                v_num_u32 = va_arg(argp, uint32_t);
     bf0:	68 01       	movw	r12, r16
     bf2:	f4 e0       	ldi	r31, 0x04	; 4
     bf4:	cf 0e       	add	r12, r31
     bf6:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
     bf8:	f8 01       	movw	r30, r16
     bfa:	40 81       	ld	r20, Z
     bfc:	51 81       	ldd	r21, Z+1	; 0x01
     bfe:	62 81       	ldd	r22, Z+2	; 0x02
     c00:	73 81       	ldd	r23, Z+3	; 0x03
     c02:	8a e0       	ldi	r24, 0x0A	; 10
     c04:	1c c0       	rjmp	.+56     	; 0xc3e <LCD_Printf+0x1ce>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     c06:	88 37       	cpi	r24, 0x78	; 120
     c08:	09 f0       	breq	.+2      	; 0xc0c <LCD_Printf+0x19c>
     c0a:	47 c0       	rjmp	.+142    	; 0xc9a <LCD_Printf+0x22a>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     c0c:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u32 = va_arg(argp, uint32_t);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
                break;            

            case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u16 = va_arg(argp, int);
     c0e:	68 01       	movw	r12, r16
     c10:	f2 e0       	ldi	r31, 0x02	; 2
     c12:	cf 0e       	add	r12, r31
     c14:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
     c16:	f8 01       	movw	r30, r16
     c18:	40 81       	ld	r20, Z
     c1a:	51 81       	ldd	r21, Z+1	; 0x01
     c1c:	60 e0       	ldi	r22, 0x00	; 0
     c1e:	70 e0       	ldi	r23, 0x00	; 0
     c20:	0d c0       	rjmp	.+26     	; 0xc3c <LCD_Printf+0x1cc>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     c22:	88 35       	cpi	r24, 0x58	; 88
     c24:	09 f0       	breq	.+2      	; 0xc28 <LCD_Printf+0x1b8>
     c26:	89 cf       	rjmp	.-238    	; 0xb3a <LCD_Printf+0xca>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     c28:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;

            case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u32 = va_arg(argp, uint32_t);
     c2a:	68 01       	movw	r12, r16
     c2c:	f4 e0       	ldi	r31, 0x04	; 4
     c2e:	cf 0e       	add	r12, r31
     c30:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
     c32:	f8 01       	movw	r30, r16
     c34:	40 81       	ld	r20, Z
     c36:	51 81       	ldd	r21, Z+1	; 0x01
     c38:	62 81       	ldd	r22, Z+2	; 0x02
     c3a:	73 81       	ldd	r23, Z+3	; 0x03
     c3c:	80 e1       	ldi	r24, 0x10	; 16
     c3e:	56 de       	rcall	.-852    	; 0x8ec <LCD_DisplayNumber>
     c40:	36 c0       	rjmp	.+108    	; 0xcae <LCD_Printf+0x23e>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     c42:	82 36       	cpi	r24, 0x62	; 98
     c44:	c1 f5       	brne	.+112    	; 0xcb6 <LCD_Printf+0x246>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     c46:	2f ef       	ldi	r18, 0xFF	; 255
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
                break;

            
            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u16 = va_arg(argp, int);
     c48:	68 01       	movw	r12, r16
     c4a:	f2 e0       	ldi	r31, 0x02	; 2
     c4c:	cf 0e       	add	r12, r31
     c4e:	d1 1c       	adc	r13, r1
     c50:	f8 01       	movw	r30, r16
     c52:	60 81       	ld	r22, Z
     c54:	71 81       	ldd	r23, Z+1	; 0x01
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
     c56:	2f 3f       	cpi	r18, 0xFF	; 255
     c58:	09 f4       	brne	.+2      	; 0xc5c <LCD_Printf+0x1ec>
                   v_numOfDigitsToDisp_u8 = 16;
     c5a:	20 e1       	ldi	r18, 0x10	; 16
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	0c c0       	rjmp	.+24     	; 0xc7a <LCD_Printf+0x20a>
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
     c62:	68 01       	movw	r12, r16
     c64:	f4 e0       	ldi	r31, 0x04	; 4
     c66:	cf 0e       	add	r12, r31
     c68:	d1 1c       	adc	r13, r1
     c6a:	f8 01       	movw	r30, r16
     c6c:	60 81       	ld	r22, Z
     c6e:	71 81       	ldd	r23, Z+1	; 0x01
     c70:	82 81       	ldd	r24, Z+2	; 0x02
     c72:	93 81       	ldd	r25, Z+3	; 0x03
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
     c74:	2f 3f       	cpi	r18, 0xFF	; 255
     c76:	09 f4       	brne	.+2      	; 0xc7a <LCD_Printf+0x20a>
                   v_numOfDigitsToDisp_u8 = 16;                
     c78:	20 e1       	ldi	r18, 0x10	; 16
     c7a:	42 2f       	mov	r20, r18
     c7c:	f0 dd       	rcall	.-1056   	; 0x85e <LCD_DisplayNumber.part.3>
     c7e:	17 c0       	rjmp	.+46     	; 0xcae <LCD_Printf+0x23e>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     c80:	86 34       	cpi	r24, 0x46	; 70
     c82:	c9 f4       	brne	.+50     	; 0xcb6 <LCD_Printf+0x246>


            case 'F':
            case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)  
                v_floatNum_f32 = va_arg(argp, double);              
     c84:	68 01       	movw	r12, r16
     c86:	f4 e0       	ldi	r31, 0x04	; 4
     c88:	cf 0e       	add	r12, r31
     c8a:	d1 1c       	adc	r13, r1
                LCD_DisplayFloatNumber(v_floatNum_f32);
     c8c:	f8 01       	movw	r30, r16
     c8e:	60 81       	ld	r22, Z
     c90:	71 81       	ldd	r23, Z+1	; 0x01
     c92:	82 81       	ldd	r24, Z+2	; 0x02
     c94:	93 81       	ldd	r25, Z+3	; 0x03
     c96:	bd de       	rcall	.-646    	; 0xa12 <LCD_DisplayFloatNumber>
     c98:	0a c0       	rjmp	.+20     	; 0xcae <LCD_Printf+0x23e>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     c9a:	83 37       	cpi	r24, 0x73	; 115
     c9c:	61 f4       	brne	.+24     	; 0xcb6 <LCD_Printf+0x246>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
     c9e:	68 01       	movw	r12, r16
     ca0:	f2 e0       	ldi	r31, 0x02	; 2
     ca2:	cf 0e       	add	r12, r31
     ca4:	d1 1c       	adc	r13, r1
                LCD_DisplayString(str);                
     ca6:	f8 01       	movw	r30, r16
     ca8:	80 81       	ld	r24, Z
     caa:	91 81       	ldd	r25, Z+1	; 0x01
     cac:	14 de       	rcall	.-984    	; 0x8d6 <LCD_DisplayString>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
     cae:	86 01       	movw	r16, r12
                LCD_DisplayString(str);                
                break;
     cb0:	02 c0       	rjmp	.+4      	; 0xcb6 <LCD_Printf+0x246>
            }
        }
        else
        {
            /* As '%' is not detected display/transmit the char passed */
            LCD_DisplayChar(ch);
     cb2:	b0 dd       	rcall	.-1184   	; 0x814 <LCD_DisplayChar>
     cb4:	76 01       	movw	r14, r12
#endif

    va_start(argp, argList);

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     cb6:	67 01       	movw	r12, r14
     cb8:	ff ef       	ldi	r31, 0xFF	; 255
     cba:	cf 1a       	sub	r12, r31
     cbc:	df 0a       	sbc	r13, r31
     cbe:	ea ce       	rjmp	.-556    	; 0xa94 <LCD_Printf+0x24>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     cc0:	82 34       	cpi	r24, 0x42	; 66
     cc2:	09 f0       	breq	.+2      	; 0xcc6 <LCD_Printf+0x256>
     cc4:	2f cf       	rjmp	.-418    	; 0xb24 <LCD_Printf+0xb4>
                   v_numOfDigitsToDisp_u8 = 16;
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
     cc6:	68 01       	movw	r12, r16
     cc8:	f4 e0       	ldi	r31, 0x04	; 4
     cca:	cf 0e       	add	r12, r31
     ccc:	d1 1c       	adc	r13, r1
     cce:	f8 01       	movw	r30, r16
     cd0:	60 81       	ld	r22, Z
     cd2:	71 81       	ldd	r23, Z+1	; 0x01
     cd4:	82 81       	ldd	r24, Z+2	; 0x02
     cd6:	93 81       	ldd	r25, Z+3	; 0x03
     cd8:	cf cf       	rjmp	.-98     	; 0xc78 <LCD_Printf+0x208>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     cda:	85 32       	cpi	r24, 0x25	; 37
     cdc:	61 f7       	brne	.-40     	; 0xcb6 <LCD_Printf+0x246>
                str = va_arg(argp, char *);
                LCD_DisplayString(str);                
                break;

            case '%':
                LCD_DisplayChar('%');
     cde:	85 e2       	ldi	r24, 0x25	; 37
     ce0:	99 dd       	rcall	.-1230   	; 0x814 <LCD_DisplayChar>
                break;
     ce2:	e9 cf       	rjmp	.-46     	; 0xcb6 <LCD_Printf+0x246>
            LCD_DisplayChar(ch);
        }
    }

    va_end(argp);
}
     ce4:	0f 90       	pop	r0
     ce6:	0f 90       	pop	r0
     ce8:	0f 90       	pop	r0
     cea:	0f 90       	pop	r0
     cec:	0f 90       	pop	r0
     cee:	df 91       	pop	r29
     cf0:	cf 91       	pop	r28
     cf2:	1f 91       	pop	r17
     cf4:	0f 91       	pop	r16
     cf6:	ff 90       	pop	r15
     cf8:	ef 90       	pop	r14
     cfa:	df 90       	pop	r13
     cfc:	cf 90       	pop	r12
     cfe:	08 95       	ret

00000d00 <RTC_Init>:

 * description :This function is used to Initialize the Ds1307 RTC.
***************************************************************************************************/
void RTC_Init(void)
{
    I2C_Init();                             // Initialize the I2c module.
     d00:	d7 db       	rcall	.-2130   	; 0x4b0 <I2C_Init>
    I2C_Start();                            // Start I2C communication
     d02:	df db       	rcall	.-2114   	; 0x4c2 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
     d04:	80 ed       	ldi	r24, 0xD0	; 208
     d06:	eb db       	rcall	.-2090   	; 0x4de <I2C_Write>
    I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
     d08:	87 e0       	ldi	r24, 0x07	; 7
     d0a:	e9 db       	rcall	.-2094   	; 0x4de <I2C_Write>

    I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
     d0c:	80 e0       	ldi	r24, 0x00	; 0
     d0e:	e7 db       	rcall	.-2098   	; 0x4de <I2C_Write>

    I2C_Stop();                             // Stop I2C communication after initializing DS1307
     d10:	e0 cb       	rjmp	.-2112   	; 0x4d2 <I2C_Stop>

00000d12 <RTC_SetDateTime>:
        Note: The date and time should be of BCD format, 
             like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
                  0x15,0x08,0x47 for 15th day,8th month and 47th year.                 
***************************************************************************************************/
void RTC_SetDateTime(rtc_t *rtc)
{
     d12:	cf 93       	push	r28
     d14:	df 93       	push	r29
     d16:	ec 01       	movw	r28, r24
    I2C_Start();                          // Start I2C communication
     d18:	d4 db       	rcall	.-2136   	; 0x4c2 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);      // connect to DS1307 by sending its ID on I2c Bus
     d1a:	80 ed       	ldi	r24, 0xD0	; 208
     d1c:	e0 db       	rcall	.-2112   	; 0x4de <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request sec RAM address at 00H
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	de db       	rcall	.-2116   	; 0x4de <I2C_Write>

    I2C_Write(rtc->sec);                    // Write sec from RAM address 00H
     d22:	88 81       	ld	r24, Y
     d24:	dc db       	rcall	.-2120   	; 0x4de <I2C_Write>
    I2C_Write(rtc->min);                    // Write min from RAM address 01H
     d26:	89 81       	ldd	r24, Y+1	; 0x01
     d28:	da db       	rcall	.-2124   	; 0x4de <I2C_Write>
    I2C_Write(rtc->hour);                    // Write hour from RAM address 02H
     d2a:	8a 81       	ldd	r24, Y+2	; 0x02
     d2c:	d8 db       	rcall	.-2128   	; 0x4de <I2C_Write>
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
     d2e:	8b 81       	ldd	r24, Y+3	; 0x03
     d30:	d6 db       	rcall	.-2132   	; 0x4de <I2C_Write>
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
     d32:	8c 81       	ldd	r24, Y+4	; 0x04
     d34:	d4 db       	rcall	.-2136   	; 0x4de <I2C_Write>
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
     d36:	8d 81       	ldd	r24, Y+5	; 0x05
     d38:	d2 db       	rcall	.-2140   	; 0x4de <I2C_Write>
    I2C_Write(rtc->year);                    // Write year on RAM address 06h
     d3a:	8e 81       	ldd	r24, Y+6	; 0x06
     d3c:	d0 db       	rcall	.-2144   	; 0x4de <I2C_Write>

    I2C_Stop();                              // Stop I2C communication after Setting the Date
}
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
    I2C_Write(rtc->year);                    // Write year on RAM address 06h

    I2C_Stop();                              // Stop I2C communication after Setting the Date
     d42:	c7 cb       	rjmp	.-2162   	; 0x4d2 <I2C_Stop>

00000d44 <RTC_GetDateTime>:
    Note: The date and time read from Ds1307 will be of BCD format, 
          like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
               0x15,0x08,0x47 for 15th day,8th month and 47th year.              
***************************************************************************************************/
void RTC_GetDateTime(rtc_t *rtc)
{
     d44:	cf 93       	push	r28
     d46:	df 93       	push	r29
     d48:	ec 01       	movw	r28, r24
    I2C_Start();                            // Start I2C communication
     d4a:	bb db       	rcall	.-2186   	; 0x4c2 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
     d4c:	80 ed       	ldi	r24, 0xD0	; 208
     d4e:	c7 db       	rcall	.-2162   	; 0x4de <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
     d50:	80 e0       	ldi	r24, 0x00	; 0
     d52:	c5 db       	rcall	.-2166   	; 0x4de <I2C_Write>

    I2C_Stop();                                // Stop I2C communication after selecting Sec Register
     d54:	be db       	rcall	.-2180   	; 0x4d2 <I2C_Stop>

    I2C_Start();                            // Start I2C communication
     d56:	b5 db       	rcall	.-2198   	; 0x4c2 <I2C_Start>
    I2C_Write(C_Ds1307ReadMode_U8);            // connect to DS1307(Read mode) by sending its ID
     d58:	81 ed       	ldi	r24, 0xD1	; 209
     d5a:	c1 db       	rcall	.-2174   	; 0x4de <I2C_Write>

    rtc->sec = I2C_Read(1);                // read second and return Positive ACK
     d5c:	81 e0       	ldi	r24, 0x01	; 1
     d5e:	c9 db       	rcall	.-2158   	; 0x4f2 <I2C_Read>
     d60:	88 83       	st	Y, r24
    rtc->min = I2C_Read(1);                 // read minute and return Positive ACK
     d62:	81 e0       	ldi	r24, 0x01	; 1
     d64:	c6 db       	rcall	.-2164   	; 0x4f2 <I2C_Read>
     d66:	89 83       	std	Y+1, r24	; 0x01
    rtc->hour= I2C_Read(1);               // read hour and return Negative/No ACK
     d68:	81 e0       	ldi	r24, 0x01	; 1
     d6a:	c3 db       	rcall	.-2170   	; 0x4f2 <I2C_Read>
     d6c:	8a 83       	std	Y+2, r24	; 0x02
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	c0 db       	rcall	.-2176   	; 0x4f2 <I2C_Read>
     d72:	8b 83       	std	Y+3, r24	; 0x03
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	bd db       	rcall	.-2182   	; 0x4f2 <I2C_Read>
     d78:	8c 83       	std	Y+4, r24	; 0x04
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	ba db       	rcall	.-2188   	; 0x4f2 <I2C_Read>
     d7e:	8d 83       	std	Y+5, r24	; 0x05
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	b7 db       	rcall	.-2194   	; 0x4f2 <I2C_Read>
     d84:	8e 83       	std	Y+6, r24	; 0x06

    I2C_Stop();                              // Stop I2C communication after reading the Date
}
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK

    I2C_Stop();                              // Stop I2C communication after reading the Date
     d8a:	a3 cb       	rjmp	.-2234   	; 0x4d2 <I2C_Stop>

00000d8c <main>:
#include <avr/io.h>
#include "rtc.h"
#include "lcd.h"

int main() 
{
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	cd b7       	in	r28, 0x3d	; 61
     d92:	de b7       	in	r29, 0x3e	; 62
     d94:	27 97       	sbiw	r28, 0x07	; 7
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	de bf       	out	0x3e, r29	; 62
     d9c:	0f be       	out	0x3f, r0	; 63
     d9e:	cd bf       	out	0x3d, r28	; 61
    rtc_t rtc;

    /*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
    LCD_SetUp(PB_0,PB_1,PB_2,P_NC,P_NC,P_NC,P_NC,PB_4,PB_5,PB_6,PB_7);
     da0:	8f e0       	ldi	r24, 0x0F	; 15
     da2:	8f 93       	push	r24
     da4:	8e e0       	ldi	r24, 0x0E	; 14
     da6:	8f 93       	push	r24
     da8:	8d e0       	ldi	r24, 0x0D	; 13
     daa:	88 2e       	mov	r8, r24
     dac:	9c e0       	ldi	r25, 0x0C	; 12
     dae:	a9 2e       	mov	r10, r25
     db0:	cc 24       	eor	r12, r12
     db2:	ca 94       	dec	r12
     db4:	ee 24       	eor	r14, r14
     db6:	ea 94       	dec	r14
     db8:	0f ef       	ldi	r16, 0xFF	; 255
     dba:	2f ef       	ldi	r18, 0xFF	; 255
     dbc:	4a e0       	ldi	r20, 0x0A	; 10
     dbe:	69 e0       	ldi	r22, 0x09	; 9
     dc0:	88 e0       	ldi	r24, 0x08	; 8
     dc2:	52 dc       	rcall	.-1884   	; 0x668 <LCD_SetUp>
    LCD_Init(2,16);
     dc4:	60 e1       	ldi	r22, 0x10	; 16
     dc6:	82 e0       	ldi	r24, 0x02	; 2
     dc8:	db dc       	rcall	.-1610   	; 0x780 <LCD_Init>
	
    /*Connect SCL->PC0, SDA->PC1*/    
    RTC_Init();
     dca:	9a df       	rcall	.-204    	; 0xd00 <RTC_Init>
    rtc.hour = 0x10; //  10:40:20 am
     dcc:	80 e1       	ldi	r24, 0x10	; 16
     dce:	8b 83       	std	Y+3, r24	; 0x03
    rtc.min =  0x40;
     dd0:	80 e4       	ldi	r24, 0x40	; 64
     dd2:	8a 83       	std	Y+2, r24	; 0x02
    rtc.sec =  0x00;
     dd4:	19 82       	std	Y+1, r1	; 0x01

    rtc.date = 0x01; //1st Jan 2016
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	8d 83       	std	Y+5, r24	; 0x05
    rtc.month = 0x01;
     dda:	8e 83       	std	Y+6, r24	; 0x06
    rtc.year = 0x16;
     ddc:	86 e1       	ldi	r24, 0x16	; 22
     dde:	8f 83       	std	Y+7, r24	; 0x07
    rtc.weekDay = 5; // Friday: 5th day of week considering monday as first day.
     de0:	85 e0       	ldi	r24, 0x05	; 5
     de2:	8c 83       	std	Y+4, r24	; 0x04
    /*##### Set the time and Date only once. Once the Time and Date is set, comment these lines
         and reflash the code. Else the time will be set every time the controller is reset*/
    RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
     de4:	ce 01       	movw	r24, r28
     de6:	01 96       	adiw	r24, 0x01	; 1
     de8:	94 df       	rcall	.-216    	; 0xd12 <RTC_SetDateTime>
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
        LCD_GoToLine(0);
        LCD_Printf("time:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
     dee:	04 e0       	ldi	r16, 0x04	; 4
     df0:	11 e0       	ldi	r17, 0x01	; 1
         and reflash the code. Else the time will be set every time the controller is reset*/
    RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
     df2:	ce 01       	movw	r24, r28
     df4:	01 96       	adiw	r24, 0x01	; 1
     df6:	a6 df       	rcall	.-180    	; 0xd44 <RTC_GetDateTime>
        LCD_GoToLine(0);
     df8:	80 e0       	ldi	r24, 0x00	; 0
     dfa:	af dc       	rcall	.-1698   	; 0x75a <LCD_GoToLine>
        LCD_Printf("time:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
     dfc:	8f 81       	ldd	r24, Y+7	; 0x07
     dfe:	1f 92       	push	r1
     e00:	8f 93       	push	r24
     e02:	8e 81       	ldd	r24, Y+6	; 0x06
     e04:	1f 92       	push	r1
     e06:	8f 93       	push	r24
     e08:	8d 81       	ldd	r24, Y+5	; 0x05
     e0a:	1f 92       	push	r1
     e0c:	8f 93       	push	r24
     e0e:	89 81       	ldd	r24, Y+1	; 0x01
     e10:	1f 92       	push	r1
     e12:	8f 93       	push	r24
     e14:	8a 81       	ldd	r24, Y+2	; 0x02
     e16:	1f 92       	push	r1
     e18:	8f 93       	push	r24
     e1a:	8b 81       	ldd	r24, Y+3	; 0x03
     e1c:	1f 92       	push	r1
     e1e:	8f 93       	push	r24
     e20:	1f 93       	push	r17
     e22:	0f 93       	push	r16
     e24:	25 de       	rcall	.-950    	; 0xa70 <LCD_Printf>
    }
     e26:	0f b6       	in	r0, 0x3f	; 63
     e28:	f8 94       	cli
     e2a:	de bf       	out	0x3e, r29	; 62
     e2c:	0f be       	out	0x3f, r0	; 63
     e2e:	cd bf       	out	0x3d, r28	; 61
     e30:	e0 cf       	rjmp	.-64     	; 0xdf2 <main+0x66>

00000e32 <__subsf3>:
     e32:	50 58       	subi	r21, 0x80	; 128

00000e34 <__addsf3>:
     e34:	bb 27       	eor	r27, r27
     e36:	aa 27       	eor	r26, r26
     e38:	0e d0       	rcall	.+28     	; 0xe56 <__addsf3x>
     e3a:	e0 c0       	rjmp	.+448    	; 0xffc <__fp_round>
     e3c:	d1 d0       	rcall	.+418    	; 0xfe0 <__fp_pscA>
     e3e:	30 f0       	brcs	.+12     	; 0xe4c <__addsf3+0x18>
     e40:	d6 d0       	rcall	.+428    	; 0xfee <__fp_pscB>
     e42:	20 f0       	brcs	.+8      	; 0xe4c <__addsf3+0x18>
     e44:	31 f4       	brne	.+12     	; 0xe52 <__addsf3+0x1e>
     e46:	9f 3f       	cpi	r25, 0xFF	; 255
     e48:	11 f4       	brne	.+4      	; 0xe4e <__addsf3+0x1a>
     e4a:	1e f4       	brtc	.+6      	; 0xe52 <__addsf3+0x1e>
     e4c:	c6 c0       	rjmp	.+396    	; 0xfda <__fp_nan>
     e4e:	0e f4       	brtc	.+2      	; 0xe52 <__addsf3+0x1e>
     e50:	e0 95       	com	r30
     e52:	e7 fb       	bst	r30, 7
     e54:	bc c0       	rjmp	.+376    	; 0xfce <__fp_inf>

00000e56 <__addsf3x>:
     e56:	e9 2f       	mov	r30, r25
     e58:	e2 d0       	rcall	.+452    	; 0x101e <__fp_split3>
     e5a:	80 f3       	brcs	.-32     	; 0xe3c <__addsf3+0x8>
     e5c:	ba 17       	cp	r27, r26
     e5e:	62 07       	cpc	r22, r18
     e60:	73 07       	cpc	r23, r19
     e62:	84 07       	cpc	r24, r20
     e64:	95 07       	cpc	r25, r21
     e66:	18 f0       	brcs	.+6      	; 0xe6e <__addsf3x+0x18>
     e68:	71 f4       	brne	.+28     	; 0xe86 <__addsf3x+0x30>
     e6a:	9e f5       	brtc	.+102    	; 0xed2 <__addsf3x+0x7c>
     e6c:	fa c0       	rjmp	.+500    	; 0x1062 <__fp_zero>
     e6e:	0e f4       	brtc	.+2      	; 0xe72 <__addsf3x+0x1c>
     e70:	e0 95       	com	r30
     e72:	0b 2e       	mov	r0, r27
     e74:	ba 2f       	mov	r27, r26
     e76:	a0 2d       	mov	r26, r0
     e78:	0b 01       	movw	r0, r22
     e7a:	b9 01       	movw	r22, r18
     e7c:	90 01       	movw	r18, r0
     e7e:	0c 01       	movw	r0, r24
     e80:	ca 01       	movw	r24, r20
     e82:	a0 01       	movw	r20, r0
     e84:	11 24       	eor	r1, r1
     e86:	ff 27       	eor	r31, r31
     e88:	59 1b       	sub	r21, r25
     e8a:	99 f0       	breq	.+38     	; 0xeb2 <__addsf3x+0x5c>
     e8c:	59 3f       	cpi	r21, 0xF9	; 249
     e8e:	50 f4       	brcc	.+20     	; 0xea4 <__addsf3x+0x4e>
     e90:	50 3e       	cpi	r21, 0xE0	; 224
     e92:	68 f1       	brcs	.+90     	; 0xeee <__addsf3x+0x98>
     e94:	1a 16       	cp	r1, r26
     e96:	f0 40       	sbci	r31, 0x00	; 0
     e98:	a2 2f       	mov	r26, r18
     e9a:	23 2f       	mov	r18, r19
     e9c:	34 2f       	mov	r19, r20
     e9e:	44 27       	eor	r20, r20
     ea0:	58 5f       	subi	r21, 0xF8	; 248
     ea2:	f3 cf       	rjmp	.-26     	; 0xe8a <__addsf3x+0x34>
     ea4:	46 95       	lsr	r20
     ea6:	37 95       	ror	r19
     ea8:	27 95       	ror	r18
     eaa:	a7 95       	ror	r26
     eac:	f0 40       	sbci	r31, 0x00	; 0
     eae:	53 95       	inc	r21
     eb0:	c9 f7       	brne	.-14     	; 0xea4 <__addsf3x+0x4e>
     eb2:	7e f4       	brtc	.+30     	; 0xed2 <__addsf3x+0x7c>
     eb4:	1f 16       	cp	r1, r31
     eb6:	ba 0b       	sbc	r27, r26
     eb8:	62 0b       	sbc	r22, r18
     eba:	73 0b       	sbc	r23, r19
     ebc:	84 0b       	sbc	r24, r20
     ebe:	ba f0       	brmi	.+46     	; 0xeee <__addsf3x+0x98>
     ec0:	91 50       	subi	r25, 0x01	; 1
     ec2:	a1 f0       	breq	.+40     	; 0xeec <__addsf3x+0x96>
     ec4:	ff 0f       	add	r31, r31
     ec6:	bb 1f       	adc	r27, r27
     ec8:	66 1f       	adc	r22, r22
     eca:	77 1f       	adc	r23, r23
     ecc:	88 1f       	adc	r24, r24
     ece:	c2 f7       	brpl	.-16     	; 0xec0 <__addsf3x+0x6a>
     ed0:	0e c0       	rjmp	.+28     	; 0xeee <__addsf3x+0x98>
     ed2:	ba 0f       	add	r27, r26
     ed4:	62 1f       	adc	r22, r18
     ed6:	73 1f       	adc	r23, r19
     ed8:	84 1f       	adc	r24, r20
     eda:	48 f4       	brcc	.+18     	; 0xeee <__addsf3x+0x98>
     edc:	87 95       	ror	r24
     ede:	77 95       	ror	r23
     ee0:	67 95       	ror	r22
     ee2:	b7 95       	ror	r27
     ee4:	f7 95       	ror	r31
     ee6:	9e 3f       	cpi	r25, 0xFE	; 254
     ee8:	08 f0       	brcs	.+2      	; 0xeec <__addsf3x+0x96>
     eea:	b3 cf       	rjmp	.-154    	; 0xe52 <__addsf3+0x1e>
     eec:	93 95       	inc	r25
     eee:	88 0f       	add	r24, r24
     ef0:	08 f0       	brcs	.+2      	; 0xef4 <__addsf3x+0x9e>
     ef2:	99 27       	eor	r25, r25
     ef4:	ee 0f       	add	r30, r30
     ef6:	97 95       	ror	r25
     ef8:	87 95       	ror	r24
     efa:	08 95       	ret

00000efc <__fixunssfsi>:
     efc:	98 d0       	rcall	.+304    	; 0x102e <__fp_splitA>
     efe:	88 f0       	brcs	.+34     	; 0xf22 <__fixunssfsi+0x26>
     f00:	9f 57       	subi	r25, 0x7F	; 127
     f02:	90 f0       	brcs	.+36     	; 0xf28 <__fixunssfsi+0x2c>
     f04:	b9 2f       	mov	r27, r25
     f06:	99 27       	eor	r25, r25
     f08:	b7 51       	subi	r27, 0x17	; 23
     f0a:	a0 f0       	brcs	.+40     	; 0xf34 <__fixunssfsi+0x38>
     f0c:	d1 f0       	breq	.+52     	; 0xf42 <__fixunssfsi+0x46>
     f0e:	66 0f       	add	r22, r22
     f10:	77 1f       	adc	r23, r23
     f12:	88 1f       	adc	r24, r24
     f14:	99 1f       	adc	r25, r25
     f16:	1a f0       	brmi	.+6      	; 0xf1e <__fixunssfsi+0x22>
     f18:	ba 95       	dec	r27
     f1a:	c9 f7       	brne	.-14     	; 0xf0e <__fixunssfsi+0x12>
     f1c:	12 c0       	rjmp	.+36     	; 0xf42 <__fixunssfsi+0x46>
     f1e:	b1 30       	cpi	r27, 0x01	; 1
     f20:	81 f0       	breq	.+32     	; 0xf42 <__fixunssfsi+0x46>
     f22:	9f d0       	rcall	.+318    	; 0x1062 <__fp_zero>
     f24:	b1 e0       	ldi	r27, 0x01	; 1
     f26:	08 95       	ret
     f28:	9c c0       	rjmp	.+312    	; 0x1062 <__fp_zero>
     f2a:	67 2f       	mov	r22, r23
     f2c:	78 2f       	mov	r23, r24
     f2e:	88 27       	eor	r24, r24
     f30:	b8 5f       	subi	r27, 0xF8	; 248
     f32:	39 f0       	breq	.+14     	; 0xf42 <__fixunssfsi+0x46>
     f34:	b9 3f       	cpi	r27, 0xF9	; 249
     f36:	cc f3       	brlt	.-14     	; 0xf2a <__fixunssfsi+0x2e>
     f38:	86 95       	lsr	r24
     f3a:	77 95       	ror	r23
     f3c:	67 95       	ror	r22
     f3e:	b3 95       	inc	r27
     f40:	d9 f7       	brne	.-10     	; 0xf38 <__fixunssfsi+0x3c>
     f42:	3e f4       	brtc	.+14     	; 0xf52 <__fixunssfsi+0x56>
     f44:	90 95       	com	r25
     f46:	80 95       	com	r24
     f48:	70 95       	com	r23
     f4a:	61 95       	neg	r22
     f4c:	7f 4f       	sbci	r23, 0xFF	; 255
     f4e:	8f 4f       	sbci	r24, 0xFF	; 255
     f50:	9f 4f       	sbci	r25, 0xFF	; 255
     f52:	08 95       	ret

00000f54 <__floatunsisf>:
     f54:	e8 94       	clt
     f56:	09 c0       	rjmp	.+18     	; 0xf6a <__floatsisf+0x12>

00000f58 <__floatsisf>:
     f58:	97 fb       	bst	r25, 7
     f5a:	3e f4       	brtc	.+14     	; 0xf6a <__floatsisf+0x12>
     f5c:	90 95       	com	r25
     f5e:	80 95       	com	r24
     f60:	70 95       	com	r23
     f62:	61 95       	neg	r22
     f64:	7f 4f       	sbci	r23, 0xFF	; 255
     f66:	8f 4f       	sbci	r24, 0xFF	; 255
     f68:	9f 4f       	sbci	r25, 0xFF	; 255
     f6a:	99 23       	and	r25, r25
     f6c:	a9 f0       	breq	.+42     	; 0xf98 <__floatsisf+0x40>
     f6e:	f9 2f       	mov	r31, r25
     f70:	96 e9       	ldi	r25, 0x96	; 150
     f72:	bb 27       	eor	r27, r27
     f74:	93 95       	inc	r25
     f76:	f6 95       	lsr	r31
     f78:	87 95       	ror	r24
     f7a:	77 95       	ror	r23
     f7c:	67 95       	ror	r22
     f7e:	b7 95       	ror	r27
     f80:	f1 11       	cpse	r31, r1
     f82:	f8 cf       	rjmp	.-16     	; 0xf74 <__floatsisf+0x1c>
     f84:	fa f4       	brpl	.+62     	; 0xfc4 <__floatsisf+0x6c>
     f86:	bb 0f       	add	r27, r27
     f88:	11 f4       	brne	.+4      	; 0xf8e <__floatsisf+0x36>
     f8a:	60 ff       	sbrs	r22, 0
     f8c:	1b c0       	rjmp	.+54     	; 0xfc4 <__floatsisf+0x6c>
     f8e:	6f 5f       	subi	r22, 0xFF	; 255
     f90:	7f 4f       	sbci	r23, 0xFF	; 255
     f92:	8f 4f       	sbci	r24, 0xFF	; 255
     f94:	9f 4f       	sbci	r25, 0xFF	; 255
     f96:	16 c0       	rjmp	.+44     	; 0xfc4 <__floatsisf+0x6c>
     f98:	88 23       	and	r24, r24
     f9a:	11 f0       	breq	.+4      	; 0xfa0 <__floatsisf+0x48>
     f9c:	96 e9       	ldi	r25, 0x96	; 150
     f9e:	11 c0       	rjmp	.+34     	; 0xfc2 <__floatsisf+0x6a>
     fa0:	77 23       	and	r23, r23
     fa2:	21 f0       	breq	.+8      	; 0xfac <__floatsisf+0x54>
     fa4:	9e e8       	ldi	r25, 0x8E	; 142
     fa6:	87 2f       	mov	r24, r23
     fa8:	76 2f       	mov	r23, r22
     faa:	05 c0       	rjmp	.+10     	; 0xfb6 <__floatsisf+0x5e>
     fac:	66 23       	and	r22, r22
     fae:	71 f0       	breq	.+28     	; 0xfcc <__floatsisf+0x74>
     fb0:	96 e8       	ldi	r25, 0x86	; 134
     fb2:	86 2f       	mov	r24, r22
     fb4:	70 e0       	ldi	r23, 0x00	; 0
     fb6:	60 e0       	ldi	r22, 0x00	; 0
     fb8:	2a f0       	brmi	.+10     	; 0xfc4 <__floatsisf+0x6c>
     fba:	9a 95       	dec	r25
     fbc:	66 0f       	add	r22, r22
     fbe:	77 1f       	adc	r23, r23
     fc0:	88 1f       	adc	r24, r24
     fc2:	da f7       	brpl	.-10     	; 0xfba <__floatsisf+0x62>
     fc4:	88 0f       	add	r24, r24
     fc6:	96 95       	lsr	r25
     fc8:	87 95       	ror	r24
     fca:	97 f9       	bld	r25, 7
     fcc:	08 95       	ret

00000fce <__fp_inf>:
     fce:	97 f9       	bld	r25, 7
     fd0:	9f 67       	ori	r25, 0x7F	; 127
     fd2:	80 e8       	ldi	r24, 0x80	; 128
     fd4:	70 e0       	ldi	r23, 0x00	; 0
     fd6:	60 e0       	ldi	r22, 0x00	; 0
     fd8:	08 95       	ret

00000fda <__fp_nan>:
     fda:	9f ef       	ldi	r25, 0xFF	; 255
     fdc:	80 ec       	ldi	r24, 0xC0	; 192
     fde:	08 95       	ret

00000fe0 <__fp_pscA>:
     fe0:	00 24       	eor	r0, r0
     fe2:	0a 94       	dec	r0
     fe4:	16 16       	cp	r1, r22
     fe6:	17 06       	cpc	r1, r23
     fe8:	18 06       	cpc	r1, r24
     fea:	09 06       	cpc	r0, r25
     fec:	08 95       	ret

00000fee <__fp_pscB>:
     fee:	00 24       	eor	r0, r0
     ff0:	0a 94       	dec	r0
     ff2:	12 16       	cp	r1, r18
     ff4:	13 06       	cpc	r1, r19
     ff6:	14 06       	cpc	r1, r20
     ff8:	05 06       	cpc	r0, r21
     ffa:	08 95       	ret

00000ffc <__fp_round>:
     ffc:	09 2e       	mov	r0, r25
     ffe:	03 94       	inc	r0
    1000:	00 0c       	add	r0, r0
    1002:	11 f4       	brne	.+4      	; 0x1008 <__fp_round+0xc>
    1004:	88 23       	and	r24, r24
    1006:	52 f0       	brmi	.+20     	; 0x101c <__fp_round+0x20>
    1008:	bb 0f       	add	r27, r27
    100a:	40 f4       	brcc	.+16     	; 0x101c <__fp_round+0x20>
    100c:	bf 2b       	or	r27, r31
    100e:	11 f4       	brne	.+4      	; 0x1014 <__fp_round+0x18>
    1010:	60 ff       	sbrs	r22, 0
    1012:	04 c0       	rjmp	.+8      	; 0x101c <__fp_round+0x20>
    1014:	6f 5f       	subi	r22, 0xFF	; 255
    1016:	7f 4f       	sbci	r23, 0xFF	; 255
    1018:	8f 4f       	sbci	r24, 0xFF	; 255
    101a:	9f 4f       	sbci	r25, 0xFF	; 255
    101c:	08 95       	ret

0000101e <__fp_split3>:
    101e:	57 fd       	sbrc	r21, 7
    1020:	90 58       	subi	r25, 0x80	; 128
    1022:	44 0f       	add	r20, r20
    1024:	55 1f       	adc	r21, r21
    1026:	59 f0       	breq	.+22     	; 0x103e <__fp_splitA+0x10>
    1028:	5f 3f       	cpi	r21, 0xFF	; 255
    102a:	71 f0       	breq	.+28     	; 0x1048 <__fp_splitA+0x1a>
    102c:	47 95       	ror	r20

0000102e <__fp_splitA>:
    102e:	88 0f       	add	r24, r24
    1030:	97 fb       	bst	r25, 7
    1032:	99 1f       	adc	r25, r25
    1034:	61 f0       	breq	.+24     	; 0x104e <__fp_splitA+0x20>
    1036:	9f 3f       	cpi	r25, 0xFF	; 255
    1038:	79 f0       	breq	.+30     	; 0x1058 <__fp_splitA+0x2a>
    103a:	87 95       	ror	r24
    103c:	08 95       	ret
    103e:	12 16       	cp	r1, r18
    1040:	13 06       	cpc	r1, r19
    1042:	14 06       	cpc	r1, r20
    1044:	55 1f       	adc	r21, r21
    1046:	f2 cf       	rjmp	.-28     	; 0x102c <__fp_split3+0xe>
    1048:	46 95       	lsr	r20
    104a:	f1 df       	rcall	.-30     	; 0x102e <__fp_splitA>
    104c:	08 c0       	rjmp	.+16     	; 0x105e <__fp_splitA+0x30>
    104e:	16 16       	cp	r1, r22
    1050:	17 06       	cpc	r1, r23
    1052:	18 06       	cpc	r1, r24
    1054:	99 1f       	adc	r25, r25
    1056:	f1 cf       	rjmp	.-30     	; 0x103a <__fp_splitA+0xc>
    1058:	86 95       	lsr	r24
    105a:	71 05       	cpc	r23, r1
    105c:	61 05       	cpc	r22, r1
    105e:	08 94       	sec
    1060:	08 95       	ret

00001062 <__fp_zero>:
    1062:	e8 94       	clt

00001064 <__fp_szero>:
    1064:	bb 27       	eor	r27, r27
    1066:	66 27       	eor	r22, r22
    1068:	77 27       	eor	r23, r23
    106a:	cb 01       	movw	r24, r22
    106c:	97 f9       	bld	r25, 7
    106e:	08 95       	ret

00001070 <__mulsf3>:
    1070:	0b d0       	rcall	.+22     	; 0x1088 <__mulsf3x>
    1072:	c4 cf       	rjmp	.-120    	; 0xffc <__fp_round>
    1074:	b5 df       	rcall	.-150    	; 0xfe0 <__fp_pscA>
    1076:	28 f0       	brcs	.+10     	; 0x1082 <__mulsf3+0x12>
    1078:	ba df       	rcall	.-140    	; 0xfee <__fp_pscB>
    107a:	18 f0       	brcs	.+6      	; 0x1082 <__mulsf3+0x12>
    107c:	95 23       	and	r25, r21
    107e:	09 f0       	breq	.+2      	; 0x1082 <__mulsf3+0x12>
    1080:	a6 cf       	rjmp	.-180    	; 0xfce <__fp_inf>
    1082:	ab cf       	rjmp	.-170    	; 0xfda <__fp_nan>
    1084:	11 24       	eor	r1, r1
    1086:	ee cf       	rjmp	.-36     	; 0x1064 <__fp_szero>

00001088 <__mulsf3x>:
    1088:	ca df       	rcall	.-108    	; 0x101e <__fp_split3>
    108a:	a0 f3       	brcs	.-24     	; 0x1074 <__mulsf3+0x4>

0000108c <__mulsf3_pse>:
    108c:	95 9f       	mul	r25, r21
    108e:	d1 f3       	breq	.-12     	; 0x1084 <__mulsf3+0x14>
    1090:	95 0f       	add	r25, r21
    1092:	50 e0       	ldi	r21, 0x00	; 0
    1094:	55 1f       	adc	r21, r21
    1096:	62 9f       	mul	r22, r18
    1098:	f0 01       	movw	r30, r0
    109a:	72 9f       	mul	r23, r18
    109c:	bb 27       	eor	r27, r27
    109e:	f0 0d       	add	r31, r0
    10a0:	b1 1d       	adc	r27, r1
    10a2:	63 9f       	mul	r22, r19
    10a4:	aa 27       	eor	r26, r26
    10a6:	f0 0d       	add	r31, r0
    10a8:	b1 1d       	adc	r27, r1
    10aa:	aa 1f       	adc	r26, r26
    10ac:	64 9f       	mul	r22, r20
    10ae:	66 27       	eor	r22, r22
    10b0:	b0 0d       	add	r27, r0
    10b2:	a1 1d       	adc	r26, r1
    10b4:	66 1f       	adc	r22, r22
    10b6:	82 9f       	mul	r24, r18
    10b8:	22 27       	eor	r18, r18
    10ba:	b0 0d       	add	r27, r0
    10bc:	a1 1d       	adc	r26, r1
    10be:	62 1f       	adc	r22, r18
    10c0:	73 9f       	mul	r23, r19
    10c2:	b0 0d       	add	r27, r0
    10c4:	a1 1d       	adc	r26, r1
    10c6:	62 1f       	adc	r22, r18
    10c8:	83 9f       	mul	r24, r19
    10ca:	a0 0d       	add	r26, r0
    10cc:	61 1d       	adc	r22, r1
    10ce:	22 1f       	adc	r18, r18
    10d0:	74 9f       	mul	r23, r20
    10d2:	33 27       	eor	r19, r19
    10d4:	a0 0d       	add	r26, r0
    10d6:	61 1d       	adc	r22, r1
    10d8:	23 1f       	adc	r18, r19
    10da:	84 9f       	mul	r24, r20
    10dc:	60 0d       	add	r22, r0
    10de:	21 1d       	adc	r18, r1
    10e0:	82 2f       	mov	r24, r18
    10e2:	76 2f       	mov	r23, r22
    10e4:	6a 2f       	mov	r22, r26
    10e6:	11 24       	eor	r1, r1
    10e8:	9f 57       	subi	r25, 0x7F	; 127
    10ea:	50 40       	sbci	r21, 0x00	; 0
    10ec:	8a f0       	brmi	.+34     	; 0x1110 <__stack+0x11>
    10ee:	e1 f0       	breq	.+56     	; 0x1128 <__stack+0x29>
    10f0:	88 23       	and	r24, r24
    10f2:	4a f0       	brmi	.+18     	; 0x1106 <__stack+0x7>
    10f4:	ee 0f       	add	r30, r30
    10f6:	ff 1f       	adc	r31, r31
    10f8:	bb 1f       	adc	r27, r27
    10fa:	66 1f       	adc	r22, r22
    10fc:	77 1f       	adc	r23, r23
    10fe:	88 1f       	adc	r24, r24
    1100:	91 50       	subi	r25, 0x01	; 1
    1102:	50 40       	sbci	r21, 0x00	; 0
    1104:	a9 f7       	brne	.-22     	; 0x10f0 <__mulsf3_pse+0x64>
    1106:	9e 3f       	cpi	r25, 0xFE	; 254
    1108:	51 05       	cpc	r21, r1
    110a:	70 f0       	brcs	.+28     	; 0x1128 <__stack+0x29>
    110c:	60 cf       	rjmp	.-320    	; 0xfce <__fp_inf>
    110e:	aa cf       	rjmp	.-172    	; 0x1064 <__fp_szero>
    1110:	5f 3f       	cpi	r21, 0xFF	; 255
    1112:	ec f3       	brlt	.-6      	; 0x110e <__stack+0xf>
    1114:	98 3e       	cpi	r25, 0xE8	; 232
    1116:	dc f3       	brlt	.-10     	; 0x110e <__stack+0xf>
    1118:	86 95       	lsr	r24
    111a:	77 95       	ror	r23
    111c:	67 95       	ror	r22
    111e:	b7 95       	ror	r27
    1120:	f7 95       	ror	r31
    1122:	e7 95       	ror	r30
    1124:	9f 5f       	subi	r25, 0xFF	; 255
    1126:	c1 f7       	brne	.-16     	; 0x1118 <__stack+0x19>
    1128:	fe 2b       	or	r31, r30
    112a:	88 0f       	add	r24, r24
    112c:	91 1d       	adc	r25, r1
    112e:	96 95       	lsr	r25
    1130:	87 95       	ror	r24
    1132:	97 f9       	bld	r25, 7
    1134:	08 95       	ret

00001136 <__udivmodsi4>:
    1136:	a1 e2       	ldi	r26, 0x21	; 33
    1138:	1a 2e       	mov	r1, r26
    113a:	aa 1b       	sub	r26, r26
    113c:	bb 1b       	sub	r27, r27
    113e:	fd 01       	movw	r30, r26
    1140:	0d c0       	rjmp	.+26     	; 0x115c <__udivmodsi4_ep>

00001142 <__udivmodsi4_loop>:
    1142:	aa 1f       	adc	r26, r26
    1144:	bb 1f       	adc	r27, r27
    1146:	ee 1f       	adc	r30, r30
    1148:	ff 1f       	adc	r31, r31
    114a:	a2 17       	cp	r26, r18
    114c:	b3 07       	cpc	r27, r19
    114e:	e4 07       	cpc	r30, r20
    1150:	f5 07       	cpc	r31, r21
    1152:	20 f0       	brcs	.+8      	; 0x115c <__udivmodsi4_ep>
    1154:	a2 1b       	sub	r26, r18
    1156:	b3 0b       	sbc	r27, r19
    1158:	e4 0b       	sbc	r30, r20
    115a:	f5 0b       	sbc	r31, r21

0000115c <__udivmodsi4_ep>:
    115c:	66 1f       	adc	r22, r22
    115e:	77 1f       	adc	r23, r23
    1160:	88 1f       	adc	r24, r24
    1162:	99 1f       	adc	r25, r25
    1164:	1a 94       	dec	r1
    1166:	69 f7       	brne	.-38     	; 0x1142 <__udivmodsi4_loop>
    1168:	60 95       	com	r22
    116a:	70 95       	com	r23
    116c:	80 95       	com	r24
    116e:	90 95       	com	r25
    1170:	9b 01       	movw	r18, r22
    1172:	ac 01       	movw	r20, r24
    1174:	bd 01       	movw	r22, r26
    1176:	cf 01       	movw	r24, r30
    1178:	08 95       	ret

0000117a <__tablejump2__>:
    117a:	ee 0f       	add	r30, r30
    117c:	ff 1f       	adc	r31, r31
    117e:	00 24       	eor	r0, r0
    1180:	00 1c       	adc	r0, r0
    1182:	0b be       	out	0x3b, r0	; 59
    1184:	07 90       	elpm	r0, Z+
    1186:	f6 91       	elpm	r31, Z
    1188:	e0 2d       	mov	r30, r0
    118a:	09 94       	ijmp

0000118c <_exit>:
    118c:	f8 94       	cli

0000118e <__stop_program>:
    118e:	ff cf       	rjmp	.-2      	; 0x118e <__stop_program>
