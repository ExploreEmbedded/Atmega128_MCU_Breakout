
SD card interface.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000003ca  00800100  0000299c  00002a30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000299c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000069f  008004ca  008004ca  00002dfa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002dfa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002e2c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001d8  00000000  00000000  00002e68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000039fb  00000000  00000000  00003040  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000098e  00000000  00000000  00006a3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001a51  00000000  00000000  000073c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000890  00000000  00000000  00008e1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d5f  00000000  00000000  000096ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000388f  00000000  00000000  0000a40b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000190  00000000  00000000  0000dc9a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	53 c0       	rjmp	.+166    	; 0xa8 <__ctors_end>
       2:	00 00       	nop
       4:	70 c0       	rjmp	.+224    	; 0xe6 <__bad_interrupt>
       6:	00 00       	nop
       8:	6e c0       	rjmp	.+220    	; 0xe6 <__bad_interrupt>
       a:	00 00       	nop
       c:	6c c0       	rjmp	.+216    	; 0xe6 <__bad_interrupt>
       e:	00 00       	nop
      10:	6a c0       	rjmp	.+212    	; 0xe6 <__bad_interrupt>
      12:	00 00       	nop
      14:	68 c0       	rjmp	.+208    	; 0xe6 <__bad_interrupt>
      16:	00 00       	nop
      18:	66 c0       	rjmp	.+204    	; 0xe6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	64 c0       	rjmp	.+200    	; 0xe6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	62 c0       	rjmp	.+196    	; 0xe6 <__bad_interrupt>
      22:	00 00       	nop
      24:	60 c0       	rjmp	.+192    	; 0xe6 <__bad_interrupt>
      26:	00 00       	nop
      28:	5e c0       	rjmp	.+188    	; 0xe6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5c c0       	rjmp	.+184    	; 0xe6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	5a c0       	rjmp	.+180    	; 0xe6 <__bad_interrupt>
      32:	00 00       	nop
      34:	58 c0       	rjmp	.+176    	; 0xe6 <__bad_interrupt>
      36:	00 00       	nop
      38:	56 c0       	rjmp	.+172    	; 0xe6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	54 c0       	rjmp	.+168    	; 0xe6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	52 c0       	rjmp	.+164    	; 0xe6 <__bad_interrupt>
      42:	00 00       	nop
      44:	50 c0       	rjmp	.+160    	; 0xe6 <__bad_interrupt>
      46:	00 00       	nop
      48:	4e c0       	rjmp	.+156    	; 0xe6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4c c0       	rjmp	.+152    	; 0xe6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	4a c0       	rjmp	.+148    	; 0xe6 <__bad_interrupt>
      52:	00 00       	nop
      54:	48 c0       	rjmp	.+144    	; 0xe6 <__bad_interrupt>
      56:	00 00       	nop
      58:	46 c0       	rjmp	.+140    	; 0xe6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	44 c0       	rjmp	.+136    	; 0xe6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	42 c0       	rjmp	.+132    	; 0xe6 <__bad_interrupt>
      62:	00 00       	nop
      64:	40 c0       	rjmp	.+128    	; 0xe6 <__bad_interrupt>
      66:	00 00       	nop
      68:	3e c0       	rjmp	.+124    	; 0xe6 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3c c0       	rjmp	.+120    	; 0xe6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	3a c0       	rjmp	.+116    	; 0xe6 <__bad_interrupt>
      72:	00 00       	nop
      74:	38 c0       	rjmp	.+112    	; 0xe6 <__bad_interrupt>
      76:	00 00       	nop
      78:	36 c0       	rjmp	.+108    	; 0xe6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	34 c0       	rjmp	.+104    	; 0xe6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	32 c0       	rjmp	.+100    	; 0xe6 <__bad_interrupt>
      82:	00 00       	nop
      84:	30 c0       	rjmp	.+96     	; 0xe6 <__bad_interrupt>
      86:	00 00       	nop
      88:	2e c0       	rjmp	.+92     	; 0xe6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	1d 0d       	add	r17, r13
      8e:	38 0d       	add	r19, r8
      90:	53 0d       	add	r21, r3
      92:	6e 0d       	add	r22, r14
      94:	89 0d       	add	r24, r9
      96:	a4 0d       	add	r26, r4
      98:	c1 0d       	add	r28, r1
      9a:	ee 0d       	add	r30, r14
      9c:	09 0e       	add	r0, r25
      9e:	24 0e       	add	r2, r20
      a0:	3f 0e       	add	r3, r31
      a2:	5a 0e       	add	r5, r26
      a4:	75 0e       	add	r7, r21
      a6:	92 0e       	add	r9, r18

000000a8 <__ctors_end>:
      a8:	11 24       	eor	r1, r1
      aa:	1f be       	out	0x3f, r1	; 63
      ac:	cf ef       	ldi	r28, 0xFF	; 255
      ae:	d0 e1       	ldi	r29, 0x10	; 16
      b0:	de bf       	out	0x3e, r29	; 62
      b2:	cd bf       	out	0x3d, r28	; 61

000000b4 <__do_copy_data>:
      b4:	14 e0       	ldi	r17, 0x04	; 4
      b6:	a0 e0       	ldi	r26, 0x00	; 0
      b8:	b1 e0       	ldi	r27, 0x01	; 1
      ba:	ec e9       	ldi	r30, 0x9C	; 156
      bc:	f9 e2       	ldi	r31, 0x29	; 41
      be:	00 e0       	ldi	r16, 0x00	; 0
      c0:	0b bf       	out	0x3b, r16	; 59
      c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x14>
      c4:	07 90       	elpm	r0, Z+
      c6:	0d 92       	st	X+, r0
      c8:	aa 3c       	cpi	r26, 0xCA	; 202
      ca:	b1 07       	cpc	r27, r17
      cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0x10>

000000ce <__do_clear_bss>:
      ce:	2b e0       	ldi	r18, 0x0B	; 11
      d0:	aa ec       	ldi	r26, 0xCA	; 202
      d2:	b4 e0       	ldi	r27, 0x04	; 4
      d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
      d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
      d8:	a9 36       	cpi	r26, 0x69	; 105
      da:	b2 07       	cpc	r27, r18
      dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
      de:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <main>
      e2:	0c 94 cc 14 	jmp	0x2998	; 0x2998 <_exit>

000000e6 <__bad_interrupt>:
      e6:	8c cf       	rjmp	.-232    	; 0x0 <__vectors>

000000e8 <FILE_Close>:
                 This functions closes the file and releases the memory used by the file.
                 Once the file is closed, no more file operation are allowed.
 ******************************************************************************************************************/
void FILE_Close(fileConfig_st *ptr)
{
    if(ptr!= 0)
      e8:	00 97       	sbiw	r24, 0x00	; 0
      ea:	21 f0       	breq	.+8      	; 0xf4 <FILE_Close+0xc>
        ptr->fileOpenedFlag = FALSE; /* Clear the file Opened flag */
      ec:	fc 01       	movw	r30, r24
      ee:	e3 5d       	subi	r30, 0xD3	; 211
      f0:	fd 4f       	sbci	r31, 0xFD	; 253
      f2:	10 82       	st	Z, r1
      f4:	08 95       	ret

000000f6 <extract_DataBySize>:

/***********************************************************************************************************************************************
                                     Local Functions
 ************************************************************************************************************************************************/
uint32_t extract_DataBySize(uint8_t *ptr,uint8_t size)
{
      f6:	cf 92       	push	r12
      f8:	df 92       	push	r13
      fa:	ef 92       	push	r14
      fc:	ff 92       	push	r15
      fe:	cf 93       	push	r28
     100:	df 93       	push	r29
     102:	c6 2f       	mov	r28, r22
     104:	d8 2f       	mov	r29, r24
    uint8_t i;
    uint32_t v_data_u32 = 0;
    for(i=0;i<size;i++)
     106:	fc 01       	movw	r30, r24
     108:	20 e0       	ldi	r18, 0x00	; 0
     10a:	30 e0       	ldi	r19, 0x00	; 0
                                     Local Functions
 ************************************************************************************************************************************************/
uint32_t extract_DataBySize(uint8_t *ptr,uint8_t size)
{
    uint8_t i;
    uint32_t v_data_u32 = 0;
     10c:	60 e0       	ldi	r22, 0x00	; 0
     10e:	70 e0       	ldi	r23, 0x00	; 0
     110:	cb 01       	movw	r24, r22
     112:	4e 2f       	mov	r20, r30
     114:	4d 1b       	sub	r20, r29
    for(i=0;i<size;i++)
     116:	4c 17       	cp	r20, r28
     118:	98 f4       	brcc	.+38     	; 0x140 <extract_DataBySize+0x4a>
    {
        v_data_u32 += (ptr[i] << (8 * i));
     11a:	41 91       	ld	r20, Z+
     11c:	50 e0       	ldi	r21, 0x00	; 0
     11e:	02 2e       	mov	r0, r18
     120:	02 c0       	rjmp	.+4      	; 0x126 <extract_DataBySize+0x30>
     122:	44 0f       	add	r20, r20
     124:	55 1f       	adc	r21, r21
     126:	0a 94       	dec	r0
     128:	e2 f7       	brpl	.-8      	; 0x122 <extract_DataBySize+0x2c>
     12a:	6a 01       	movw	r12, r20
     12c:	55 0f       	add	r21, r21
     12e:	ee 08       	sbc	r14, r14
     130:	ff 08       	sbc	r15, r15
     132:	6c 0d       	add	r22, r12
     134:	7d 1d       	adc	r23, r13
     136:	8e 1d       	adc	r24, r14
     138:	9f 1d       	adc	r25, r15
     13a:	28 5f       	subi	r18, 0xF8	; 248
     13c:	3f 4f       	sbci	r19, 0xFF	; 255
     13e:	e9 cf       	rjmp	.-46     	; 0x112 <extract_DataBySize+0x1c>
    }
    return v_data_u32;
} 
     140:	df 91       	pop	r29
     142:	cf 91       	pop	r28
     144:	ff 90       	pop	r15
     146:	ef 90       	pop	r14
     148:	df 90       	pop	r13
     14a:	cf 90       	pop	r12
     14c:	08 95       	ret

0000014e <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
uint32_t getFirstSector(uint32_t clusterNumber)
{
     14e:	0f 93       	push	r16
     150:	1f 93       	push	r17
    return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
     152:	9b 01       	movw	r18, r22
     154:	ac 01       	movw	r20, r24
     156:	22 50       	subi	r18, 0x02	; 2
     158:	31 09       	sbc	r19, r1
     15a:	41 09       	sbc	r20, r1
     15c:	51 09       	sbc	r21, r1
     15e:	a0 91 e3 06 	lds	r26, 0x06E3
     162:	b0 91 e4 06 	lds	r27, 0x06E4
     166:	0e 94 ac 14 	call	0x2958	; 0x2958 <__muluhisi3>
     16a:	00 91 d5 04 	lds	r16, 0x04D5
     16e:	10 91 d6 04 	lds	r17, 0x04D6
     172:	20 91 d7 04 	lds	r18, 0x04D7
     176:	30 91 d8 04 	lds	r19, 0x04D8
     17a:	60 0f       	add	r22, r16
     17c:	71 1f       	adc	r23, r17
     17e:	82 1f       	adc	r24, r18
     180:	93 1f       	adc	r25, r19
}
     182:	1f 91       	pop	r17
     184:	0f 91       	pop	r16
     186:	08 95       	ret

00000188 <getSetNextCluster>:
//Arguments: 1. current cluster number, 2. get_set (=GET, if next cluster is to be found or = SET,
//if next cluster is to be set 3. next cluster number, if argument#2 = SET, else 0
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
uint32_t getSetNextCluster(char *inputBuffer,uint32_t clusterNumber,uint8_t get_set,uint32_t clusterEntry)
{
     188:	2f 92       	push	r2
     18a:	3f 92       	push	r3
     18c:	4f 92       	push	r4
     18e:	5f 92       	push	r5
     190:	7f 92       	push	r7
     192:	8f 92       	push	r8
     194:	9f 92       	push	r9
     196:	af 92       	push	r10
     198:	bf 92       	push	r11
     19a:	cf 92       	push	r12
     19c:	df 92       	push	r13
     19e:	ef 92       	push	r14
     1a0:	ff 92       	push	r15
     1a2:	0f 93       	push	r16
     1a4:	1f 93       	push	r17
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	ec 01       	movw	r28, r24
     1ac:	72 2e       	mov	r7, r18
     1ae:	17 01       	movw	r2, r14
     1b0:	28 01       	movw	r4, r16
    uint32_t *FATEntryValue;
    uint32_t FATEntrySector;
    uint8_t retry = 0;

    //get sector number of the cluster entry in the FAT
    FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
     1b2:	cb 01       	movw	r24, r22
     1b4:	ba 01       	movw	r22, r20
     1b6:	22 e0       	ldi	r18, 0x02	; 2
     1b8:	66 0f       	add	r22, r22
     1ba:	77 1f       	adc	r23, r23
     1bc:	88 1f       	adc	r24, r24
     1be:	99 1f       	adc	r25, r25
     1c0:	2a 95       	dec	r18
     1c2:	d1 f7       	brne	.-12     	; 0x1b8 <getSetNextCluster+0x30>
     1c4:	20 91 d9 04 	lds	r18, 0x04D9
     1c8:	30 91 da 04 	lds	r19, 0x04DA
     1cc:	40 e0       	ldi	r20, 0x00	; 0
     1ce:	50 e0       	ldi	r21, 0x00	; 0
     1d0:	e0 91 e9 06 	lds	r30, 0x06E9
     1d4:	f0 91 ea 06 	lds	r31, 0x06EA
     1d8:	c0 90 e5 06 	lds	r12, 0x06E5
     1dc:	d0 90 e6 06 	lds	r13, 0x06E6
     1e0:	e0 90 e7 06 	lds	r14, 0x06E7
     1e4:	f0 90 e8 06 	lds	r15, 0x06E8
     1e8:	ce 0e       	add	r12, r30
     1ea:	df 1e       	adc	r13, r31
     1ec:	e1 1c       	adc	r14, r1
     1ee:	f1 1c       	adc	r15, r1
     1f0:	0e 94 72 14 	call	0x28e4	; 0x28e4 <__udivmodsi4>
     1f4:	4b 01       	movw	r8, r22
     1f6:	5c 01       	movw	r10, r24
     1f8:	c2 0e       	add	r12, r18
     1fa:	d3 1e       	adc	r13, r19
     1fc:	e4 1e       	adc	r14, r20
     1fe:	f5 1e       	adc	r15, r21

    //get the offset address in that sector number
    FATEntryOffset = (uint16_t) ((clusterNumber * 4) % bytesPerSector);
     200:	1a e0       	ldi	r17, 0x0A	; 10

    //read the sector into a buffer
    while(retry <10)
    {
        if(!SD_readSingleBlock(inputBuffer,FATEntrySector))
     202:	b7 01       	movw	r22, r14
     204:	a6 01       	movw	r20, r12
     206:	ce 01       	movw	r24, r28
     208:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>
     20c:	88 23       	and	r24, r24
     20e:	11 f0       	breq	.+4      	; 0x214 <getSetNextCluster+0x8c>
     210:	11 50       	subi	r17, 0x01	; 1

    //get the offset address in that sector number
    FATEntryOffset = (uint16_t) ((clusterNumber * 4) % bytesPerSector);

    //read the sector into a buffer
    while(retry <10)
     212:	b9 f7       	brne	.-18     	; 0x202 <getSetNextCluster+0x7a>
            break;
        retry++;
    }

    //get the cluster address from the buffer
    FATEntryValue = (uint32_t *) &inputBuffer[FATEntryOffset];
     214:	fe 01       	movw	r30, r28
     216:	e8 0d       	add	r30, r8
     218:	f9 1d       	adc	r31, r9

    if(get_set == GET)
     21a:	71 10       	cpse	r7, r1
     21c:	08 c0       	rjmp	.+16     	; 0x22e <getSetNextCluster+0xa6>
        return ((*FATEntryValue) & 0x0fffffff);
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	a2 81       	ldd	r26, Z+2	; 0x02
     224:	b3 81       	ldd	r27, Z+3	; 0x03
     226:	bc 01       	movw	r22, r24
     228:	cd 01       	movw	r24, r26
     22a:	9f 70       	andi	r25, 0x0F	; 15
     22c:	0c c0       	rjmp	.+24     	; 0x246 <getSetNextCluster+0xbe>


    *FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
     22e:	20 82       	st	Z, r2
     230:	31 82       	std	Z+1, r3	; 0x01
     232:	42 82       	std	Z+2, r4	; 0x02
     234:	53 82       	std	Z+3, r5	; 0x03
    SD_writeSingleBlock(inputBuffer,FATEntrySector);
     236:	b7 01       	movw	r22, r14
     238:	a6 01       	movw	r20, r12
     23a:	ce 01       	movw	r24, r28
     23c:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <SD_writeSingleBlock>

    return (0);
     240:	60 e0       	ldi	r22, 0x00	; 0
     242:	70 e0       	ldi	r23, 0x00	; 0
     244:	cb 01       	movw	r24, r22
}
     246:	df 91       	pop	r29
     248:	cf 91       	pop	r28
     24a:	1f 91       	pop	r17
     24c:	0f 91       	pop	r16
     24e:	ff 90       	pop	r15
     250:	ef 90       	pop	r14
     252:	df 90       	pop	r13
     254:	cf 90       	pop	r12
     256:	bf 90       	pop	r11
     258:	af 90       	pop	r10
     25a:	9f 90       	pop	r9
     25c:	8f 90       	pop	r8
     25e:	7f 90       	pop	r7
     260:	5f 90       	pop	r5
     262:	4f 90       	pop	r4
     264:	3f 90       	pop	r3
     266:	2f 90       	pop	r2
     268:	08 95       	ret

0000026a <FILE_GetCh>:
                 This functions reads a byte of data from the file.
                 It checks whether the requested file is opened or not, it reads the data only if the file is open else returns EOF.
                 Once the End of File is reached it returns EOF(26). User shoukd stop calling the function after this.
 ******************************************************************************************************************/
char FILE_GetCh(fileConfig_st *filePtr)
{
     26a:	cf 92       	push	r12
     26c:	df 92       	push	r13
     26e:	ef 92       	push	r14
     270:	ff 92       	push	r15
     272:	0f 93       	push	r16
     274:	1f 93       	push	r17
     276:	cf 93       	push	r28
     278:	df 93       	push	r29
     27a:	ec 01       	movw	r28, r24
    char ch;

    if(((filePtr->byteCounter) < (filePtr->fileSize))   &&  (filePtr->fileOpenedFlag == TRUE))
     27c:	48 8d       	ldd	r20, Y+24	; 0x18
     27e:	59 8d       	ldd	r21, Y+25	; 0x19
     280:	6a 8d       	ldd	r22, Y+26	; 0x1a
     282:	7b 8d       	ldd	r23, Y+27	; 0x1b
     284:	8c 89       	ldd	r24, Y+20	; 0x14
     286:	9d 89       	ldd	r25, Y+21	; 0x15
     288:	ae 89       	ldd	r26, Y+22	; 0x16
     28a:	bf 89       	ldd	r27, Y+23	; 0x17
     28c:	48 17       	cp	r20, r24
     28e:	59 07       	cpc	r21, r25
     290:	6a 07       	cpc	r22, r26
     292:	7b 07       	cpc	r23, r27
     294:	08 f0       	brcs	.+2      	; 0x298 <FILE_GetCh+0x2e>
     296:	5e c0       	rjmp	.+188    	; 0x354 <FILE_GetCh+0xea>
     298:	fe 01       	movw	r30, r28
     29a:	e3 5d       	subi	r30, 0xD3	; 211
     29c:	fd 4f       	sbci	r31, 0xFD	; 253
     29e:	80 81       	ld	r24, Z
     2a0:	81 30       	cpi	r24, 0x01	; 1
     2a2:	09 f0       	breq	.+2      	; 0x2a6 <FILE_GetCh+0x3c>
     2a4:	57 c0       	rjmp	.+174    	; 0x354 <FILE_GetCh+0xea>
    {
        if(filePtr->bufferIndex_u16 == 0)
     2a6:	8e a1       	ldd	r24, Y+38	; 0x26
     2a8:	9f a1       	ldd	r25, Y+39	; 0x27
     2aa:	89 2b       	or	r24, r25
     2ac:	d1 f4       	brne	.+52     	; 0x2e2 <FILE_GetCh+0x78>
        {
            if((filePtr->sectorIndex == 0))
     2ae:	cc a0       	ldd	r12, Y+36	; 0x24
     2b0:	dd a0       	ldd	r13, Y+37	; 0x25
     2b2:	c1 14       	cp	r12, r1
     2b4:	d1 04       	cpc	r13, r1
     2b6:	49 f4       	brne	.+18     	; 0x2ca <FILE_GetCh+0x60>
            {
                filePtr->firstSector = getFirstSector (filePtr->cluster);
     2b8:	6c 81       	ldd	r22, Y+4	; 0x04
     2ba:	7d 81       	ldd	r23, Y+5	; 0x05
     2bc:	8e 81       	ldd	r24, Y+6	; 0x06
     2be:	9f 81       	ldd	r25, Y+7	; 0x07
     2c0:	46 df       	rcall	.-372    	; 0x14e <getFirstSector>
     2c2:	68 83       	st	Y, r22
     2c4:	79 83       	std	Y+1, r23	; 0x01
     2c6:	8a 83       	std	Y+2, r24	; 0x02
     2c8:	9b 83       	std	Y+3, r25	; 0x03
            }
            SD_readSingleBlock(filePtr->fileBuffer,filePtr->firstSector + filePtr->sectorIndex);
     2ca:	48 81       	ld	r20, Y
     2cc:	59 81       	ldd	r21, Y+1	; 0x01
     2ce:	6a 81       	ldd	r22, Y+2	; 0x02
     2d0:	7b 81       	ldd	r23, Y+3	; 0x03
     2d2:	4c 0d       	add	r20, r12
     2d4:	5d 1d       	adc	r21, r13
     2d6:	61 1d       	adc	r22, r1
     2d8:	71 1d       	adc	r23, r1
     2da:	ce 01       	movw	r24, r28
     2dc:	8c 96       	adiw	r24, 0x2c	; 44
     2de:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>
        }

        ch = filePtr->fileBuffer[filePtr->bufferIndex_u16];
     2e2:	2e a1       	ldd	r18, Y+38	; 0x26
     2e4:	3f a1       	ldd	r19, Y+39	; 0x27
     2e6:	fe 01       	movw	r30, r28
     2e8:	e2 0f       	add	r30, r18
     2ea:	f3 1f       	adc	r31, r19
     2ec:	d4 a4       	ldd	r13, Z+44	; 0x2c
        filePtr->bufferIndex_u16 ++;
     2ee:	2f 5f       	subi	r18, 0xFF	; 255
     2f0:	3f 4f       	sbci	r19, 0xFF	; 255
     2f2:	3f a3       	std	Y+39, r19	; 0x27
     2f4:	2e a3       	std	Y+38, r18	; 0x26
        filePtr->byteCounter++;
     2f6:	88 8d       	ldd	r24, Y+24	; 0x18
     2f8:	99 8d       	ldd	r25, Y+25	; 0x19
     2fa:	aa 8d       	ldd	r26, Y+26	; 0x1a
     2fc:	bb 8d       	ldd	r27, Y+27	; 0x1b
     2fe:	01 96       	adiw	r24, 0x01	; 1
     300:	a1 1d       	adc	r26, r1
     302:	b1 1d       	adc	r27, r1
     304:	88 8f       	std	Y+24, r24	; 0x18
     306:	99 8f       	std	Y+25, r25	; 0x19
     308:	aa 8f       	std	Y+26, r26	; 0x1a
     30a:	bb 8f       	std	Y+27, r27	; 0x1b


        if(filePtr->bufferIndex_u16 == 512)
     30c:	21 15       	cp	r18, r1
     30e:	32 40       	sbci	r19, 0x02	; 2
     310:	19 f5       	brne	.+70     	; 0x358 <FILE_GetCh+0xee>
        {
            filePtr->sectorIndex++;
     312:	2c a1       	ldd	r18, Y+36	; 0x24
     314:	3d a1       	ldd	r19, Y+37	; 0x25
     316:	2f 5f       	subi	r18, 0xFF	; 255
     318:	3f 4f       	sbci	r19, 0xFF	; 255
     31a:	3d a3       	std	Y+37, r19	; 0x25
     31c:	2c a3       	std	Y+36, r18	; 0x24
            filePtr->bufferIndex_u16 = 0;
     31e:	1f a2       	std	Y+39, r1	; 0x27
     320:	1e a2       	std	Y+38, r1	; 0x26
            if(filePtr->sectorIndex == sectorPerCluster)
     322:	80 91 e3 06 	lds	r24, 0x06E3
     326:	90 91 e4 06 	lds	r25, 0x06E4
     32a:	28 17       	cp	r18, r24
     32c:	39 07       	cpc	r19, r25
     32e:	a1 f4       	brne	.+40     	; 0x358 <FILE_GetCh+0xee>
            {
                filePtr->sectorIndex = 0;
     330:	1d a2       	std	Y+37, r1	; 0x25
     332:	1c a2       	std	Y+36, r1	; 0x24
                filePtr->cluster = getSetNextCluster (filePtr->fileBuffer,filePtr->cluster, GET, 0);
     334:	4c 81       	ldd	r20, Y+4	; 0x04
     336:	5d 81       	ldd	r21, Y+5	; 0x05
     338:	6e 81       	ldd	r22, Y+6	; 0x06
     33a:	7f 81       	ldd	r23, Y+7	; 0x07
     33c:	e1 2c       	mov	r14, r1
     33e:	f1 2c       	mov	r15, r1
     340:	87 01       	movw	r16, r14
     342:	20 e0       	ldi	r18, 0x00	; 0
     344:	ce 01       	movw	r24, r28
     346:	8c 96       	adiw	r24, 0x2c	; 44
     348:	1f df       	rcall	.-450    	; 0x188 <getSetNextCluster>
     34a:	6c 83       	std	Y+4, r22	; 0x04
     34c:	7d 83       	std	Y+5, r23	; 0x05
     34e:	8e 83       	std	Y+6, r24	; 0x06
     350:	9f 83       	std	Y+7, r25	; 0x07
     352:	02 c0       	rjmp	.+4      	; 0x358 <FILE_GetCh+0xee>
            }
        }
    }
    else
    {
        ch = EOF;
     354:	8a e1       	ldi	r24, 0x1A	; 26
     356:	d8 2e       	mov	r13, r24
    }

    return ch;
}
     358:	8d 2d       	mov	r24, r13
     35a:	df 91       	pop	r29
     35c:	cf 91       	pop	r28
     35e:	1f 91       	pop	r17
     360:	0f 91       	pop	r16
     362:	ff 90       	pop	r15
     364:	ef 90       	pop	r14
     366:	df 90       	pop	r13
     368:	cf 90       	pop	r12
     36a:	08 95       	ret

0000036c <FILE_GetList>:
                 It updates the file name and its size in the structure pointer passed to the function.
                 It returns FAT32_MORE_FILES_To_READ(8), if there are files to be listed.
                 In case there are no files to be listed it returns FAT32_END_OF_FILE_LIST(9).
 ******************************************************************************************************************/
uint8_t FILE_GetList (fileInfo *fileList)
{
     36c:	cf 92       	push	r12
     36e:	df 92       	push	r13
     370:	ef 92       	push	r14
     372:	ff 92       	push	r15
     374:	0f 93       	push	r16
     376:	1f 93       	push	r17
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
     37c:	6c 01       	movw	r12, r24
    dir_Structure *dir;
    static uint16_t i;
    uint8_t j;
    uint8_t fileNameIndex = 0;

    if(clusterNumber == 0xffffffff)
     37e:	80 91 00 01 	lds	r24, 0x0100
     382:	90 91 01 01 	lds	r25, 0x0101
     386:	a0 91 02 01 	lds	r26, 0x0102
     38a:	b0 91 03 01 	lds	r27, 0x0103
     38e:	8f 3f       	cpi	r24, 0xFF	; 255
     390:	9f 4f       	sbci	r25, 0xFF	; 255
     392:	af 4f       	sbci	r26, 0xFF	; 255
     394:	bf 4f       	sbci	r27, 0xFF	; 255
     396:	59 f5       	brne	.+86     	; 0x3ee <FILE_GetList+0x82>
    {
        clusterNumber = rootCluster;
     398:	60 91 df 06 	lds	r22, 0x06DF
     39c:	70 91 e0 06 	lds	r23, 0x06E0
     3a0:	80 91 e1 06 	lds	r24, 0x06E1
     3a4:	90 91 e2 06 	lds	r25, 0x06E2
     3a8:	60 93 00 01 	sts	0x0100, r22
     3ac:	70 93 01 01 	sts	0x0101, r23
     3b0:	80 93 02 01 	sts	0x0102, r24
     3b4:	90 93 03 01 	sts	0x0103, r25
        sectorNumber = 0;
     3b8:	10 92 d0 04 	sts	0x04D0, r1
     3bc:	10 92 d1 04 	sts	0x04D1, r1
     3c0:	10 92 d2 04 	sts	0x04D2, r1
     3c4:	10 92 d3 04 	sts	0x04D3, r1
        i = 0;
     3c8:	10 92 cf 04 	sts	0x04CF, r1
     3cc:	10 92 ce 04 	sts	0x04CE, r1
        firstSectorIndex = getFirstSector (clusterNumber);
     3d0:	be de       	rcall	.-644    	; 0x14e <getFirstSector>
     3d2:	ab 01       	movw	r20, r22
     3d4:	bc 01       	movw	r22, r24
     3d6:	40 93 ca 04 	sts	0x04CA, r20
     3da:	50 93 cb 04 	sts	0x04CB, r21
     3de:	60 93 cc 04 	sts	0x04CC, r22
     3e2:	70 93 cd 04 	sts	0x04CD, r23
        SD_readSingleBlock (GlobalBuffer,firstSectorIndex + sectorNumber);
     3e6:	8f ed       	ldi	r24, 0xDF	; 223
     3e8:	94 e0       	ldi	r25, 0x04	; 4
     3ea:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>

            for(j=0; j<11; j++)
            {
                if(j == 8)
                {
                    fileList->fileName[fileNameIndex++] = ('.');
     3ee:	de e2       	ldi	r29, 0x2E	; 46
        SD_readSingleBlock (GlobalBuffer,firstSectorIndex + sectorNumber);
    }

    do
    {
        dir = (dir_Structure *) &GlobalBuffer[i];
     3f0:	20 91 ce 04 	lds	r18, 0x04CE
     3f4:	30 91 cf 04 	lds	r19, 0x04CF
     3f8:	f9 01       	movw	r30, r18
     3fa:	e1 52       	subi	r30, 0x21	; 33
     3fc:	fb 4f       	sbci	r31, 0xFB	; 251

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
     3fe:	80 81       	ld	r24, Z
     400:	81 11       	cpse	r24, r1
     402:	0d c0       	rjmp	.+26     	; 0x41e <FILE_GetList+0xb2>
        {
            print_DebugMsg("File does not exist!");
            clusterNumber = 0xffffffff;
     404:	8f ef       	ldi	r24, 0xFF	; 255
     406:	9f ef       	ldi	r25, 0xFF	; 255
     408:	dc 01       	movw	r26, r24
     40a:	80 93 00 01 	sts	0x0100, r24
     40e:	90 93 01 01 	sts	0x0101, r25
     412:	a0 93 02 01 	sts	0x0102, r26
     416:	b0 93 03 01 	sts	0x0103, r27
            return (FAT32_END_OF_FILE_LIST);
     41a:	89 e0       	ldi	r24, 0x09	; 9
     41c:	b1 c0       	rjmp	.+354    	; 0x580 <FILE_GetList+0x214>
        }
        if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
     41e:	85 3e       	cpi	r24, 0xE5	; 229
     420:	71 f1       	breq	.+92     	; 0x47e <FILE_GetList+0x112>
     422:	83 85       	ldd	r24, Z+11	; 0x0b
     424:	8f 30       	cpi	r24, 0x0F	; 15
     426:	59 f1       	breq	.+86     	; 0x47e <FILE_GetList+0x112>
     428:	bf 01       	movw	r22, r30
     42a:	80 e0       	ldi	r24, 0x00	; 0
     42c:	c0 e0       	ldi	r28, 0x00	; 0
                {
                    fileList->fileName[fileNameIndex++] = ('.');
                }


                if(dir->name[j] != ' ')
     42e:	db 01       	movw	r26, r22
     430:	9d 91       	ld	r25, X+
     432:	bd 01       	movw	r22, r26
     434:	90 32       	cpi	r25, 0x20	; 32
     436:	39 f0       	breq	.+14     	; 0x446 <FILE_GetList+0xda>
                {
                    fileList->fileName[fileNameIndex++] = dir->name[j];
     438:	a6 01       	movw	r20, r12
     43a:	4c 0f       	add	r20, r28
     43c:	51 1d       	adc	r21, r1
     43e:	da 01       	movw	r26, r20
     440:	14 96       	adiw	r26, 0x04	; 4
     442:	9c 93       	st	X, r25
     444:	cf 5f       	subi	r28, 0xFF	; 255
            return (FAT32_END_OF_FILE_LIST);
        }
        if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {

            for(j=0; j<11; j++)
     446:	8f 5f       	subi	r24, 0xFF	; 255
     448:	8b 30       	cpi	r24, 0x0B	; 11
     44a:	51 f0       	breq	.+20     	; 0x460 <FILE_GetList+0xf4>
            {
                if(j == 8)
     44c:	88 30       	cpi	r24, 0x08	; 8
     44e:	79 f7       	brne	.-34     	; 0x42e <FILE_GetList+0xc2>
                {
                    fileList->fileName[fileNameIndex++] = ('.');
     450:	a6 01       	movw	r20, r12
     452:	4c 0f       	add	r20, r28
     454:	51 1d       	adc	r21, r1
     456:	da 01       	movw	r26, r20
     458:	14 96       	adiw	r26, 0x04	; 4
     45a:	dc 93       	st	X, r29
     45c:	cf 5f       	subi	r28, 0xFF	; 255
     45e:	e7 cf       	rjmp	.-50     	; 0x42e <FILE_GetList+0xc2>
                if(dir->name[j] != ' ')
                {
                    fileList->fileName[fileNameIndex++] = dir->name[j];
                }
            }
            fileList->fileName[fileNameIndex] = 0;
     460:	d6 01       	movw	r26, r12
     462:	ac 0f       	add	r26, r28
     464:	b1 1d       	adc	r27, r1
     466:	14 96       	adiw	r26, 0x04	; 4
     468:	1c 92       	st	X, r1
            fileList->fileSize = dir->fileSize;
     46a:	84 8d       	ldd	r24, Z+28	; 0x1c
     46c:	95 8d       	ldd	r25, Z+29	; 0x1d
     46e:	a6 8d       	ldd	r26, Z+30	; 0x1e
     470:	b7 8d       	ldd	r27, Z+31	; 0x1f
     472:	f6 01       	movw	r30, r12
     474:	80 83       	st	Z, r24
     476:	91 83       	std	Z+1, r25	; 0x01
     478:	a2 83       	std	Z+2, r26	; 0x02
     47a:	b3 83       	std	Z+3, r27	; 0x03
     47c:	01 c0       	rjmp	.+2      	; 0x480 <FILE_GetList+0x114>
     47e:	c0 e0       	ldi	r28, 0x00	; 0
        }

        i = i+32;
     480:	20 5e       	subi	r18, 0xE0	; 224
     482:	3f 4f       	sbci	r19, 0xFF	; 255
     484:	30 93 cf 04 	sts	0x04CF, r19
     488:	20 93 ce 04 	sts	0x04CE, r18

        if(i >= bytesPerSector)
     48c:	80 91 d9 04 	lds	r24, 0x04D9
     490:	90 91 da 04 	lds	r25, 0x04DA
     494:	28 17       	cp	r18, r24
     496:	39 07       	cpc	r19, r25
     498:	08 f4       	brcc	.+2      	; 0x49c <FILE_GetList+0x130>
     49a:	6e c0       	rjmp	.+220    	; 0x578 <FILE_GetList+0x20c>
        {
            i = 0;
     49c:	10 92 cf 04 	sts	0x04CF, r1
     4a0:	10 92 ce 04 	sts	0x04CE, r1
            sectorNumber++;
     4a4:	80 91 d0 04 	lds	r24, 0x04D0
     4a8:	90 91 d1 04 	lds	r25, 0x04D1
     4ac:	a0 91 d2 04 	lds	r26, 0x04D2
     4b0:	b0 91 d3 04 	lds	r27, 0x04D3
     4b4:	01 96       	adiw	r24, 0x01	; 1
     4b6:	a1 1d       	adc	r26, r1
     4b8:	b1 1d       	adc	r27, r1
     4ba:	80 93 d0 04 	sts	0x04D0, r24
     4be:	90 93 d1 04 	sts	0x04D1, r25
     4c2:	a0 93 d2 04 	sts	0x04D2, r26
     4c6:	b0 93 d3 04 	sts	0x04D3, r27

            if(sectorNumber == sectorPerCluster)
     4ca:	40 91 e3 06 	lds	r20, 0x06E3
     4ce:	50 91 e4 06 	lds	r21, 0x06E4
     4d2:	60 e0       	ldi	r22, 0x00	; 0
     4d4:	70 e0       	ldi	r23, 0x00	; 0
     4d6:	84 17       	cp	r24, r20
     4d8:	95 07       	cpc	r25, r21
     4da:	a6 07       	cpc	r26, r22
     4dc:	b7 07       	cpc	r27, r23
     4de:	a1 f5       	brne	.+104    	; 0x548 <FILE_GetList+0x1dc>
            {
                sectorNumber = 0;
     4e0:	10 92 d0 04 	sts	0x04D0, r1
     4e4:	10 92 d1 04 	sts	0x04D1, r1
     4e8:	10 92 d2 04 	sts	0x04D2, r1
     4ec:	10 92 d3 04 	sts	0x04D3, r1
                clusterNumber = (getSetNextCluster (GlobalBuffer,clusterNumber, GET, 0));
     4f0:	40 91 00 01 	lds	r20, 0x0100
     4f4:	50 91 01 01 	lds	r21, 0x0101
     4f8:	60 91 02 01 	lds	r22, 0x0102
     4fc:	70 91 03 01 	lds	r23, 0x0103
     500:	e1 2c       	mov	r14, r1
     502:	f1 2c       	mov	r15, r1
     504:	87 01       	movw	r16, r14
     506:	20 e0       	ldi	r18, 0x00	; 0
     508:	8f ed       	ldi	r24, 0xDF	; 223
     50a:	94 e0       	ldi	r25, 0x04	; 4
     50c:	3d de       	rcall	.-902    	; 0x188 <getSetNextCluster>
     50e:	60 93 00 01 	sts	0x0100, r22
     512:	70 93 01 01 	sts	0x0101, r23
     516:	80 93 02 01 	sts	0x0102, r24
     51a:	90 93 03 01 	sts	0x0103, r25
                    print_DebugMsg("End of Cluster");
                    clusterNumber = 0xffffffff;
                    return FAT32_END_OF_FILE_LIST;
                }

                if(clusterNumber == 0)
     51e:	8b 01       	movw	r16, r22
     520:	9c 01       	movw	r18, r24
     522:	01 50       	subi	r16, 0x01	; 1
     524:	11 09       	sbc	r17, r1
     526:	21 09       	sbc	r18, r1
     528:	31 09       	sbc	r19, r1
     52a:	06 3f       	cpi	r16, 0xF6	; 246
     52c:	1f 4f       	sbci	r17, 0xFF	; 255
     52e:	2f 4f       	sbci	r18, 0xFF	; 255
     530:	3f 40       	sbci	r19, 0x0F	; 15
     532:	08 f0       	brcs	.+2      	; 0x536 <FILE_GetList+0x1ca>
     534:	67 cf       	rjmp	.-306    	; 0x404 <FILE_GetList+0x98>
                    print_DebugMsg("Error in getting cluster");
                    clusterNumber = 0xffffffff;;
                    return FAT32_END_OF_FILE_LIST;
                }

                firstSectorIndex = getFirstSector (clusterNumber);
     536:	0b de       	rcall	.-1002   	; 0x14e <getFirstSector>
     538:	60 93 ca 04 	sts	0x04CA, r22
     53c:	70 93 cb 04 	sts	0x04CB, r23
     540:	80 93 cc 04 	sts	0x04CC, r24
     544:	90 93 cd 04 	sts	0x04CD, r25
            }

            SD_readSingleBlock(GlobalBuffer,firstSectorIndex + sectorNumber);
     548:	40 91 d0 04 	lds	r20, 0x04D0
     54c:	50 91 d1 04 	lds	r21, 0x04D1
     550:	60 91 d2 04 	lds	r22, 0x04D2
     554:	70 91 d3 04 	lds	r23, 0x04D3
     558:	80 91 ca 04 	lds	r24, 0x04CA
     55c:	90 91 cb 04 	lds	r25, 0x04CB
     560:	a0 91 cc 04 	lds	r26, 0x04CC
     564:	b0 91 cd 04 	lds	r27, 0x04CD
     568:	48 0f       	add	r20, r24
     56a:	59 1f       	adc	r21, r25
     56c:	6a 1f       	adc	r22, r26
     56e:	7b 1f       	adc	r23, r27
     570:	8f ed       	ldi	r24, 0xDF	; 223
     572:	94 e0       	ldi	r25, 0x04	; 4
     574:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>
        }
    }while(fileNameIndex == 0);
     578:	cc 23       	and	r28, r28
     57a:	09 f4       	brne	.+2      	; 0x57e <FILE_GetList+0x212>
     57c:	39 cf       	rjmp	.-398    	; 0x3f0 <FILE_GetList+0x84>


    return FAT32_MORE_FILES_To_READ;
     57e:	88 e0       	ldi	r24, 0x08	; 8
}
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	1f 91       	pop	r17
     586:	0f 91       	pop	r16
     588:	ff 90       	pop	r15
     58a:	ef 90       	pop	r14
     58c:	df 90       	pop	r13
     58e:	cf 90       	pop	r12
     590:	08 95       	ret

00000592 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
uint32_t getSetFreeCluster(char *inputBuffer, uint8_t totOrNext, uint8_t get_set, uint32_t FSEntry)
{
     592:	ef 92       	push	r14
     594:	ff 92       	push	r15
     596:	0f 93       	push	r16
     598:	1f 93       	push	r17
     59a:	cf 93       	push	r28
     59c:	df 93       	push	r29
     59e:	00 d0       	rcall	.+0      	; 0x5a0 <getSetFreeCluster+0xe>
     5a0:	cd b7       	in	r28, 0x3d	; 61
     5a2:	de b7       	in	r29, 0x3e	; 62
     5a4:	9a 83       	std	Y+2, r25	; 0x02
     5a6:	89 83       	std	Y+1, r24	; 0x01
     5a8:	f6 2e       	mov	r15, r22
     5aa:	e4 2e       	mov	r14, r20
    struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &inputBuffer;

    SD_readSingleBlock(inputBuffer,unusedSectors + 1);
     5ac:	8c 01       	movw	r16, r24
     5ae:	40 91 e5 06 	lds	r20, 0x06E5
     5b2:	50 91 e6 06 	lds	r21, 0x06E6
     5b6:	60 91 e7 06 	lds	r22, 0x06E7
     5ba:	70 91 e8 06 	lds	r23, 0x06E8
     5be:	4f 5f       	subi	r20, 0xFF	; 255
     5c0:	5f 4f       	sbci	r21, 0xFF	; 255
     5c2:	6f 4f       	sbci	r22, 0xFF	; 255
     5c4:	7f 4f       	sbci	r23, 0xFF	; 255
     5c6:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>

    if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
     5ca:	89 81       	ldd	r24, Y+1	; 0x01
     5cc:	9a 81       	ldd	r25, Y+2	; 0x02
     5ce:	ab 81       	ldd	r26, Y+3	; 0x03
     5d0:	bc 81       	ldd	r27, Y+4	; 0x04
     5d2:	82 35       	cpi	r24, 0x52	; 82
     5d4:	92 45       	sbci	r25, 0x52	; 82
     5d6:	a1 46       	sbci	r26, 0x61	; 97
     5d8:	b1 44       	sbci	r27, 0x41	; 65
     5da:	09 f0       	breq	.+2      	; 0x5de <getSetFreeCluster+0x4c>
     5dc:	3f c0       	rjmp	.+126    	; 0x65c <getSetFreeCluster+0xca>
     5de:	cb 51       	subi	r28, 0x1B	; 27
     5e0:	de 4f       	sbci	r29, 0xFE	; 254
     5e2:	88 81       	ld	r24, Y
     5e4:	99 81       	ldd	r25, Y+1	; 0x01
     5e6:	aa 81       	ldd	r26, Y+2	; 0x02
     5e8:	bb 81       	ldd	r27, Y+3	; 0x03
     5ea:	c5 5e       	subi	r28, 0xE5	; 229
     5ec:	d1 40       	sbci	r29, 0x01	; 1
     5ee:	82 37       	cpi	r24, 0x72	; 114
     5f0:	92 47       	sbci	r25, 0x72	; 114
     5f2:	a1 44       	sbci	r26, 0x41	; 65
     5f4:	b1 46       	sbci	r27, 0x61	; 97
     5f6:	91 f5       	brne	.+100    	; 0x65c <getSetFreeCluster+0xca>
     5f8:	c3 50       	subi	r28, 0x03	; 3
     5fa:	de 4f       	sbci	r29, 0xFE	; 254
     5fc:	88 81       	ld	r24, Y
     5fe:	99 81       	ldd	r25, Y+1	; 0x01
     600:	aa 81       	ldd	r26, Y+2	; 0x02
     602:	bb 81       	ldd	r27, Y+3	; 0x03
     604:	cd 5f       	subi	r28, 0xFD	; 253
     606:	d1 40       	sbci	r29, 0x01	; 1
     608:	00 97       	sbiw	r24, 0x00	; 0
     60a:	a5 45       	sbci	r26, 0x55	; 85
     60c:	ba 4a       	sbci	r27, 0xAA	; 170
     60e:	31 f5       	brne	.+76     	; 0x65c <getSetFreeCluster+0xca>
        return 0xffffffff;

    if(get_set == GET)
     610:	e1 10       	cpse	r14, r1
     612:	15 c0       	rjmp	.+42     	; 0x63e <getSetFreeCluster+0xac>
    {
        if(totOrNext == TOTAL_FREE)
     614:	81 e0       	ldi	r24, 0x01	; 1
     616:	f8 12       	cpse	r15, r24
     618:	09 c0       	rjmp	.+18     	; 0x62c <getSetFreeCluster+0x9a>
            return(FS->freeClusterCount);
     61a:	c7 51       	subi	r28, 0x17	; 23
     61c:	de 4f       	sbci	r29, 0xFE	; 254
     61e:	68 81       	ld	r22, Y
     620:	79 81       	ldd	r23, Y+1	; 0x01
     622:	8a 81       	ldd	r24, Y+2	; 0x02
     624:	9b 81       	ldd	r25, Y+3	; 0x03
     626:	c9 5e       	subi	r28, 0xE9	; 233
     628:	d1 40       	sbci	r29, 0x01	; 1
     62a:	1b c0       	rjmp	.+54     	; 0x662 <getSetFreeCluster+0xd0>
        else // when totOrNext = NEXT_FREE
            return(FS->nextFreeCluster);
     62c:	c3 51       	subi	r28, 0x13	; 19
     62e:	de 4f       	sbci	r29, 0xFE	; 254
     630:	68 81       	ld	r22, Y
     632:	79 81       	ldd	r23, Y+1	; 0x01
     634:	8a 81       	ldd	r24, Y+2	; 0x02
     636:	9b 81       	ldd	r25, Y+3	; 0x03
     638:	cd 5e       	subi	r28, 0xED	; 237
     63a:	d1 40       	sbci	r29, 0x01	; 1
     63c:	12 c0       	rjmp	.+36     	; 0x662 <getSetFreeCluster+0xd0>
        if(totOrNext == TOTAL_FREE)
            FS->freeClusterCount = FSEntry;
        else // when totOrNext = NEXT_FREE
            FS->nextFreeCluster = FSEntry;

        SD_writeSingleBlock(inputBuffer,unusedSectors + 1);	//update FSinfo
     63e:	40 91 e5 06 	lds	r20, 0x06E5
     642:	50 91 e6 06 	lds	r21, 0x06E6
     646:	60 91 e7 06 	lds	r22, 0x06E7
     64a:	70 91 e8 06 	lds	r23, 0x06E8
     64e:	4f 5f       	subi	r20, 0xFF	; 255
     650:	5f 4f       	sbci	r21, 0xFF	; 255
     652:	6f 4f       	sbci	r22, 0xFF	; 255
     654:	7f 4f       	sbci	r23, 0xFF	; 255
     656:	c8 01       	movw	r24, r16
     658:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <SD_writeSingleBlock>
    struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &inputBuffer;

    SD_readSingleBlock(inputBuffer,unusedSectors + 1);

    if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
        return 0xffffffff;
     65c:	6f ef       	ldi	r22, 0xFF	; 255
     65e:	7f ef       	ldi	r23, 0xFF	; 255
     660:	cb 01       	movw	r24, r22
            FS->nextFreeCluster = FSEntry;

        SD_writeSingleBlock(inputBuffer,unusedSectors + 1);	//update FSinfo
    }
    return 0xffffffff;
}
     662:	0f 90       	pop	r0
     664:	0f 90       	pop	r0
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	ff 90       	pop	r15
     670:	ef 90       	pop	r14
     672:	08 95       	ret

00000674 <FILE_GetMemoryStatics>:
 * description :
                 This functions calculates the total and free memory of the SD card.
                 Note: It takes upto 10secs(for 32GB) to calculate the memory statics depending on the size of CARD
 ******************************************************************************************************************/
void FILE_GetMemoryStatics(uint32_t *ptr_totalMemory, uint32_t *ptr_freeMemory)
{
     674:	2f 92       	push	r2
     676:	3f 92       	push	r3
     678:	4f 92       	push	r4
     67a:	5f 92       	push	r5
     67c:	6f 92       	push	r6
     67e:	7f 92       	push	r7
     680:	8f 92       	push	r8
     682:	9f 92       	push	r9
     684:	af 92       	push	r10
     686:	bf 92       	push	r11
     688:	cf 92       	push	r12
     68a:	df 92       	push	r13
     68c:	ef 92       	push	r14
     68e:	ff 92       	push	r15
     690:	0f 93       	push	r16
     692:	1f 93       	push	r17
     694:	cf 93       	push	r28
     696:	df 93       	push	r29
     698:	00 d0       	rcall	.+0      	; 0x69a <FILE_GetMemoryStatics+0x26>
     69a:	00 d0       	rcall	.+0      	; 0x69c <FILE_GetMemoryStatics+0x28>
     69c:	cd b7       	in	r28, 0x3d	; 61
     69e:	de b7       	in	r29, 0x3e	; 62
     6a0:	fc 01       	movw	r30, r24
     6a2:	1b 01       	movw	r2, r22
    uint32_t freeClusters = 0, totalClusterCount, cluster;
    uint32_t sector, *value;
    uint8_t i;

    *ptr_totalMemory = totalClusters * sectorPerCluster / 1024;
     6a4:	a0 91 e3 06 	lds	r26, 0x06E3
     6a8:	b0 91 e4 06 	lds	r27, 0x06E4
     6ac:	20 91 db 04 	lds	r18, 0x04DB
     6b0:	30 91 dc 04 	lds	r19, 0x04DC
     6b4:	40 91 dd 04 	lds	r20, 0x04DD
     6b8:	50 91 de 04 	lds	r21, 0x04DE
     6bc:	0e 94 ac 14 	call	0x2958	; 0x2958 <__muluhisi3>
     6c0:	9b 01       	movw	r18, r22
     6c2:	ac 01       	movw	r20, r24
     6c4:	6a e0       	ldi	r22, 0x0A	; 10
     6c6:	56 95       	lsr	r21
     6c8:	47 95       	ror	r20
     6ca:	37 95       	ror	r19
     6cc:	27 95       	ror	r18
     6ce:	6a 95       	dec	r22
     6d0:	d1 f7       	brne	.-12     	; 0x6c6 <FILE_GetMemoryStatics+0x52>
    *ptr_totalMemory *= bytesPerSector;
     6d2:	a0 91 d9 04 	lds	r26, 0x04D9
     6d6:	b0 91 da 04 	lds	r27, 0x04DA
     6da:	0e 94 ac 14 	call	0x2958	; 0x2958 <__muluhisi3>
     6de:	60 83       	st	Z, r22
     6e0:	71 83       	std	Z+1, r23	; 0x01
     6e2:	82 83       	std	Z+2, r24	; 0x02
     6e4:	93 83       	std	Z+3, r25	; 0x03

    freeClusters = getSetFreeCluster (GlobalBuffer,TOTAL_FREE, GET, 0);
     6e6:	00 e0       	ldi	r16, 0x00	; 0
     6e8:	10 e0       	ldi	r17, 0x00	; 0
     6ea:	98 01       	movw	r18, r16
     6ec:	40 e0       	ldi	r20, 0x00	; 0
     6ee:	61 e0       	ldi	r22, 0x01	; 1
     6f0:	8f ed       	ldi	r24, 0xDF	; 223
     6f2:	94 e0       	ldi	r25, 0x04	; 4
     6f4:	4e df       	rcall	.-356    	; 0x592 <getSetFreeCluster>
     6f6:	6b 01       	movw	r12, r22
     6f8:	7c 01       	movw	r14, r24

    if(freeClusters > totalClusters)
     6fa:	80 91 db 04 	lds	r24, 0x04DB
     6fe:	90 91 dc 04 	lds	r25, 0x04DC
     702:	a0 91 dd 04 	lds	r26, 0x04DD
     706:	b0 91 de 04 	lds	r27, 0x04DE
     70a:	8c 15       	cp	r24, r12
     70c:	9d 05       	cpc	r25, r13
     70e:	ae 05       	cpc	r26, r14
     710:	bf 05       	cpc	r27, r15
     712:	08 f0       	brcs	.+2      	; 0x716 <FILE_GetMemoryStatics+0xa2>
     714:	76 c0       	rjmp	.+236    	; 0x802 <FILE_GetMemoryStatics+0x18e>
    {
        freeClusterCountUpdated = 0;
     716:	10 92 67 0b 	sts	0x0B67, r1
     71a:	80 90 df 06 	lds	r8, 0x06DF
     71e:	90 90 e0 06 	lds	r9, 0x06E0
     722:	a0 90 e1 06 	lds	r10, 0x06E1
     726:	b0 90 e2 06 	lds	r11, 0x06E2
     72a:	92 e0       	ldi	r25, 0x02	; 2
     72c:	88 0c       	add	r8, r8
     72e:	99 1c       	adc	r9, r9
     730:	aa 1c       	adc	r10, r10
     732:	bb 1c       	adc	r11, r11
     734:	9a 95       	dec	r25
     736:	d1 f7       	brne	.-12     	; 0x72c <FILE_GetMemoryStatics+0xb8>
        freeClusters = 0;
        totalClusterCount = 0;
     738:	41 2c       	mov	r4, r1
     73a:	51 2c       	mov	r5, r1
     73c:	32 01       	movw	r6, r4
    freeClusters = getSetFreeCluster (GlobalBuffer,TOTAL_FREE, GET, 0);

    if(freeClusters > totalClusters)
    {
        freeClusterCountUpdated = 0;
        freeClusters = 0;
     73e:	c1 2c       	mov	r12, r1
     740:	d1 2c       	mov	r13, r1
     742:	76 01       	movw	r14, r12
        totalClusterCount = 0;
        cluster = rootCluster;
        while(1)
        {
            sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector) ;
     744:	80 91 e9 06 	lds	r24, 0x06E9
     748:	90 91 ea 06 	lds	r25, 0x06EA
     74c:	40 91 e5 06 	lds	r20, 0x06E5
     750:	50 91 e6 06 	lds	r21, 0x06E6
     754:	60 91 e7 06 	lds	r22, 0x06E7
     758:	70 91 e8 06 	lds	r23, 0x06E8
     75c:	8a 01       	movw	r16, r20
     75e:	9b 01       	movw	r18, r22
     760:	08 0f       	add	r16, r24
     762:	19 1f       	adc	r17, r25
     764:	21 1d       	adc	r18, r1
     766:	31 1d       	adc	r19, r1
     768:	09 83       	std	Y+1, r16	; 0x01
     76a:	1a 83       	std	Y+2, r17	; 0x02
     76c:	2b 83       	std	Y+3, r18	; 0x03
     76e:	3c 83       	std	Y+4, r19	; 0x04
     770:	20 91 d9 04 	lds	r18, 0x04D9
     774:	30 91 da 04 	lds	r19, 0x04DA
     778:	40 e0       	ldi	r20, 0x00	; 0
     77a:	50 e0       	ldi	r21, 0x00	; 0
     77c:	c5 01       	movw	r24, r10
     77e:	b4 01       	movw	r22, r8
     780:	0e 94 72 14 	call	0x28e4	; 0x28e4 <__udivmodsi4>
     784:	89 81       	ldd	r24, Y+1	; 0x01
     786:	9a 81       	ldd	r25, Y+2	; 0x02
     788:	ab 81       	ldd	r26, Y+3	; 0x03
     78a:	bc 81       	ldd	r27, Y+4	; 0x04
     78c:	82 0f       	add	r24, r18
     78e:	93 1f       	adc	r25, r19
     790:	a4 1f       	adc	r26, r20
     792:	b5 1f       	adc	r27, r21
     794:	ac 01       	movw	r20, r24
     796:	bd 01       	movw	r22, r26
            SD_readSingleBlock(GlobalBuffer,sector);
     798:	8f ed       	ldi	r24, 0xDF	; 223
     79a:	94 e0       	ldi	r25, 0x04	; 4
     79c:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>
                value = (uint32_t *) &GlobalBuffer[i*4];
                if(((*value)& 0x0fffffff) == 0)
                    freeClusters++;;

                totalClusterCount++;
                if(totalClusterCount == (totalClusters+2)) break;
     7a0:	40 91 db 04 	lds	r20, 0x04DB
     7a4:	50 91 dc 04 	lds	r21, 0x04DC
     7a8:	60 91 dd 04 	lds	r22, 0x04DD
     7ac:	70 91 de 04 	lds	r23, 0x04DE
     7b0:	4e 5f       	subi	r20, 0xFE	; 254
     7b2:	5f 4f       	sbci	r21, 0xFF	; 255
     7b4:	6f 4f       	sbci	r22, 0xFF	; 255
     7b6:	7f 4f       	sbci	r23, 0xFF	; 255
     7b8:	ef ed       	ldi	r30, 0xDF	; 223
     7ba:	f4 e0       	ldi	r31, 0x04	; 4
        cluster = rootCluster;
        while(1)
        {
            sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector) ;
            SD_readSingleBlock(GlobalBuffer,sector);
            for(i=0; i<128; i++)
     7bc:	80 e0       	ldi	r24, 0x00	; 0
     7be:	80 38       	cpi	r24, 0x80	; 128
     7c0:	d1 f0       	breq	.+52     	; 0x7f6 <FILE_GetMemoryStatics+0x182>
            {
                value = (uint32_t *) &GlobalBuffer[i*4];
                if(((*value)& 0x0fffffff) == 0)
     7c2:	01 91       	ld	r16, Z+
     7c4:	11 91       	ld	r17, Z+
     7c6:	21 91       	ld	r18, Z+
     7c8:	31 91       	ld	r19, Z+
     7ca:	3f 70       	andi	r19, 0x0F	; 15
     7cc:	01 2b       	or	r16, r17
     7ce:	02 2b       	or	r16, r18
     7d0:	03 2b       	or	r16, r19
     7d2:	29 f4       	brne	.+10     	; 0x7de <FILE_GetMemoryStatics+0x16a>
                    freeClusters++;;
     7d4:	9f ef       	ldi	r25, 0xFF	; 255
     7d6:	c9 1a       	sub	r12, r25
     7d8:	d9 0a       	sbc	r13, r25
     7da:	e9 0a       	sbc	r14, r25
     7dc:	f9 0a       	sbc	r15, r25

                totalClusterCount++;
     7de:	af ef       	ldi	r26, 0xFF	; 255
     7e0:	4a 1a       	sub	r4, r26
     7e2:	5a 0a       	sbc	r5, r26
     7e4:	6a 0a       	sbc	r6, r26
     7e6:	7a 0a       	sbc	r7, r26
                if(totalClusterCount == (totalClusters+2)) break;
     7e8:	44 16       	cp	r4, r20
     7ea:	55 06       	cpc	r5, r21
     7ec:	66 06       	cpc	r6, r22
     7ee:	77 06       	cpc	r7, r23
     7f0:	11 f0       	breq	.+4      	; 0x7f6 <FILE_GetMemoryStatics+0x182>
        cluster = rootCluster;
        while(1)
        {
            sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector) ;
            SD_readSingleBlock(GlobalBuffer,sector);
            for(i=0; i<128; i++)
     7f2:	8f 5f       	subi	r24, 0xFF	; 255
     7f4:	e4 cf       	rjmp	.-56     	; 0x7be <FILE_GetMemoryStatics+0x14a>
     7f6:	b2 e0       	ldi	r27, 0x02	; 2
     7f8:	9b 0e       	add	r9, r27
     7fa:	a1 1c       	adc	r10, r1
     7fc:	b1 1c       	adc	r11, r1
                    freeClusters++;;

                totalClusterCount++;
                if(totalClusterCount == (totalClusters+2)) break;
            }
            if(i < 128) break;
     7fe:	87 fd       	sbrc	r24, 7
     800:	a1 cf       	rjmp	.-190    	; 0x744 <FILE_GetMemoryStatics+0xd0>
            cluster+=128;
        }
    }

    *ptr_freeMemory = freeClusters * sectorPerCluster / 1024;
     802:	a0 91 e3 06 	lds	r26, 0x06E3
     806:	b0 91 e4 06 	lds	r27, 0x06E4
     80a:	a7 01       	movw	r20, r14
     80c:	96 01       	movw	r18, r12
     80e:	0e 94 ac 14 	call	0x2958	; 0x2958 <__muluhisi3>
     812:	9b 01       	movw	r18, r22
     814:	ac 01       	movw	r20, r24
     816:	8a e0       	ldi	r24, 0x0A	; 10
     818:	56 95       	lsr	r21
     81a:	47 95       	ror	r20
     81c:	37 95       	ror	r19
     81e:	27 95       	ror	r18
     820:	8a 95       	dec	r24
     822:	d1 f7       	brne	.-12     	; 0x818 <FILE_GetMemoryStatics+0x1a4>
    *ptr_freeMemory *= bytesPerSector ;
     824:	a0 91 d9 04 	lds	r26, 0x04D9
     828:	b0 91 da 04 	lds	r27, 0x04DA
     82c:	0e 94 ac 14 	call	0x2958	; 0x2958 <__muluhisi3>
     830:	f1 01       	movw	r30, r2
     832:	60 83       	st	Z, r22
     834:	71 83       	std	Z+1, r23	; 0x01
     836:	82 83       	std	Z+2, r24	; 0x02
     838:	93 83       	std	Z+3, r25	; 0x03
}
     83a:	0f 90       	pop	r0
     83c:	0f 90       	pop	r0
     83e:	0f 90       	pop	r0
     840:	0f 90       	pop	r0
     842:	df 91       	pop	r29
     844:	cf 91       	pop	r28
     846:	1f 91       	pop	r17
     848:	0f 91       	pop	r16
     84a:	ff 90       	pop	r15
     84c:	ef 90       	pop	r14
     84e:	df 90       	pop	r13
     850:	cf 90       	pop	r12
     852:	bf 90       	pop	r11
     854:	af 90       	pop	r10
     856:	9f 90       	pop	r9
     858:	8f 90       	pop	r8
     85a:	7f 90       	pop	r7
     85c:	6f 90       	pop	r6
     85e:	5f 90       	pop	r5
     860:	4f 90       	pop	r4
     862:	3f 90       	pop	r3
     864:	2f 90       	pop	r2
     866:	08 95       	ret

00000868 <getBootSectorData>:




uint8_t getBootSectorData (void)
{
     868:	4f 92       	push	r4
     86a:	5f 92       	push	r5
     86c:	6f 92       	push	r6
     86e:	7f 92       	push	r7
     870:	8f 92       	push	r8
     872:	9f 92       	push	r9
     874:	af 92       	push	r10
     876:	bf 92       	push	r11
     878:	cf 92       	push	r12
     87a:	df 92       	push	r13
     87c:	ef 92       	push	r14
     87e:	ff 92       	push	r15
     880:	0f 93       	push	r16
     882:	1f 93       	push	r17
     884:	cf 93       	push	r28
    struct BS_Structure *bpb; //mapping the buffer onto the structure
    struct MBRinfo_Structure *mbr;
    uint32_t dataSectors;


    unusedSectors = 0;
     886:	10 92 e5 06 	sts	0x06E5, r1
     88a:	10 92 e6 06 	sts	0x06E6, r1
     88e:	10 92 e7 06 	sts	0x06E7, r1
     892:	10 92 e8 06 	sts	0x06E8, r1

    SD_readSingleBlock(GlobalBuffer,0);
     896:	40 e0       	ldi	r20, 0x00	; 0
     898:	50 e0       	ldi	r21, 0x00	; 0
     89a:	ba 01       	movw	r22, r20
     89c:	8f ed       	ldi	r24, 0xDF	; 223
     89e:	94 e0       	ldi	r25, 0x04	; 4
     8a0:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>
    bpb = (struct BS_Structure *)GlobalBuffer;



    if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
     8a4:	80 91 df 04 	lds	r24, 0x04DF
     8a8:	8d 7f       	andi	r24, 0xFD	; 253
     8aa:	89 3e       	cpi	r24, 0xE9	; 233
     8ac:	09 f0       	breq	.+2      	; 0x8b0 <getBootSectorData+0x48>
     8ae:	91 c0       	rjmp	.+290    	; 0x9d2 <getBootSectorData+0x16a>
        {
            return SDCARD_FAT_INVALID;
        }
    }

    bytesPerSector = extract_DataBySize((uint8_t*)bpb->bytesPerSector,2);
     8b0:	62 e0       	ldi	r22, 0x02	; 2
     8b2:	8a ee       	ldi	r24, 0xEA	; 234
     8b4:	94 e0       	ldi	r25, 0x04	; 4
     8b6:	1f dc       	rcall	.-1986   	; 0xf6 <extract_DataBySize>
     8b8:	70 93 da 04 	sts	0x04DA, r23
     8bc:	60 93 d9 04 	sts	0x04D9, r22
    sectorPerCluster = bpb->sectorPerCluster;
     8c0:	c0 91 ec 04 	lds	r28, 0x04EC
     8c4:	8c 2f       	mov	r24, r28
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	90 93 e4 06 	sts	0x06E4, r25
     8cc:	80 93 e3 06 	sts	0x06E3, r24
    reservedSectorCount = extract_DataBySize((uint8_t*)bpb->reservedSectorCount,2);
     8d0:	62 e0       	ldi	r22, 0x02	; 2
     8d2:	8d ee       	ldi	r24, 0xED	; 237
     8d4:	94 e0       	ldi	r25, 0x04	; 4
     8d6:	0f dc       	rcall	.-2018   	; 0xf6 <extract_DataBySize>
     8d8:	4b 01       	movw	r8, r22
     8da:	5c 01       	movw	r10, r24
     8dc:	70 93 ea 06 	sts	0x06EA, r23
     8e0:	60 93 e9 06 	sts	0x06E9, r22
    rootCluster = extract_DataBySize((uint8_t*)bpb->rootCluster,4);
     8e4:	64 e0       	ldi	r22, 0x04	; 4
     8e6:	8b e0       	ldi	r24, 0x0B	; 11
     8e8:	95 e0       	ldi	r25, 0x05	; 5
     8ea:	05 dc       	rcall	.-2038   	; 0xf6 <extract_DataBySize>
     8ec:	60 93 df 06 	sts	0x06DF, r22
     8f0:	70 93 e0 06 	sts	0x06E0, r23
     8f4:	80 93 e1 06 	sts	0x06E1, r24
     8f8:	90 93 e2 06 	sts	0x06E2, r25

    firstDataSector = extract_DataBySize((uint8_t*)bpb->hiddenSectors,4) + reservedSectorCount + (bpb->numberofFATs * extract_DataBySize(bpb->FATsize_F32,4));
     8fc:	64 e0       	ldi	r22, 0x04	; 4
     8fe:	8b ef       	ldi	r24, 0xFB	; 251
     900:	94 e0       	ldi	r25, 0x04	; 4
     902:	f9 db       	rcall	.-2062   	; 0xf6 <extract_DataBySize>
     904:	6b 01       	movw	r12, r22
     906:	7c 01       	movw	r14, r24
     908:	aa 24       	eor	r10, r10
     90a:	bb 24       	eor	r11, r11
     90c:	40 90 ef 04 	lds	r4, 0x04EF
     910:	51 2c       	mov	r5, r1
     912:	61 2c       	mov	r6, r1
     914:	71 2c       	mov	r7, r1
     916:	64 e0       	ldi	r22, 0x04	; 4
     918:	83 e0       	ldi	r24, 0x03	; 3
     91a:	95 e0       	ldi	r25, 0x05	; 5
     91c:	ec db       	rcall	.-2088   	; 0xf6 <extract_DataBySize>
     91e:	9b 01       	movw	r18, r22
     920:	ac 01       	movw	r20, r24
     922:	c3 01       	movw	r24, r6
     924:	b2 01       	movw	r22, r4
     926:	0e 94 63 14 	call	0x28c6	; 0x28c6 <__mulsi3>
     92a:	dc 01       	movw	r26, r24
     92c:	cb 01       	movw	r24, r22
     92e:	88 0d       	add	r24, r8
     930:	99 1d       	adc	r25, r9
     932:	aa 1d       	adc	r26, r10
     934:	bb 1d       	adc	r27, r11
     936:	c8 0e       	add	r12, r24
     938:	d9 1e       	adc	r13, r25
     93a:	ea 1e       	adc	r14, r26
     93c:	fb 1e       	adc	r15, r27
     93e:	c0 92 d5 04 	sts	0x04D5, r12
     942:	d0 92 d6 04 	sts	0x04D6, r13
     946:	e0 92 d7 04 	sts	0x04D7, r14
     94a:	f0 92 d8 04 	sts	0x04D8, r15

    dataSectors = (extract_DataBySize((uint8_t*)bpb->totalSectors_F32,4)) - reservedSectorCount - ( (bpb->numberofFATs) * extract_DataBySize(bpb->FATsize_F32,4));
     94e:	64 e0       	ldi	r22, 0x04	; 4
     950:	8f ef       	ldi	r24, 0xFF	; 255
     952:	94 e0       	ldi	r25, 0x04	; 4
     954:	d0 db       	rcall	.-2144   	; 0xf6 <extract_DataBySize>
     956:	6b 01       	movw	r12, r22
     958:	7c 01       	movw	r14, r24
     95a:	c8 18       	sub	r12, r8
     95c:	d9 08       	sbc	r13, r9
     95e:	ea 08       	sbc	r14, r10
     960:	fb 08       	sbc	r15, r11
     962:	64 e0       	ldi	r22, 0x04	; 4
     964:	83 e0       	ldi	r24, 0x03	; 3
     966:	95 e0       	ldi	r25, 0x05	; 5
     968:	c6 db       	rcall	.-2164   	; 0xf6 <extract_DataBySize>
     96a:	9b 01       	movw	r18, r22
     96c:	ac 01       	movw	r20, r24
     96e:	c3 01       	movw	r24, r6
     970:	b2 01       	movw	r22, r4
     972:	0e 94 63 14 	call	0x28c6	; 0x28c6 <__mulsi3>
     976:	a7 01       	movw	r20, r14
     978:	96 01       	movw	r18, r12
     97a:	26 1b       	sub	r18, r22
     97c:	37 0b       	sbc	r19, r23
     97e:	48 0b       	sbc	r20, r24
     980:	59 0b       	sbc	r21, r25
     982:	ca 01       	movw	r24, r20
     984:	b9 01       	movw	r22, r18
    totalClusters = dataSectors / sectorPerCluster;
     986:	2c 2f       	mov	r18, r28
     988:	30 e0       	ldi	r19, 0x00	; 0
     98a:	40 e0       	ldi	r20, 0x00	; 0
     98c:	50 e0       	ldi	r21, 0x00	; 0
     98e:	0e 94 72 14 	call	0x28e4	; 0x28e4 <__udivmodsi4>
     992:	20 93 db 04 	sts	0x04DB, r18
     996:	30 93 dc 04 	sts	0x04DC, r19
     99a:	40 93 dd 04 	sts	0x04DD, r20
     99e:	50 93 de 04 	sts	0x04DE, r21

    if((getSetFreeCluster (GlobalBuffer,TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     9a2:	00 e0       	ldi	r16, 0x00	; 0
     9a4:	10 e0       	ldi	r17, 0x00	; 0
     9a6:	98 01       	movw	r18, r16
     9a8:	40 e0       	ldi	r20, 0x00	; 0
     9aa:	61 e0       	ldi	r22, 0x01	; 1
     9ac:	8f ed       	ldi	r24, 0xDF	; 223
     9ae:	94 e0       	ldi	r25, 0x04	; 4
     9b0:	f0 dd       	rcall	.-1056   	; 0x592 <getSetFreeCluster>
     9b2:	c0 90 db 04 	lds	r12, 0x04DB
     9b6:	d0 90 dc 04 	lds	r13, 0x04DC
     9ba:	e0 90 dd 04 	lds	r14, 0x04DD
     9be:	f0 90 de 04 	lds	r15, 0x04DE
     9c2:	c6 16       	cp	r12, r22
     9c4:	d7 06       	cpc	r13, r23
     9c6:	e8 06       	cpc	r14, r24
     9c8:	f9 06       	cpc	r15, r25
     9ca:	20 f5       	brcc	.+72     	; 0xa14 <getBootSectorData+0x1ac>
        freeClusterCountUpdated = 0;
     9cc:	10 92 67 0b 	sts	0x0B67, r1
     9d0:	24 c0       	rjmp	.+72     	; 0xa1a <getBootSectorData+0x1b2>
    {
        mbr = (struct MBRinfo_Structure *) GlobalBuffer;       //if it is not boot sector, it must be MBR



        if(mbr->signature != 0xaa55)
     9d2:	80 91 dd 06 	lds	r24, 0x06DD
     9d6:	90 91 de 06 	lds	r25, 0x06DE
     9da:	85 35       	cpi	r24, 0x55	; 85
     9dc:	9a 4a       	sbci	r25, 0xAA	; 170
     9de:	11 f0       	breq	.+4      	; 0x9e4 <getBootSectorData+0x17c>
        {
            return SDCARD_FAT_INVALID;       //if it is not even MBR then it's not FAT32
     9e0:	83 e0       	ldi	r24, 0x03	; 3
     9e2:	1c c0       	rjmp	.+56     	; 0xa1c <getBootSectorData+0x1b4>
        }

        //partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
        unusedSectors = extract_DataBySize(((uint8_t*)GlobalBuffer)+454,4);//partition->firstSector; //the unused sectors, hidden to the FAT
     9e4:	64 e0       	ldi	r22, 0x04	; 4
     9e6:	85 ea       	ldi	r24, 0xA5	; 165
     9e8:	96 e0       	ldi	r25, 0x06	; 6
     9ea:	85 db       	rcall	.-2294   	; 0xf6 <extract_DataBySize>
     9ec:	ab 01       	movw	r20, r22
     9ee:	bc 01       	movw	r22, r24
     9f0:	40 93 e5 06 	sts	0x06E5, r20
     9f4:	50 93 e6 06 	sts	0x06E6, r21
     9f8:	60 93 e7 06 	sts	0x06E7, r22
     9fc:	70 93 e8 06 	sts	0x06E8, r23

        SD_readSingleBlock(GlobalBuffer,unusedSectors);//read the bpb sector
     a00:	8f ed       	ldi	r24, 0xDF	; 223
     a02:	94 e0       	ldi	r25, 0x04	; 4
     a04:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>
        bpb = (struct BS_Structure *)GlobalBuffer;
        if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)
     a08:	80 91 df 04 	lds	r24, 0x04DF
     a0c:	8d 7f       	andi	r24, 0xFD	; 253
     a0e:	89 3e       	cpi	r24, 0xE9	; 233
     a10:	39 f7       	brne	.-50     	; 0x9e0 <getBootSectorData+0x178>
     a12:	4e cf       	rjmp	.-356    	; 0x8b0 <getBootSectorData+0x48>
    totalClusters = dataSectors / sectorPerCluster;

    if((getSetFreeCluster (GlobalBuffer,TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
        freeClusterCountUpdated = 0;
    else
        freeClusterCountUpdated = 1;
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	80 93 67 0b 	sts	0x0B67, r24

    return SDCARD_INIT_SUCCESSFUL;
     a1a:	80 e0       	ldi	r24, 0x00	; 0
}
     a1c:	cf 91       	pop	r28
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	ff 90       	pop	r15
     a24:	ef 90       	pop	r14
     a26:	df 90       	pop	r13
     a28:	cf 90       	pop	r12
     a2a:	bf 90       	pop	r11
     a2c:	af 90       	pop	r10
     a2e:	9f 90       	pop	r9
     a30:	8f 90       	pop	r8
     a32:	7f 90       	pop	r7
     a34:	6f 90       	pop	r6
     a36:	5f 90       	pop	r5
     a38:	4f 90       	pop	r4
     a3a:	08 95       	ret

00000a3c <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
uint32_t searchNextFreeCluster (char *inputBuffer, uint32_t startCluster)
{
     a3c:	4f 92       	push	r4
     a3e:	5f 92       	push	r5
     a40:	6f 92       	push	r6
     a42:	7f 92       	push	r7
     a44:	8f 92       	push	r8
     a46:	9f 92       	push	r9
     a48:	af 92       	push	r10
     a4a:	bf 92       	push	r11
     a4c:	cf 92       	push	r12
     a4e:	df 92       	push	r13
     a50:	ef 92       	push	r14
     a52:	ff 92       	push	r15
     a54:	cf 93       	push	r28
     a56:	df 93       	push	r29
     a58:	ec 01       	movw	r28, r24
    uint32_t cluster, *value, sector;
    uint8_t i;

    startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
     a5a:	6a 01       	movw	r12, r20
     a5c:	7b 01       	movw	r14, r22
     a5e:	80 e8       	ldi	r24, 0x80	; 128
     a60:	c8 22       	and	r12, r24
     a62:	46 01       	movw	r8, r12
     a64:	57 01       	movw	r10, r14
     a66:	82 e0       	ldi	r24, 0x02	; 2
     a68:	88 0c       	add	r8, r8
     a6a:	99 1c       	adc	r9, r9
     a6c:	aa 1c       	adc	r10, r10
     a6e:	bb 1c       	adc	r11, r11
     a70:	8a 95       	dec	r24
     a72:	d1 f7       	brne	.-12     	; 0xa68 <searchNextFreeCluster+0x2c>
    for(cluster =startCluster; cluster <totalClusters; cluster+=128)
     a74:	80 91 db 04 	lds	r24, 0x04DB
     a78:	90 91 dc 04 	lds	r25, 0x04DC
     a7c:	a0 91 dd 04 	lds	r26, 0x04DD
     a80:	b0 91 de 04 	lds	r27, 0x04DE
     a84:	c8 16       	cp	r12, r24
     a86:	d9 06       	cpc	r13, r25
     a88:	ea 06       	cpc	r14, r26
     a8a:	fb 06       	cpc	r15, r27
     a8c:	08 f0       	brcs	.+2      	; 0xa90 <searchNextFreeCluster+0x54>
     a8e:	44 c0       	rjmp	.+136    	; 0xb18 <searchNextFreeCluster+0xdc>
    {
        sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
     a90:	80 91 e9 06 	lds	r24, 0x06E9
     a94:	90 91 ea 06 	lds	r25, 0x06EA
     a98:	40 91 e5 06 	lds	r20, 0x06E5
     a9c:	50 91 e6 06 	lds	r21, 0x06E6
     aa0:	60 91 e7 06 	lds	r22, 0x06E7
     aa4:	70 91 e8 06 	lds	r23, 0x06E8
     aa8:	2a 01       	movw	r4, r20
     aaa:	3b 01       	movw	r6, r22
     aac:	48 0e       	add	r4, r24
     aae:	59 1e       	adc	r5, r25
     ab0:	61 1c       	adc	r6, r1
     ab2:	71 1c       	adc	r7, r1
     ab4:	20 91 d9 04 	lds	r18, 0x04D9
     ab8:	30 91 da 04 	lds	r19, 0x04DA
     abc:	40 e0       	ldi	r20, 0x00	; 0
     abe:	50 e0       	ldi	r21, 0x00	; 0
     ac0:	c5 01       	movw	r24, r10
     ac2:	b4 01       	movw	r22, r8
     ac4:	0e 94 72 14 	call	0x28e4	; 0x28e4 <__udivmodsi4>
     ac8:	ba 01       	movw	r22, r20
     aca:	a9 01       	movw	r20, r18
     acc:	44 0d       	add	r20, r4
     ace:	55 1d       	adc	r21, r5
     ad0:	66 1d       	adc	r22, r6
     ad2:	77 1d       	adc	r23, r7
        SD_readSingleBlock(inputBuffer,sector);
     ad4:	ce 01       	movw	r24, r28
     ad6:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>
     ada:	fe 01       	movw	r30, r28
        for(i=0; i<128; i++)
     adc:	20 e0       	ldi	r18, 0x00	; 0
        {
            value = (uint32_t *) &inputBuffer[i*4];
            if(((*value) & 0x0fffffff) == 0)
     ade:	41 91       	ld	r20, Z+
     ae0:	51 91       	ld	r21, Z+
     ae2:	61 91       	ld	r22, Z+
     ae4:	71 91       	ld	r23, Z+
     ae6:	7f 70       	andi	r23, 0x0F	; 15
     ae8:	45 2b       	or	r20, r21
     aea:	46 2b       	or	r20, r22
     aec:	47 2b       	or	r20, r23
     aee:	39 f4       	brne	.+14     	; 0xafe <searchNextFreeCluster+0xc2>
            {
                return(cluster+i);
     af0:	c7 01       	movw	r24, r14
     af2:	b6 01       	movw	r22, r12
     af4:	62 0f       	add	r22, r18
     af6:	71 1d       	adc	r23, r1
     af8:	81 1d       	adc	r24, r1
     afa:	91 1d       	adc	r25, r1
     afc:	10 c0       	rjmp	.+32     	; 0xb1e <searchNextFreeCluster+0xe2>
    startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128)
    {
        sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
        SD_readSingleBlock(inputBuffer,sector);
        for(i=0; i<128; i++)
     afe:	2f 5f       	subi	r18, 0xFF	; 255
     b00:	20 38       	cpi	r18, 0x80	; 128
     b02:	69 f7       	brne	.-38     	; 0xade <searchNextFreeCluster+0xa2>
{
    uint32_t cluster, *value, sector;
    uint8_t i;

    startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128)
     b04:	80 e8       	ldi	r24, 0x80	; 128
     b06:	c8 0e       	add	r12, r24
     b08:	d1 1c       	adc	r13, r1
     b0a:	e1 1c       	adc	r14, r1
     b0c:	f1 1c       	adc	r15, r1
     b0e:	82 e0       	ldi	r24, 0x02	; 2
     b10:	98 0e       	add	r9, r24
     b12:	a1 1c       	adc	r10, r1
     b14:	b1 1c       	adc	r11, r1
     b16:	ae cf       	rjmp	.-164    	; 0xa74 <searchNextFreeCluster+0x38>
            {
                return(cluster+i);
            }
        }
    }
    return 0;
     b18:	60 e0       	ldi	r22, 0x00	; 0
     b1a:	70 e0       	ldi	r23, 0x00	; 0
     b1c:	cb 01       	movw	r24, r22
}
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	ff 90       	pop	r15
     b24:	ef 90       	pop	r14
     b26:	df 90       	pop	r13
     b28:	cf 90       	pop	r12
     b2a:	bf 90       	pop	r11
     b2c:	af 90       	pop	r10
     b2e:	9f 90       	pop	r9
     b30:	8f 90       	pop	r8
     b32:	7f 90       	pop	r7
     b34:	6f 90       	pop	r6
     b36:	5f 90       	pop	r5
     b38:	4f 90       	pop	r4
     b3a:	08 95       	ret

00000b3c <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
uint8_t convertFileName (char *inputFileName)
{
     b3c:	ef 92       	push	r14
     b3e:	ff 92       	push	r15
     b40:	0f 93       	push	r16
     b42:	1f 93       	push	r17
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	cd b7       	in	r28, 0x3d	; 61
     b4a:	de b7       	in	r29, 0x3e	; 62
     b4c:	2b 97       	sbiw	r28, 0x0b	; 11
     b4e:	0f b6       	in	r0, 0x3f	; 63
     b50:	f8 94       	cli
     b52:	de bf       	out	0x3e, r29	; 62
     b54:	0f be       	out	0x3f, r0	; 63
     b56:	cd bf       	out	0x3d, r28	; 61
     b58:	ac 01       	movw	r20, r24
     b5a:	7c 01       	movw	r14, r24
     b5c:	fc 01       	movw	r30, r24
    uint8_t fileNameFAT[11];
    uint8_t j, k;

    for(j=0; j<12; j++)
     b5e:	90 e0       	ldi	r25, 0x00	; 0
        if(inputFileName[j] == '.') break;
     b60:	81 91       	ld	r24, Z+
     b62:	8e 32       	cpi	r24, 0x2E	; 46
     b64:	21 f0       	breq	.+8      	; 0xb6e <convertFileName+0x32>
uint8_t convertFileName (char *inputFileName)
{
    uint8_t fileNameFAT[11];
    uint8_t j, k;

    for(j=0; j<12; j++)
     b66:	9f 5f       	subi	r25, 0xFF	; 255
     b68:	9c 30       	cpi	r25, 0x0C	; 12
     b6a:	d1 f7       	brne	.-12     	; 0xb60 <convertFileName+0x24>
     b6c:	4c c0       	rjmp	.+152    	; 0xc06 <convertFileName+0xca>
     b6e:	29 2f       	mov	r18, r25
        if(inputFileName[j] == '.') break;


    if(j>8)
     b70:	99 30       	cpi	r25, 0x09	; 9
     b72:	08 f0       	brcs	.+2      	; 0xb76 <convertFileName+0x3a>
     b74:	48 c0       	rjmp	.+144    	; 0xc06 <convertFileName+0xca>
     b76:	fe 01       	movw	r30, r28
     b78:	31 96       	adiw	r30, 0x01	; 1
     b7a:	bf 01       	movw	r22, r30
     b7c:	8a 01       	movw	r16, r20
     b7e:	8e 2f       	mov	r24, r30
     b80:	36 2f       	mov	r19, r22
     b82:	3e 1b       	sub	r19, r30
    {
        return FAT32_INVALID_FLIE_NAME;
    }

    for(k=0; k<j; k++) //setting file name
     b84:	39 17       	cp	r19, r25
     b86:	38 f4       	brcc	.+14     	; 0xb96 <convertFileName+0x5a>
        fileNameFAT[k] = inputFileName[k];
     b88:	d8 01       	movw	r26, r16
     b8a:	3d 91       	ld	r19, X+
     b8c:	8d 01       	movw	r16, r26
     b8e:	db 01       	movw	r26, r22
     b90:	3d 93       	st	X+, r19
     b92:	bd 01       	movw	r22, r26
     b94:	f5 cf       	rjmp	.-22     	; 0xb80 <convertFileName+0x44>

    for(k=j; k<=7; k++) //filling file name trail with blanks
        fileNameFAT[k] = ' ';
     b96:	30 e2       	ldi	r19, 0x20	; 32
    }

    for(k=0; k<j; k++) //setting file name
        fileNameFAT[k] = inputFileName[k];

    for(k=j; k<=7; k++) //filling file name trail with blanks
     b98:	98 30       	cpi	r25, 0x08	; 8
     b9a:	39 f0       	breq	.+14     	; 0xbaa <convertFileName+0x6e>
        fileNameFAT[k] = ' ';
     b9c:	bf 01       	movw	r22, r30
     b9e:	69 0f       	add	r22, r25
     ba0:	71 1d       	adc	r23, r1
     ba2:	db 01       	movw	r26, r22
     ba4:	3c 93       	st	X, r19
    }

    for(k=0; k<j; k++) //setting file name
        fileNameFAT[k] = inputFileName[k];

    for(k=j; k<=7; k++) //filling file name trail with blanks
     ba6:	9f 5f       	subi	r25, 0xFF	; 255
     ba8:	f7 cf       	rjmp	.-18     	; 0xb98 <convertFileName+0x5c>
        fileNameFAT[k] = ' ';

    j++;
     baa:	2f 5f       	subi	r18, 0xFF	; 255
    {
        if(inputFileName[j] != 0)
            fileNameFAT[k] = inputFileName[j++];
        else //filling extension trail with blanks
            while(k<11)
                fileNameFAT[k++] = ' ';
     bac:	60 e2       	ldi	r22, 0x20	; 32
        fileNameFAT[k] = ' ';

    j++;
    for(k=8; k<11; k++) //setting file extention
    {
        if(inputFileName[j] != 0)
     bae:	8a 01       	movw	r16, r20
     bb0:	02 0f       	add	r16, r18
     bb2:	11 1d       	adc	r17, r1
     bb4:	d8 01       	movw	r26, r16
     bb6:	3c 91       	ld	r19, X
     bb8:	33 23       	and	r19, r19
     bba:	39 f0       	breq	.+14     	; 0xbca <convertFileName+0x8e>
            fileNameFAT[k] = inputFileName[j++];
     bbc:	2f 5f       	subi	r18, 0xFF	; 255
     bbe:	8f 01       	movw	r16, r30
     bc0:	09 0f       	add	r16, r25
     bc2:	11 1d       	adc	r17, r1
     bc4:	d8 01       	movw	r26, r16
     bc6:	3c 93       	st	X, r19
     bc8:	0a c0       	rjmp	.+20     	; 0xbde <convertFileName+0xa2>
        fileNameFAT[k] = ' ';

    j++;
    for(k=8; k<11; k++) //setting file extention
    {
        if(inputFileName[j] != 0)
     bca:	39 2f       	mov	r19, r25
            fileNameFAT[k] = inputFileName[j++];
        else //filling extension trail with blanks
            while(k<11)
                fileNameFAT[k++] = ' ';
     bcc:	9f 5f       	subi	r25, 0xFF	; 255
     bce:	8f 01       	movw	r16, r30
     bd0:	03 0f       	add	r16, r19
     bd2:	11 1d       	adc	r17, r1
     bd4:	d8 01       	movw	r26, r16
     bd6:	6c 93       	st	X, r22
     bd8:	39 2f       	mov	r19, r25
    for(k=8; k<11; k++) //setting file extention
    {
        if(inputFileName[j] != 0)
            fileNameFAT[k] = inputFileName[j++];
        else //filling extension trail with blanks
            while(k<11)
     bda:	9b 30       	cpi	r25, 0x0B	; 11
     bdc:	b8 f3       	brcs	.-18     	; 0xbcc <convertFileName+0x90>

    for(k=j; k<=7; k++) //filling file name trail with blanks
        fileNameFAT[k] = ' ';

    j++;
    for(k=8; k<11; k++) //setting file extention
     bde:	9f 5f       	subi	r25, 0xFF	; 255
     be0:	9b 30       	cpi	r25, 0x0B	; 11
     be2:	28 f3       	brcs	.-54     	; 0xbae <convertFileName+0x72>
     be4:	9b e0       	ldi	r25, 0x0B	; 11
     be6:	98 0f       	add	r25, r24
                fileNameFAT[k++] = ' ';
    }

    for(j=0; j<11; j++) //converting small letters to caps
    {
        if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
     be8:	81 91       	ld	r24, Z+
     bea:	2f e9       	ldi	r18, 0x9F	; 159
     bec:	28 0f       	add	r18, r24
     bee:	2a 31       	cpi	r18, 0x1A	; 26
     bf0:	08 f4       	brcc	.+2      	; 0xbf4 <convertFileName+0xb8>
        {
            inputFileName[j] = fileNameFAT[j] - 0x20;
     bf2:	80 52       	subi	r24, 0x20	; 32
        }
        else
        {
            inputFileName[j] = fileNameFAT[j];
     bf4:	d7 01       	movw	r26, r14
     bf6:	8c 93       	st	X, r24
     bf8:	bf ef       	ldi	r27, 0xFF	; 255
     bfa:	eb 1a       	sub	r14, r27
     bfc:	fb 0a       	sbc	r15, r27
        else //filling extension trail with blanks
            while(k<11)
                fileNameFAT[k++] = ' ';
    }

    for(j=0; j<11; j++) //converting small letters to caps
     bfe:	9e 13       	cpse	r25, r30
     c00:	f3 cf       	rjmp	.-26     	; 0xbe8 <convertFileName+0xac>
        {
            inputFileName[j] = fileNameFAT[j];
        }
    }

    return FAT32_VALID_FILE_NAME;
     c02:	83 e0       	ldi	r24, 0x03	; 3
     c04:	01 c0       	rjmp	.+2      	; 0xc08 <convertFileName+0xcc>
        if(inputFileName[j] == '.') break;


    if(j>8)
    {
        return FAT32_INVALID_FLIE_NAME;
     c06:	84 e0       	ldi	r24, 0x04	; 4
            inputFileName[j] = fileNameFAT[j];
        }
    }

    return FAT32_VALID_FILE_NAME;
}
     c08:	2b 96       	adiw	r28, 0x0b	; 11
     c0a:	0f b6       	in	r0, 0x3f	; 63
     c0c:	f8 94       	cli
     c0e:	de bf       	out	0x3e, r29	; 62
     c10:	0f be       	out	0x3f, r0	; 63
     c12:	cd bf       	out	0x3d, r28	; 61
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	1f 91       	pop	r17
     c1a:	0f 91       	pop	r16
     c1c:	ff 90       	pop	r15
     c1e:	ef 90       	pop	r14
     c20:	08 95       	ret

00000c22 <openFile>:
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: none
//************************************************************************************
uint8_t openFile (uint8_t fileOperation, fileConfig_st *filePtr)
{
     c22:	2f 92       	push	r2
     c24:	3f 92       	push	r3
     c26:	4f 92       	push	r4
     c28:	5f 92       	push	r5
     c2a:	6f 92       	push	r6
     c2c:	7f 92       	push	r7
     c2e:	8f 92       	push	r8
     c30:	9f 92       	push	r9
     c32:	af 92       	push	r10
     c34:	bf 92       	push	r11
     c36:	cf 92       	push	r12
     c38:	df 92       	push	r13
     c3a:	ef 92       	push	r14
     c3c:	ff 92       	push	r15
     c3e:	0f 93       	push	r16
     c40:	1f 93       	push	r17
     c42:	cf 93       	push	r28
     c44:	df 93       	push	r29
     c46:	cd b7       	in	r28, 0x3d	; 61
     c48:	de b7       	in	r29, 0x3e	; 62
     c4a:	2f 97       	sbiw	r28, 0x0f	; 15
     c4c:	0f b6       	in	r0, 0x3f	; 63
     c4e:	f8 94       	cli
     c50:	de bf       	out	0x3e, r29	; 62
     c52:	0f be       	out	0x3f, r0	; 63
     c54:	cd bf       	out	0x3d, r28	; 61
     c56:	8f 83       	std	Y+7, r24	; 0x07
     c58:	7f 87       	std	Y+15, r23	; 0x0f
     c5a:	6e 87       	std	Y+14, r22	; 0x0e
    uint8_t returnStatus;
    uint32_t cluster = rootCluster, sector, firstSector;
     c5c:	80 90 df 06 	lds	r8, 0x06DF
     c60:	90 90 e0 06 	lds	r9, 0x06E0
     c64:	a0 90 e1 06 	lds	r10, 0x06E1
     c68:	b0 90 e2 06 	lds	r11, 0x06E2
    dir_Structure *dir;
    uint16_t i;
    uint8_t j;


    returnStatus = convertFileName (filePtr->fileName); //convert fileName into FAT format
     c6c:	7b 01       	movw	r14, r22
     c6e:	2e ec       	ldi	r18, 0xCE	; 206
     c70:	e2 1a       	sub	r14, r18
     c72:	2d ef       	ldi	r18, 0xFD	; 253
     c74:	f2 0a       	sbc	r15, r18
     c76:	c7 01       	movw	r24, r14
     c78:	61 df       	rcall	.-318    	; 0xb3c <convertFileName>

    if(returnStatus == FAT32_INVALID_FLIE_NAME)
     c7a:	84 30       	cpi	r24, 0x04	; 4
     c7c:	09 f4       	brne	.+2      	; 0xc80 <openFile+0x5e>
     c7e:	e9 c0       	rjmp	.+466    	; 0xe52 <openFile+0x230>
        {
            firstSector = getFirstSector (cluster);

            for(sector = 0; ((sector < sectorPerCluster) && (returnStatus == CONTINUE_LOOP)); sector++)
            {
                SD_readSingleBlock (filePtr->fileBuffer,firstSector + sector);
     c80:	2e 84       	ldd	r2, Y+14	; 0x0e
     c82:	3f 84       	ldd	r3, Y+15	; 0x0f
     c84:	4c e2       	ldi	r20, 0x2C	; 44
     c86:	24 0e       	add	r2, r20
     c88:	31 1c       	adc	r3, r1
     c8a:	ea 86       	std	Y+10, r14	; 0x0a
     c8c:	fb 86       	std	Y+11, r15	; 0x0b
     c8e:	8e 85       	ldd	r24, Y+14	; 0x0e
     c90:	9f 85       	ldd	r25, Y+15	; 0x0f
     c92:	83 5c       	subi	r24, 0xC3	; 195
     c94:	9d 4f       	sbci	r25, 0xFD	; 253
     c96:	99 87       	std	Y+9, r25	; 0x09
     c98:	88 87       	std	Y+8, r24	; 0x08

        returnStatus = CONTINUE_LOOP;

        do
        {
            firstSector = getFirstSector (cluster);
     c9a:	c5 01       	movw	r24, r10
     c9c:	b4 01       	movw	r22, r8
     c9e:	57 da       	rcall	.-2898   	; 0x14e <getFirstSector>
     ca0:	6b 83       	std	Y+3, r22	; 0x03
     ca2:	7c 83       	std	Y+4, r23	; 0x04
     ca4:	8d 83       	std	Y+5, r24	; 0x05
     ca6:	9e 83       	std	Y+6, r25	; 0x06

            for(sector = 0; ((sector < sectorPerCluster) && (returnStatus == CONTINUE_LOOP)); sector++)
     ca8:	41 2c       	mov	r4, r1
     caa:	51 2c       	mov	r5, r1
     cac:	32 01       	movw	r6, r4
     cae:	15 e5       	ldi	r17, 0x55	; 85
     cb0:	80 91 e3 06 	lds	r24, 0x06E3
     cb4:	90 91 e4 06 	lds	r25, 0x06E4
     cb8:	a0 e0       	ldi	r26, 0x00	; 0
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	48 16       	cp	r4, r24
     cbe:	59 06       	cpc	r5, r25
     cc0:	6a 06       	cpc	r6, r26
     cc2:	7b 06       	cpc	r7, r27
     cc4:	08 f0       	brcs	.+2      	; 0xcc8 <openFile+0xa6>
     cc6:	7f c0       	rjmp	.+254    	; 0xdc6 <openFile+0x1a4>
     cc8:	15 35       	cpi	r17, 0x55	; 85
     cca:	09 f0       	breq	.+2      	; 0xcce <openFile+0xac>
     ccc:	95 c0       	rjmp	.+298    	; 0xdf8 <openFile+0x1d6>
            {
                SD_readSingleBlock (filePtr->fileBuffer,firstSector + sector);
     cce:	cb 80       	ldd	r12, Y+3	; 0x03
     cd0:	dc 80       	ldd	r13, Y+4	; 0x04
     cd2:	ed 80       	ldd	r14, Y+5	; 0x05
     cd4:	fe 80       	ldd	r15, Y+6	; 0x06
     cd6:	c4 0c       	add	r12, r4
     cd8:	d5 1c       	adc	r13, r5
     cda:	e6 1c       	adc	r14, r6
     cdc:	f7 1c       	adc	r15, r7
     cde:	b7 01       	movw	r22, r14
     ce0:	a6 01       	movw	r20, r12
     ce2:	c1 01       	movw	r24, r2
     ce4:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <SD_readSingleBlock>


                for(i=0; ((i<bytesPerSector) && (returnStatus == CONTINUE_LOOP)); i+=32)
     ce8:	60 91 d9 04 	lds	r22, 0x04D9
     cec:	70 91 da 04 	lds	r23, 0x04DA
     cf0:	f1 01       	movw	r30, r2
     cf2:	20 e0       	ldi	r18, 0x00	; 0
     cf4:	30 e0       	ldi	r19, 0x00	; 0
     cf6:	26 17       	cp	r18, r22
     cf8:	37 07       	cpc	r19, r23
     cfa:	08 f0       	brcs	.+2      	; 0xcfe <openFile+0xdc>
     cfc:	5e c0       	rjmp	.+188    	; 0xdba <openFile+0x198>
                {
                    dir = (dir_Structure *) &filePtr->fileBuffer[i];
     cfe:	fa 83       	std	Y+2, r31	; 0x02
     d00:	e9 83       	std	Y+1, r30	; 0x01

                    if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
     d02:	80 81       	ld	r24, Z
     d04:	88 23       	and	r24, r24
     d06:	09 f4       	brne	.+2      	; 0xd0a <openFile+0xe8>
     d08:	57 c0       	rjmp	.+174    	; 0xdb8 <openFile+0x196>
                    {
                        print_DebugMsg("File does not exist!");
                        returnStatus = FAT32_FILE_DELETED_OR_NOT_FOUND;
                        break;
                    }
                    if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
     d0a:	85 3e       	cpi	r24, 0xE5	; 229
     d0c:	09 f4       	brne	.+2      	; 0xd10 <openFile+0xee>
     d0e:	50 c0       	rjmp	.+160    	; 0xdb0 <openFile+0x18e>
     d10:	ae 85       	ldd	r26, Y+14	; 0x0e
     d12:	bf 85       	ldd	r27, Y+15	; 0x0f
     d14:	a2 0f       	add	r26, r18
     d16:	b3 1f       	adc	r27, r19
     d18:	d7 96       	adiw	r26, 0x37	; 55
     d1a:	8c 91       	ld	r24, X
     d1c:	8f 30       	cpi	r24, 0x0F	; 15
     d1e:	09 f4       	brne	.+2      	; 0xd22 <openFile+0x100>
     d20:	47 c0       	rjmp	.+142    	; 0xdb0 <openFile+0x18e>
     d22:	9a 85       	ldd	r25, Y+10	; 0x0a
     d24:	9c 87       	std	Y+12, r25	; 0x0c
     d26:	ab 85       	ldd	r26, Y+11	; 0x0b
     d28:	ad 87       	std	Y+13, r26	; 0x0d
     d2a:	cf 01       	movw	r24, r30
                    {
                        for(j=0; j<11; j++)
                        {
                            if(dir->name[j] != filePtr->fileName[j])
     d2c:	dc 01       	movw	r26, r24
     d2e:	5d 91       	ld	r21, X+
     d30:	cd 01       	movw	r24, r26
     d32:	ac 85       	ldd	r26, Y+12	; 0x0c
     d34:	bd 85       	ldd	r27, Y+13	; 0x0d
     d36:	4d 91       	ld	r20, X+
     d38:	bd 87       	std	Y+13, r27	; 0x0d
     d3a:	ac 87       	std	Y+12, r26	; 0x0c
     d3c:	54 13       	cpse	r21, r20
     d3e:	38 c0       	rjmp	.+112    	; 0xdb0 <openFile+0x18e>
                        returnStatus = FAT32_FILE_DELETED_OR_NOT_FOUND;
                        break;
                    }
                    if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
                    {
                        for(j=0; j<11; j++)
     d40:	48 85       	ldd	r20, Y+8	; 0x08
     d42:	59 85       	ldd	r21, Y+9	; 0x09
     d44:	a4 17       	cp	r26, r20
     d46:	b5 07       	cpc	r27, r21
     d48:	89 f7       	brne	.-30     	; 0xd2c <openFile+0x10a>
                            if(dir->name[j] != filePtr->fileName[j])
                                break;
                        }
                        if(j == 11)
                        {
                            filePtr->appendFileSector = firstSector + sector;
     d4a:	ae 85       	ldd	r26, Y+14	; 0x0e
     d4c:	bf 85       	ldd	r27, Y+15	; 0x0f
     d4e:	1c 96       	adiw	r26, 0x0c	; 12
     d50:	cd 92       	st	X+, r12
     d52:	dd 92       	st	X+, r13
     d54:	ed 92       	st	X+, r14
     d56:	fc 92       	st	X, r15
     d58:	1f 97       	sbiw	r26, 0x0f	; 15
                            filePtr->appendFileLocation = i;
     d5a:	40 e0       	ldi	r20, 0x00	; 0
     d5c:	50 e0       	ldi	r21, 0x00	; 0
     d5e:	50 96       	adiw	r26, 0x10	; 16
     d60:	2d 93       	st	X+, r18
     d62:	3d 93       	st	X+, r19
     d64:	4d 93       	st	X+, r20
     d66:	5c 93       	st	X, r21
     d68:	53 97       	sbiw	r26, 0x13	; 19
                            filePtr->appendStartCluster = (((uint32_t) dir->firstClusterHI) << 16) | dir->firstClusterLO;
     d6a:	44 89       	ldd	r20, Z+20	; 0x14
     d6c:	55 89       	ldd	r21, Z+21	; 0x15
     d6e:	60 e0       	ldi	r22, 0x00	; 0
     d70:	70 e0       	ldi	r23, 0x00	; 0
     d72:	ba 01       	movw	r22, r20
     d74:	55 27       	eor	r21, r21
     d76:	44 27       	eor	r20, r20
     d78:	82 8d       	ldd	r24, Z+26	; 0x1a
     d7a:	93 8d       	ldd	r25, Z+27	; 0x1b
     d7c:	a0 e0       	ldi	r26, 0x00	; 0
     d7e:	b0 e0       	ldi	r27, 0x00	; 0
     d80:	48 2b       	or	r20, r24
     d82:	59 2b       	or	r21, r25
     d84:	6a 2b       	or	r22, r26
     d86:	7b 2b       	or	r23, r27
     d88:	ae 85       	ldd	r26, Y+14	; 0x0e
     d8a:	bf 85       	ldd	r27, Y+15	; 0x0f
     d8c:	90 96       	adiw	r26, 0x20	; 32
     d8e:	4d 93       	st	X+, r20
     d90:	5d 93       	st	X+, r21
     d92:	6d 93       	st	X+, r22
     d94:	7c 93       	st	X, r23
     d96:	93 97       	sbiw	r26, 0x23	; 35
                            filePtr->fileSize = dir->fileSize;
     d98:	84 8d       	ldd	r24, Z+28	; 0x1c
     d9a:	95 8d       	ldd	r25, Z+29	; 0x1d
     d9c:	a6 8d       	ldd	r26, Z+30	; 0x1e
     d9e:	b7 8d       	ldd	r27, Z+31	; 0x1f
     da0:	ee 85       	ldd	r30, Y+14	; 0x0e
     da2:	ff 85       	ldd	r31, Y+15	; 0x0f
     da4:	84 8b       	std	Z+20, r24	; 0x14
     da6:	95 8b       	std	Z+21, r25	; 0x15
     da8:	a6 8b       	std	Z+22, r26	; 0x16
     daa:	b7 8b       	std	Z+23, r27	; 0x17
                            returnStatus = FAT32_FILE_OPEN_SUCCESSFUL;
     dac:	10 e0       	ldi	r17, 0x00	; 0
                            break;
     dae:	05 c0       	rjmp	.+10     	; 0xdba <openFile+0x198>
            for(sector = 0; ((sector < sectorPerCluster) && (returnStatus == CONTINUE_LOOP)); sector++)
            {
                SD_readSingleBlock (filePtr->fileBuffer,firstSector + sector);


                for(i=0; ((i<bytesPerSector) && (returnStatus == CONTINUE_LOOP)); i+=32)
     db0:	20 5e       	subi	r18, 0xE0	; 224
     db2:	3f 4f       	sbci	r19, 0xFF	; 255
     db4:	b0 96       	adiw	r30, 0x20	; 32
     db6:	9f cf       	rjmp	.-194    	; 0xcf6 <openFile+0xd4>
                    dir = (dir_Structure *) &filePtr->fileBuffer[i];

                    if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
                    {
                        print_DebugMsg("File does not exist!");
                        returnStatus = FAT32_FILE_DELETED_OR_NOT_FOUND;
     db8:	11 e0       	ldi	r17, 0x01	; 1

        do
        {
            firstSector = getFirstSector (cluster);

            for(sector = 0; ((sector < sectorPerCluster) && (returnStatus == CONTINUE_LOOP)); sector++)
     dba:	ff ef       	ldi	r31, 0xFF	; 255
     dbc:	4f 1a       	sub	r4, r31
     dbe:	5f 0a       	sbc	r5, r31
     dc0:	6f 0a       	sbc	r6, r31
     dc2:	7f 0a       	sbc	r7, r31
     dc4:	75 cf       	rjmp	.-278    	; 0xcb0 <openFile+0x8e>
                        }
                    }
                }
            }

            if(returnStatus == CONTINUE_LOOP)
     dc6:	15 35       	cpi	r17, 0x55	; 85
     dc8:	b9 f4       	brne	.+46     	; 0xdf8 <openFile+0x1d6>
            {
                cluster = (getSetNextCluster (filePtr->fileBuffer,cluster, GET, 0));
     dca:	e1 2c       	mov	r14, r1
     dcc:	f1 2c       	mov	r15, r1
     dce:	87 01       	movw	r16, r14
     dd0:	20 e0       	ldi	r18, 0x00	; 0
     dd2:	b5 01       	movw	r22, r10
     dd4:	a4 01       	movw	r20, r8
     dd6:	c1 01       	movw	r24, r2
     dd8:	d7 d9       	rcall	.-3154   	; 0x188 <getSetNextCluster>
     dda:	4b 01       	movw	r8, r22
     ddc:	5c 01       	movw	r10, r24

                if((cluster > 0x0ffffff6) || (cluster == 0))
     dde:	dc 01       	movw	r26, r24
     de0:	cb 01       	movw	r24, r22
     de2:	01 97       	sbiw	r24, 0x01	; 1
     de4:	a1 09       	sbc	r26, r1
     de6:	b1 09       	sbc	r27, r1
     de8:	86 3f       	cpi	r24, 0xF6	; 246
     dea:	9f 4f       	sbci	r25, 0xFF	; 255
     dec:	af 4f       	sbci	r26, 0xFF	; 255
     dee:	bf 40       	sbci	r27, 0x0F	; 15
     df0:	08 f4       	brcc	.+2      	; 0xdf4 <openFile+0x1d2>
     df2:	53 cf       	rjmp	.-346    	; 0xc9a <openFile+0x78>
                {
                    print_DebugMsg("Error in getting cluster");
                    returnStatus = FAT32_NO_FREE_CLUSTERS_FOUND;
     df4:	85 e0       	ldi	r24, 0x05	; 5
     df6:	2d c0       	rjmp	.+90     	; 0xe52 <openFile+0x230>
     df8:	81 2f       	mov	r24, r17
                }
            }
        }while(returnStatus == CONTINUE_LOOP);


        if((returnStatus == FAT32_FILE_OPEN_SUCCESSFUL) && (fileOperation == READ ))
     dfa:	11 11       	cpse	r17, r1
     dfc:	29 c0       	rjmp	.+82     	; 0xe50 <openFile+0x22e>
     dfe:	4f 81       	ldd	r20, Y+7	; 0x07
     e00:	41 11       	cpse	r20, r1
     e02:	27 c0       	rjmp	.+78     	; 0xe52 <openFile+0x230>
        {
            filePtr->cluster = (((uint32_t) dir->firstClusterHI) << 16) | dir->firstClusterLO;
     e04:	a9 81       	ldd	r26, Y+1	; 0x01
     e06:	ba 81       	ldd	r27, Y+2	; 0x02
     e08:	54 96       	adiw	r26, 0x14	; 20
     e0a:	4d 91       	ld	r20, X+
     e0c:	5c 91       	ld	r21, X
     e0e:	55 97       	sbiw	r26, 0x15	; 21
     e10:	60 e0       	ldi	r22, 0x00	; 0
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	ba 01       	movw	r22, r20
     e16:	55 27       	eor	r21, r21
     e18:	44 27       	eor	r20, r20
     e1a:	5a 96       	adiw	r26, 0x1a	; 26
     e1c:	cd 90       	ld	r12, X+
     e1e:	dc 90       	ld	r13, X
     e20:	5b 97       	sbiw	r26, 0x1b	; 27
     e22:	e1 2c       	mov	r14, r1
     e24:	f1 2c       	mov	r15, r1
     e26:	4c 29       	or	r20, r12
     e28:	5d 29       	or	r21, r13
     e2a:	6e 29       	or	r22, r14
     e2c:	7f 29       	or	r23, r15
     e2e:	ee 85       	ldd	r30, Y+14	; 0x0e
     e30:	ff 85       	ldd	r31, Y+15	; 0x0f
     e32:	44 83       	std	Z+4, r20	; 0x04
     e34:	55 83       	std	Z+5, r21	; 0x05
     e36:	66 83       	std	Z+6, r22	; 0x06
     e38:	77 83       	std	Z+7, r23	; 0x07

            filePtr->fileSize = dir->fileSize;
     e3a:	5c 96       	adiw	r26, 0x1c	; 28
     e3c:	4d 91       	ld	r20, X+
     e3e:	5d 91       	ld	r21, X+
     e40:	6d 91       	ld	r22, X+
     e42:	7c 91       	ld	r23, X
     e44:	5f 97       	sbiw	r26, 0x1f	; 31
     e46:	44 8b       	std	Z+20, r20	; 0x14
     e48:	55 8b       	std	Z+21, r21	; 0x15
     e4a:	66 8b       	std	Z+22, r22	; 0x16
     e4c:	77 8b       	std	Z+23, r23	; 0x17
     e4e:	01 c0       	rjmp	.+2      	; 0xe52 <openFile+0x230>
     e50:	81 2f       	mov	r24, r17
        }
    }


    return returnStatus;
}
     e52:	2f 96       	adiw	r28, 0x0f	; 15
     e54:	0f b6       	in	r0, 0x3f	; 63
     e56:	f8 94       	cli
     e58:	de bf       	out	0x3e, r29	; 62
     e5a:	0f be       	out	0x3f, r0	; 63
     e5c:	cd bf       	out	0x3d, r28	; 61
     e5e:	df 91       	pop	r29
     e60:	cf 91       	pop	r28
     e62:	1f 91       	pop	r17
     e64:	0f 91       	pop	r16
     e66:	ff 90       	pop	r15
     e68:	ef 90       	pop	r14
     e6a:	df 90       	pop	r13
     e6c:	cf 90       	pop	r12
     e6e:	bf 90       	pop	r11
     e70:	af 90       	pop	r10
     e72:	9f 90       	pop	r9
     e74:	8f 90       	pop	r8
     e76:	7f 90       	pop	r7
     e78:	6f 90       	pop	r6
     e7a:	5f 90       	pop	r5
     e7c:	4f 90       	pop	r4
     e7e:	3f 90       	pop	r3
     e80:	2f 90       	pop	r2
     e82:	08 95       	ret

00000e84 <FILE_Open>:
                 This functions opens the file with requested mode(Read/Write). 
                 If the file is successfully opened, it returns the pointer to file structure.
                 In case the file is not opened it returns NULL, fileOpenSts contains the failure cause.
 ******************************************************************************************************************/
fileConfig_st* FILE_Open(char* filename,uint8_t fileOperation,uint8_t *fileOpenSts)
{
     e84:	2f 92       	push	r2
     e86:	3f 92       	push	r3
     e88:	4f 92       	push	r4
     e8a:	5f 92       	push	r5
     e8c:	6f 92       	push	r6
     e8e:	7f 92       	push	r7
     e90:	8f 92       	push	r8
     e92:	9f 92       	push	r9
     e94:	af 92       	push	r10
     e96:	bf 92       	push	r11
     e98:	cf 92       	push	r12
     e9a:	df 92       	push	r13
     e9c:	ef 92       	push	r14
     e9e:	ff 92       	push	r15
     ea0:	0f 93       	push	r16
     ea2:	1f 93       	push	r17
     ea4:	cf 93       	push	r28
     ea6:	df 93       	push	r29
     ea8:	00 d0       	rcall	.+0      	; 0xeaa <FILE_Open+0x26>
     eaa:	00 d0       	rcall	.+0      	; 0xeac <FILE_Open+0x28>
     eac:	00 d0       	rcall	.+0      	; 0xeae <FILE_Open+0x2a>
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	28 e1       	ldi	r18, 0x18	; 24
     eb4:	a2 2e       	mov	r10, r18
     eb6:	29 e0       	ldi	r18, 0x09	; 9
     eb8:	b2 2e       	mov	r11, r18
     eba:	2b ee       	ldi	r18, 0xEB	; 235
     ebc:	36 e0       	ldi	r19, 0x06	; 6
     ebe:	3e 83       	std	Y+6, r19	; 0x06
     ec0:	2d 83       	std	Y+5, r18	; 0x05
     ec2:	3f ef       	ldi	r19, 0xFF	; 255
     ec4:	c3 2e       	mov	r12, r19
     ec6:	36 e0       	ldi	r19, 0x06	; 6
     ec8:	d3 2e       	mov	r13, r19
    uint8_t i,freeLocationDetected = FALSE;
    uint32_t nextCluster, clusterCount;

    for(i=0;((i< C_MaxFilesOpening_U8) && (freeLocationDetected == FALSE));i++)
    {
        if(fatMappingTable[i].fileOpenedFlag == FALSE)
     eca:	d5 01       	movw	r26, r10
     ecc:	2c 91       	ld	r18, X
     ece:	21 11       	cpse	r18, r1
     ed0:	7e c1       	rjmp	.+764    	; 0x11ce <__stack+0xcf>
     ed2:	3a 01       	movw	r6, r20
     ed4:	96 2e       	mov	r9, r22
     ed6:	bc 01       	movw	r22, r24
        {
            freeLocationDetected = TRUE;

            filePtr = &fatMappingTable[i];
     ed8:	3d 80       	ldd	r3, Y+5	; 0x05
     eda:	2e 80       	ldd	r2, Y+6	; 0x06
            filePtr->fileOpenedFlag = TRUE;
     edc:	11 e0       	ldi	r17, 0x01	; 1
     ede:	1c 93       	st	X, r17
            strcpy(filePtr->fileName,filename);
     ee0:	8d 81       	ldd	r24, Y+5	; 0x05
     ee2:	9e 81       	ldd	r25, Y+6	; 0x06
     ee4:	8e 5c       	subi	r24, 0xCE	; 206
     ee6:	9d 4f       	sbci	r25, 0xFD	; 253
     ee8:	0e 94 c5 14 	call	0x298a	; 0x298a <strcpy>
     eec:	ed 81       	ldd	r30, Y+5	; 0x05
     eee:	fe 81       	ldd	r31, Y+6	; 0x06
     ef0:	e4 5d       	subi	r30, 0xD4	; 212
     ef2:	fd 4f       	sbci	r31, 0xFD	; 253
            filePtr->fileOperation_u8 = fileOperation;
     ef4:	90 82       	st	Z, r9
            filePtr->firstSector= 0x00;
     ef6:	ed 81       	ldd	r30, Y+5	; 0x05
     ef8:	fe 81       	ldd	r31, Y+6	; 0x06
     efa:	10 82       	st	Z, r1
     efc:	11 82       	std	Z+1, r1	; 0x01
     efe:	12 82       	std	Z+2, r1	; 0x02
     f00:	13 82       	std	Z+3, r1	; 0x03
            filePtr->cluster= 0x00;
     f02:	14 82       	std	Z+4, r1	; 0x04
     f04:	15 82       	std	Z+5, r1	; 0x05
     f06:	16 82       	std	Z+6, r1	; 0x06
     f08:	17 82       	std	Z+7, r1	; 0x07
            filePtr->blockNumber_u32 = 0x00;
     f0a:	14 8e       	std	Z+28, r1	; 0x1c
     f0c:	15 8e       	std	Z+29, r1	; 0x1d
     f0e:	16 8e       	std	Z+30, r1	; 0x1e
     f10:	17 8e       	std	Z+31, r1	; 0x1f
            filePtr->appendFileSector= 0x00;
     f12:	14 86       	std	Z+12, r1	; 0x0c
     f14:	15 86       	std	Z+13, r1	; 0x0d
     f16:	16 86       	std	Z+14, r1	; 0x0e
     f18:	17 86       	std	Z+15, r1	; 0x0f
            filePtr->appendFileLocation= 0x00;
     f1a:	10 8a       	std	Z+16, r1	; 0x10
     f1c:	11 8a       	std	Z+17, r1	; 0x11
     f1e:	12 8a       	std	Z+18, r1	; 0x12
     f20:	13 8a       	std	Z+19, r1	; 0x13
            filePtr->fileSize= 0x00;
     f22:	d6 01       	movw	r26, r12
     f24:	1d 92       	st	X+, r1
     f26:	1d 92       	st	X+, r1
     f28:	1d 92       	st	X+, r1
     f2a:	1c 92       	st	X, r1
     f2c:	13 97       	sbiw	r26, 0x03	; 3
            filePtr->byteCounter= 0x00;
     f2e:	10 8e       	std	Z+24, r1	; 0x18
     f30:	11 8e       	std	Z+25, r1	; 0x19
     f32:	12 8e       	std	Z+26, r1	; 0x1a
     f34:	13 8e       	std	Z+27, r1	; 0x1b
            filePtr->appendStartCluster= 0x00;
     f36:	1c 96       	adiw	r26, 0x0c	; 12
     f38:	1d 92       	st	X+, r1
     f3a:	1d 92       	st	X+, r1
     f3c:	1d 92       	st	X+, r1
     f3e:	1c 92       	st	X, r1
     f40:	1f 97       	sbiw	r26, 0x0f	; 15
            filePtr->sectorIndex= 0x00;
     f42:	51 96       	adiw	r26, 0x11	; 17
     f44:	1c 92       	st	X, r1
     f46:	1e 92       	st	-X, r1
     f48:	50 97       	sbiw	r26, 0x10	; 16
            filePtr->bufferIndex_u16= 0x00;
     f4a:	53 96       	adiw	r26, 0x13	; 19
     f4c:	1c 92       	st	X, r1
     f4e:	1e 92       	st	-X, r1
     f50:	52 97       	sbiw	r26, 0x12	; 18
     f52:	e2 5d       	subi	r30, 0xD2	; 210
     f54:	fd 4f       	sbci	r31, 0xFD	; 253

            filePtr->fileCreatedFlag = 0x00;
     f56:	10 82       	st	Z, r1
     f58:	ed 81       	ldd	r30, Y+5	; 0x05
     f5a:	fe 81       	ldd	r31, Y+6	; 0x06
     f5c:	ef 5c       	subi	r30, 0xCF	; 207
     f5e:	fd 4f       	sbci	r31, 0xFD	; 253
            filePtr->endOfFileDetected = 0x00;
     f60:	10 82       	st	Z, r1

            if(fileOperation == READ)
     f62:	91 10       	cpse	r9, r1
     f64:	0a c0       	rjmp	.+20     	; 0xf7a <FILE_Open+0xf6>
            {
                *fileOpenSts = openFile( READ, filePtr);
     f66:	6d 81       	ldd	r22, Y+5	; 0x05
     f68:	7e 81       	ldd	r23, Y+6	; 0x06
     f6a:	80 e0       	ldi	r24, 0x00	; 0
     f6c:	5a de       	rcall	.-844    	; 0xc22 <openFile>
     f6e:	f3 01       	movw	r30, r6
     f70:	80 83       	st	Z, r24
                if(*fileOpenSts != FAT32_FILE_OPEN_SUCCESSFUL)
     f72:	88 23       	and	r24, r24
     f74:	09 f4       	brne	.+2      	; 0xf78 <FILE_Open+0xf4>
     f76:	1e c1       	rjmp	.+572    	; 0x11b4 <__stack+0xb5>
     f78:	27 c1       	rjmp	.+590    	; 0x11c8 <__stack+0xc9>

                    print_DebugMsg("FILE_DELETED_OR_NOT_FOUND");
                    return  0; /* Set the pointer to NULL indication File not found or Read failed, */
                }
            }
            else if((fileOperation == WRITE) || (fileOperation == APPEND))
     f7a:	6e ef       	ldi	r22, 0xFE	; 254
     f7c:	69 0d       	add	r22, r9
     f7e:	62 30       	cpi	r22, 0x02	; 2
     f80:	08 f0       	brcs	.+2      	; 0xf84 <FILE_Open+0x100>
     f82:	18 c1       	rjmp	.+560    	; 0x11b4 <__stack+0xb5>
            {
                *fileOpenSts = openFile (VERIFY, filePtr);
     f84:	6d 81       	ldd	r22, Y+5	; 0x05
     f86:	7e 81       	ldd	r23, Y+6	; 0x06
     f88:	81 e0       	ldi	r24, 0x01	; 1
     f8a:	4b de       	rcall	.-874    	; 0xc22 <openFile>
     f8c:	d3 01       	movw	r26, r6
     f8e:	8c 93       	st	X, r24

                if(*fileOpenSts == FAT32_FILE_OPEN_SUCCESSFUL)
     f90:	81 11       	cpse	r24, r1
     f92:	96 c0       	rjmp	.+300    	; 0x10c0 <FILE_Open+0x23c>
     f94:	ed 81       	ldd	r30, Y+5	; 0x05
     f96:	fe 81       	ldd	r31, Y+6	; 0x06
     f98:	e1 5d       	subi	r30, 0xD1	; 209
     f9a:	fd 4f       	sbci	r31, 0xFD	; 253
                {
                    print_DebugMsg("File already existing, appending data..");

                    filePtr->appendFileFlag = 1;
     f9c:	10 83       	st	Z, r17
                    filePtr->cluster = filePtr->appendStartCluster;
     f9e:	f6 01       	movw	r30, r12
     fa0:	84 85       	ldd	r24, Z+12	; 0x0c
     fa2:	95 85       	ldd	r25, Z+13	; 0x0d
     fa4:	a6 85       	ldd	r26, Z+14	; 0x0e
     fa6:	b7 85       	ldd	r27, Z+15	; 0x0f
     fa8:	ed 81       	ldd	r30, Y+5	; 0x05
     faa:	fe 81       	ldd	r31, Y+6	; 0x06
     fac:	84 83       	std	Z+4, r24	; 0x04
     fae:	95 83       	std	Z+5, r25	; 0x05
     fb0:	a6 83       	std	Z+6, r26	; 0x06
     fb2:	b7 83       	std	Z+7, r27	; 0x07
                    clusterCount=0;
     fb4:	41 2c       	mov	r4, r1
     fb6:	51 2c       	mov	r5, r1
     fb8:	32 01       	movw	r6, r4
     fba:	4f 01       	movw	r8, r30
     fbc:	fc e2       	ldi	r31, 0x2C	; 44
     fbe:	8f 0e       	add	r8, r31
     fc0:	91 1c       	adc	r9, r1
                    while(1)
                    {
                        nextCluster = getSetNextCluster (filePtr->fileBuffer,filePtr->cluster, GET, 0);
     fc2:	ad 81       	ldd	r26, Y+5	; 0x05
     fc4:	be 81       	ldd	r27, Y+6	; 0x06
     fc6:	14 96       	adiw	r26, 0x04	; 4
     fc8:	4d 91       	ld	r20, X+
     fca:	5d 91       	ld	r21, X+
     fcc:	6d 91       	ld	r22, X+
     fce:	7c 91       	ld	r23, X
     fd0:	17 97       	sbiw	r26, 0x07	; 7
     fd2:	e1 2c       	mov	r14, r1
     fd4:	f1 2c       	mov	r15, r1
     fd6:	87 01       	movw	r16, r14
     fd8:	20 e0       	ldi	r18, 0x00	; 0
     fda:	c4 01       	movw	r24, r8
     fdc:	d5 d8       	rcall	.-3670   	; 0x188 <getSetNextCluster>
                        if(nextCluster == END_OF_CLUSTERS) break;
     fde:	6f 3f       	cpi	r22, 0xFF	; 255
     fe0:	bf ef       	ldi	r27, 0xFF	; 255
     fe2:	7b 07       	cpc	r23, r27
     fe4:	8b 07       	cpc	r24, r27
     fe6:	bf e0       	ldi	r27, 0x0F	; 15
     fe8:	9b 07       	cpc	r25, r27
     fea:	61 f0       	breq	.+24     	; 0x1004 <FILE_Open+0x180>
                        filePtr->cluster = nextCluster;
     fec:	ed 81       	ldd	r30, Y+5	; 0x05
     fee:	fe 81       	ldd	r31, Y+6	; 0x06
     ff0:	64 83       	std	Z+4, r22	; 0x04
     ff2:	75 83       	std	Z+5, r23	; 0x05
     ff4:	86 83       	std	Z+6, r24	; 0x06
     ff6:	97 83       	std	Z+7, r25	; 0x07
                        clusterCount++;
     ff8:	ff ef       	ldi	r31, 0xFF	; 255
     ffa:	4f 1a       	sub	r4, r31
     ffc:	5f 0a       	sbc	r5, r31
     ffe:	6f 0a       	sbc	r6, r31
    1000:	7f 0a       	sbc	r7, r31
                    }
    1002:	df cf       	rjmp	.-66     	; 0xfc2 <FILE_Open+0x13e>

                    filePtr->sectorIndex = (filePtr->fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector;
    1004:	a0 91 e3 06 	lds	r26, 0x06E3
    1008:	b0 91 e4 06 	lds	r27, 0x06E4
    100c:	e0 91 d9 04 	lds	r30, 0x04D9
    1010:	f0 91 da 04 	lds	r31, 0x04DA
    1014:	9f 01       	movw	r18, r30
    1016:	0e 94 9d 14 	call	0x293a	; 0x293a <__umulhisi3>
    101a:	9b 01       	movw	r18, r22
    101c:	ac 01       	movw	r20, r24
    101e:	c3 01       	movw	r24, r6
    1020:	b2 01       	movw	r22, r4
    1022:	0e 94 63 14 	call	0x28c6	; 0x28c6 <__mulsi3>
    1026:	d6 01       	movw	r26, r12
    1028:	0d 91       	ld	r16, X+
    102a:	1d 91       	ld	r17, X+
    102c:	2d 91       	ld	r18, X+
    102e:	3c 91       	ld	r19, X
    1030:	28 01       	movw	r4, r16
    1032:	39 01       	movw	r6, r18
    1034:	46 1a       	sub	r4, r22
    1036:	57 0a       	sbc	r5, r23
    1038:	68 0a       	sbc	r6, r24
    103a:	79 0a       	sbc	r7, r25
    103c:	c3 01       	movw	r24, r6
    103e:	b2 01       	movw	r22, r4
    1040:	9f 01       	movw	r18, r30
    1042:	40 e0       	ldi	r20, 0x00	; 0
    1044:	50 e0       	ldi	r21, 0x00	; 0
    1046:	0e 94 72 14 	call	0x28e4	; 0x28e4 <__udivmodsi4>
    104a:	d6 01       	movw	r26, r12
    104c:	51 96       	adiw	r26, 0x11	; 17
    104e:	3c 93       	st	X, r19
    1050:	2e 93       	st	-X, r18
    1052:	50 97       	sbiw	r26, 0x10	; 16

                    filePtr->blockNumber_u32 = getFirstSector (filePtr->cluster) + filePtr->sectorIndex;
    1054:	ed 81       	ldd	r30, Y+5	; 0x05
    1056:	fe 81       	ldd	r31, Y+6	; 0x06
    1058:	64 81       	ldd	r22, Z+4	; 0x04
    105a:	75 81       	ldd	r23, Z+5	; 0x05
    105c:	86 81       	ldd	r24, Z+6	; 0x06
    105e:	97 81       	ldd	r25, Z+7	; 0x07
    1060:	29 83       	std	Y+1, r18	; 0x01
    1062:	3a 83       	std	Y+2, r19	; 0x02
    1064:	4b 83       	std	Y+3, r20	; 0x03
    1066:	5c 83       	std	Y+4, r21	; 0x04
    1068:	72 d8       	rcall	.-3868   	; 0x14e <getFirstSector>
    106a:	29 81       	ldd	r18, Y+1	; 0x01
    106c:	3a 81       	ldd	r19, Y+2	; 0x02
    106e:	4b 81       	ldd	r20, Y+3	; 0x03
    1070:	5c 81       	ldd	r21, Y+4	; 0x04
    1072:	89 01       	movw	r16, r18
    1074:	9a 01       	movw	r18, r20
    1076:	22 27       	eor	r18, r18
    1078:	33 27       	eor	r19, r19
    107a:	ab 01       	movw	r20, r22
    107c:	bc 01       	movw	r22, r24
    107e:	40 0f       	add	r20, r16
    1080:	51 1f       	adc	r21, r17
    1082:	62 1f       	adc	r22, r18
    1084:	73 1f       	adc	r23, r19
    1086:	ad 81       	ldd	r26, Y+5	; 0x05
    1088:	be 81       	ldd	r27, Y+6	; 0x06
    108a:	5c 96       	adiw	r26, 0x1c	; 28
    108c:	4d 93       	st	X+, r20
    108e:	5d 93       	st	X+, r21
    1090:	6d 93       	st	X+, r22
    1092:	7c 93       	st	X, r23
    1094:	5f 97       	sbiw	r26, 0x1f	; 31
                    SD_readSingleBlock (filePtr->fileBuffer,filePtr->blockNumber_u32);
    1096:	c4 01       	movw	r24, r8
    1098:	bb d6       	rcall	.+3446   	; 0x1e10 <SD_readSingleBlock>
                    filePtr->bufferIndex_u16 = filePtr->fileSize % bytesPerSector;
    109a:	20 91 d9 04 	lds	r18, 0x04D9
    109e:	30 91 da 04 	lds	r19, 0x04DA
    10a2:	40 e0       	ldi	r20, 0x00	; 0
    10a4:	50 e0       	ldi	r21, 0x00	; 0
    10a6:	f6 01       	movw	r30, r12
    10a8:	60 81       	ld	r22, Z
    10aa:	71 81       	ldd	r23, Z+1	; 0x01
    10ac:	82 81       	ldd	r24, Z+2	; 0x02
    10ae:	93 81       	ldd	r25, Z+3	; 0x03
    10b0:	0e 94 72 14 	call	0x28e4	; 0x28e4 <__udivmodsi4>
    10b4:	d6 01       	movw	r26, r12
    10b6:	53 96       	adiw	r26, 0x13	; 19
    10b8:	7c 93       	st	X, r23
    10ba:	6e 93       	st	-X, r22
    10bc:	52 97       	sbiw	r26, 0x12	; 18
    10be:	7a c0       	rjmp	.+244    	; 0x11b4 <__stack+0xb5>
                }
                else if(*fileOpenSts == FAT32_FILE_DELETED_OR_NOT_FOUND)
    10c0:	81 30       	cpi	r24, 0x01	; 1
    10c2:	09 f0       	breq	.+2      	; 0x10c6 <FILE_Open+0x242>
    10c4:	9d c0       	rjmp	.+314    	; 0x1200 <__stack+0x101>
                {
                    *fileOpenSts = FAT32_FILE_OPEN_SUCCESSFUL;
    10c6:	f3 01       	movw	r30, r6
    10c8:	10 82       	st	Z, r1
    10ca:	8d 80       	ldd	r8, Y+5	; 0x05
    10cc:	9e 80       	ldd	r9, Y+6	; 0x06
    10ce:	fc e2       	ldi	r31, 0x2C	; 44
    10d0:	8f 0e       	add	r8, r31
    10d2:	91 1c       	adc	r9, r1

                    print_DebugMsg("Creating File..");
                    filePtr->cluster = getSetFreeCluster (filePtr->fileBuffer,NEXT_FREE, GET, 0);
    10d4:	00 e0       	ldi	r16, 0x00	; 0
    10d6:	10 e0       	ldi	r17, 0x00	; 0
    10d8:	98 01       	movw	r18, r16
    10da:	40 e0       	ldi	r20, 0x00	; 0
    10dc:	62 e0       	ldi	r22, 0x02	; 2
    10de:	c4 01       	movw	r24, r8
    10e0:	58 da       	rcall	.-2896   	; 0x592 <getSetFreeCluster>
    10e2:	ad 81       	ldd	r26, Y+5	; 0x05
    10e4:	be 81       	ldd	r27, Y+6	; 0x06
    10e6:	14 96       	adiw	r26, 0x04	; 4
    10e8:	6d 93       	st	X+, r22
    10ea:	7d 93       	st	X+, r23
    10ec:	8d 93       	st	X+, r24
    10ee:	9c 93       	st	X, r25
    10f0:	17 97       	sbiw	r26, 0x07	; 7
                    if(filePtr->cluster > totalClusters)
    10f2:	00 91 db 04 	lds	r16, 0x04DB
    10f6:	10 91 dc 04 	lds	r17, 0x04DC
    10fa:	20 91 dd 04 	lds	r18, 0x04DD
    10fe:	30 91 de 04 	lds	r19, 0x04DE
    1102:	06 17       	cp	r16, r22
    1104:	17 07       	cpc	r17, r23
    1106:	28 07       	cpc	r18, r24
    1108:	39 07       	cpc	r19, r25
    110a:	70 f4       	brcc	.+28     	; 0x1128 <__stack+0x29>
                    {
                        filePtr->cluster = rootCluster;
    110c:	80 91 df 06 	lds	r24, 0x06DF
    1110:	90 91 e0 06 	lds	r25, 0x06E0
    1114:	a0 91 e1 06 	lds	r26, 0x06E1
    1118:	b0 91 e2 06 	lds	r27, 0x06E2
    111c:	ed 81       	ldd	r30, Y+5	; 0x05
    111e:	fe 81       	ldd	r31, Y+6	; 0x06
    1120:	84 83       	std	Z+4, r24	; 0x04
    1122:	95 83       	std	Z+5, r25	; 0x05
    1124:	a6 83       	std	Z+6, r26	; 0x06
    1126:	b7 83       	std	Z+7, r27	; 0x07
                    }
                    print_DebugMsg("searchNextFreeCluster..");
                    filePtr->cluster = searchNextFreeCluster(filePtr->fileBuffer,filePtr->cluster);
    1128:	ad 81       	ldd	r26, Y+5	; 0x05
    112a:	be 81       	ldd	r27, Y+6	; 0x06
    112c:	14 96       	adiw	r26, 0x04	; 4
    112e:	4d 91       	ld	r20, X+
    1130:	5d 91       	ld	r21, X+
    1132:	6d 91       	ld	r22, X+
    1134:	7c 91       	ld	r23, X
    1136:	17 97       	sbiw	r26, 0x07	; 7
    1138:	c4 01       	movw	r24, r8
    113a:	80 dc       	rcall	.-1792   	; 0xa3c <searchNextFreeCluster>
    113c:	ab 01       	movw	r20, r22
    113e:	bc 01       	movw	r22, r24
    1140:	ed 81       	ldd	r30, Y+5	; 0x05
    1142:	fe 81       	ldd	r31, Y+6	; 0x06
    1144:	44 83       	std	Z+4, r20	; 0x04
    1146:	55 83       	std	Z+5, r21	; 0x05
    1148:	66 83       	std	Z+6, r22	; 0x06
    114a:	77 83       	std	Z+7, r23	; 0x07
                    if(filePtr->cluster == 0)
    114c:	41 15       	cp	r20, r1
    114e:	51 05       	cpc	r21, r1
    1150:	61 05       	cpc	r22, r1
    1152:	71 05       	cpc	r23, r1
    1154:	21 f4       	brne	.+8      	; 0x115e <__stack+0x5f>
                    {
                        print_DebugMsg("No free cluster!");
                        *fileOpenSts = FAT32_NO_FREE_CLUSTERS_FOUND;
    1156:	85 e0       	ldi	r24, 0x05	; 5
    1158:	d3 01       	movw	r26, r6
    115a:	8c 93       	st	X, r24
    115c:	35 c0       	rjmp	.+106    	; 0x11c8 <__stack+0xc9>
                        return 0;
                    } 

                    print_DebugMsg("get/Set NextCluster..");   //last cluster of the file, marked END_OF_CLUSTERS
                    getSetNextCluster(filePtr->fileBuffer,filePtr->cluster, SET, END_OF_CLUSTERS);
    115e:	ee 24       	eor	r14, r14
    1160:	ea 94       	dec	r14
    1162:	fe 2c       	mov	r15, r14
    1164:	0f ef       	ldi	r16, 0xFF	; 255
    1166:	1f e0       	ldi	r17, 0x0F	; 15
    1168:	21 e0       	ldi	r18, 0x01	; 1
    116a:	c4 01       	movw	r24, r8
    116c:	0d d8       	rcall	.-4070   	; 0x188 <getSetNextCluster>

                    filePtr->firstClusterHigh = (uint16_t) ((filePtr->cluster & 0xffff0000) >> 16 );
    116e:	ed 81       	ldd	r30, Y+5	; 0x05
    1170:	fe 81       	ldd	r31, Y+6	; 0x06
    1172:	64 81       	ldd	r22, Z+4	; 0x04
    1174:	75 81       	ldd	r23, Z+5	; 0x05
    1176:	86 81       	ldd	r24, Z+6	; 0x06
    1178:	97 81       	ldd	r25, Z+7	; 0x07
    117a:	d6 01       	movw	r26, r12
    117c:	55 96       	adiw	r26, 0x15	; 21
    117e:	9c 93       	st	X, r25
    1180:	8e 93       	st	-X, r24
    1182:	54 97       	sbiw	r26, 0x14	; 20
                    filePtr->firstClusterLow = (uint16_t) ( filePtr->cluster & 0x0000ffff);
    1184:	57 96       	adiw	r26, 0x17	; 23
    1186:	7c 93       	st	X, r23
    1188:	6e 93       	st	-X, r22
    118a:	56 97       	sbiw	r26, 0x16	; 22
                    filePtr->fileSize = 0;
    118c:	f6 01       	movw	r30, r12
    118e:	10 82       	st	Z, r1
    1190:	11 82       	std	Z+1, r1	; 0x01
    1192:	12 82       	std	Z+2, r1	; 0x02
    1194:	13 82       	std	Z+3, r1	; 0x03

                    filePtr->blockNumber_u32 = getFirstSector (filePtr->cluster);
    1196:	0e 94 a7 00 	call	0x14e	; 0x14e <getFirstSector>
    119a:	ad 81       	ldd	r26, Y+5	; 0x05
    119c:	be 81       	ldd	r27, Y+6	; 0x06
    119e:	5c 96       	adiw	r26, 0x1c	; 28
    11a0:	6d 93       	st	X+, r22
    11a2:	7d 93       	st	X+, r23
    11a4:	8d 93       	st	X+, r24
    11a6:	9c 93       	st	X, r25
    11a8:	5f 97       	sbiw	r26, 0x1f	; 31
                    filePtr->bufferIndex_u16=0;
    11aa:	f6 01       	movw	r30, r12
    11ac:	13 8a       	std	Z+19, r1	; 0x13
    11ae:	12 8a       	std	Z+18, r1	; 0x12
                    filePtr->sectorIndex=0;
    11b0:	11 8a       	std	Z+17, r1	; 0x11
    11b2:	10 8a       	std	Z+16, r1	; 0x10
                {
                    filePtr = 0;
                }
            }

            if(filePtr!= 0)
    11b4:	4d 80       	ldd	r4, Y+5	; 0x05
    11b6:	5e 80       	ldd	r5, Y+6	; 0x06
    11b8:	45 28       	or	r4, r5
    11ba:	19 f0       	breq	.+6      	; 0x11c2 <__stack+0xc3>
            {
                fatMappingTable[i].fileOpenedFlag = C_FileAllocated_U8;
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	d5 01       	movw	r26, r10
    11c0:	8c 93       	st	X, r24
    if(freeLocationDetected == FALSE)
    {
        *fileOpenSts = FAT32_TO_MANY_FILES_OPENED;
    }

    return filePtr;
    11c2:	83 2d       	mov	r24, r3
    11c4:	92 2d       	mov	r25, r2
    11c6:	1f c0       	rjmp	.+62     	; 0x1206 <__stack+0x107>
                *fileOpenSts = openFile( READ, filePtr);
                if(*fileOpenSts != FAT32_FILE_OPEN_SUCCESSFUL)
                {

                    print_DebugMsg("FILE_DELETED_OR_NOT_FOUND");
                    return  0; /* Set the pointer to NULL indication File not found or Read failed, */
    11c8:	80 e0       	ldi	r24, 0x00	; 0
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	1c c0       	rjmp	.+56     	; 0x1206 <__stack+0x107>
{
    fileConfig_st *filePtr = 0x00;
    uint8_t i,freeLocationDetected = FALSE;
    uint32_t nextCluster, clusterCount;

    for(i=0;((i< C_MaxFilesOpening_U8) && (freeLocationDetected == FALSE));i++)
    11ce:	2d 81       	ldd	r18, Y+5	; 0x05
    11d0:	3e 81       	ldd	r19, Y+6	; 0x06
    11d2:	29 52       	subi	r18, 0x29	; 41
    11d4:	39 40       	sbci	r19, 0x09	; 9
    11d6:	79 f0       	breq	.+30     	; 0x11f6 <__stack+0xf7>
    11d8:	b2 ec       	ldi	r27, 0xC2	; 194
    11da:	ab 1a       	sub	r10, r27
    11dc:	bd ef       	ldi	r27, 0xFD	; 253
    11de:	bb 0a       	sbc	r11, r27
    11e0:	ed 81       	ldd	r30, Y+5	; 0x05
    11e2:	fe 81       	ldd	r31, Y+6	; 0x06
    11e4:	e2 5c       	subi	r30, 0xC2	; 194
    11e6:	fd 4f       	sbci	r31, 0xFD	; 253
    11e8:	fe 83       	std	Y+6, r31	; 0x06
    11ea:	ed 83       	std	Y+5, r30	; 0x05
    11ec:	f2 ec       	ldi	r31, 0xC2	; 194
    11ee:	cf 1a       	sub	r12, r31
    11f0:	fd ef       	ldi	r31, 0xFD	; 253
    11f2:	df 0a       	sbc	r13, r31
    11f4:	6a ce       	rjmp	.-812    	; 0xeca <FILE_Open+0x46>
    11f6:	31 2c       	mov	r3, r1
    11f8:	21 2c       	mov	r2, r1
        }
    }

    if(freeLocationDetected == FALSE)
    {
        *fileOpenSts = FAT32_TO_MANY_FILES_OPENED;
    11fa:	87 e0       	ldi	r24, 0x07	; 7
    11fc:	da 01       	movw	r26, r20
    11fe:	e0 cf       	rjmp	.-64     	; 0x11c0 <__stack+0xc1>
    1200:	31 2c       	mov	r3, r1
    1202:	21 2c       	mov	r2, r1
    1204:	de cf       	rjmp	.-68     	; 0x11c2 <__stack+0xc3>
    }

    return filePtr;
}
    1206:	26 96       	adiw	r28, 0x06	; 6
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	cd bf       	out	0x3d, r28	; 61
    1212:	df 91       	pop	r29
    1214:	cf 91       	pop	r28
    1216:	1f 91       	pop	r17
    1218:	0f 91       	pop	r16
    121a:	ff 90       	pop	r15
    121c:	ef 90       	pop	r14
    121e:	df 90       	pop	r13
    1220:	cf 90       	pop	r12
    1222:	bf 90       	pop	r11
    1224:	af 90       	pop	r10
    1226:	9f 90       	pop	r9
    1228:	8f 90       	pop	r8
    122a:	7f 90       	pop	r7
    122c:	6f 90       	pop	r6
    122e:	5f 90       	pop	r5
    1230:	4f 90       	pop	r4
    1232:	3f 90       	pop	r3
    1234:	2f 90       	pop	r2
    1236:	08 95       	ret

00001238 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (char *inputBuffer, uint8_t flag, uint32_t size)
{
    1238:	8f 92       	push	r8
    123a:	9f 92       	push	r9
    123c:	af 92       	push	r10
    123e:	bf 92       	push	r11
    1240:	cf 92       	push	r12
    1242:	df 92       	push	r13
    1244:	ef 92       	push	r14
    1246:	ff 92       	push	r15
    1248:	0f 93       	push	r16
    124a:	1f 93       	push	r17
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    uint32_t freeClusters;
    //convert file size into number of clusters occupied
    if((size % 512) == 0) size = size / 512;
    1250:	49 01       	movw	r8, r18
    1252:	5a 01       	movw	r10, r20
    1254:	71 e0       	ldi	r23, 0x01	; 1
    1256:	97 22       	and	r9, r23
    1258:	aa 24       	eor	r10, r10
    125a:	bb 24       	eor	r11, r11
    125c:	69 01       	movw	r12, r18
    125e:	7a 01       	movw	r14, r20
    1260:	59 e0       	ldi	r21, 0x09	; 9
    1262:	f6 94       	lsr	r15
    1264:	e7 94       	ror	r14
    1266:	d7 94       	ror	r13
    1268:	c7 94       	ror	r12
    126a:	5a 95       	dec	r21
    126c:	d1 f7       	brne	.-12     	; 0x1262 <freeMemoryUpdate+0x2a>
    126e:	89 28       	or	r8, r9
    1270:	8a 28       	or	r8, r10
    1272:	8b 28       	or	r8, r11
    1274:	29 f0       	breq	.+10     	; 0x1280 <freeMemoryUpdate+0x48>
    else size = (size / 512) +1;
    1276:	2f ef       	ldi	r18, 0xFF	; 255
    1278:	c2 1a       	sub	r12, r18
    127a:	d2 0a       	sbc	r13, r18
    127c:	e2 0a       	sbc	r14, r18
    127e:	f2 0a       	sbc	r15, r18
    if((size % 8) == 0) size = size / 8;
    1280:	97 01       	movw	r18, r14
    1282:	86 01       	movw	r16, r12
    1284:	07 70       	andi	r16, 0x07	; 7
    1286:	11 27       	eor	r17, r17
    1288:	22 27       	eor	r18, r18
    128a:	33 27       	eor	r19, r19
    128c:	43 e0       	ldi	r20, 0x03	; 3
    128e:	f6 94       	lsr	r15
    1290:	e7 94       	ror	r14
    1292:	d7 94       	ror	r13
    1294:	c7 94       	ror	r12
    1296:	4a 95       	dec	r20
    1298:	d1 f7       	brne	.-12     	; 0x128e <freeMemoryUpdate+0x56>
    129a:	01 2b       	or	r16, r17
    129c:	02 2b       	or	r16, r18
    129e:	03 2b       	or	r16, r19
    12a0:	29 f0       	breq	.+10     	; 0x12ac <freeMemoryUpdate+0x74>
    else size = (size / 8) +1;
    12a2:	7f ef       	ldi	r23, 0xFF	; 255
    12a4:	c7 1a       	sub	r12, r23
    12a6:	d7 0a       	sbc	r13, r23
    12a8:	e7 0a       	sbc	r14, r23
    12aa:	f7 0a       	sbc	r15, r23

    if(freeClusterCountUpdated)
    12ac:	20 91 67 0b 	lds	r18, 0x0B67
    12b0:	22 23       	and	r18, r18
    12b2:	c9 f0       	breq	.+50     	; 0x12e6 <freeMemoryUpdate+0xae>
    12b4:	b6 2e       	mov	r11, r22
    12b6:	ec 01       	movw	r28, r24
    {
        freeClusters = getSetFreeCluster (inputBuffer,TOTAL_FREE, GET, 0);
    12b8:	00 e0       	ldi	r16, 0x00	; 0
    12ba:	10 e0       	ldi	r17, 0x00	; 0
    12bc:	98 01       	movw	r18, r16
    12be:	40 e0       	ldi	r20, 0x00	; 0
    12c0:	61 e0       	ldi	r22, 0x01	; 1
    12c2:	67 d9       	rcall	.-3378   	; 0x592 <getSetFreeCluster>
        if(flag == ADD)
            freeClusters = freeClusters + size;
    12c4:	8b 01       	movw	r16, r22
    12c6:	9c 01       	movw	r18, r24
    else size = (size / 8) +1;

    if(freeClusterCountUpdated)
    {
        freeClusters = getSetFreeCluster (inputBuffer,TOTAL_FREE, GET, 0);
        if(flag == ADD)
    12c8:	b1 10       	cpse	r11, r1
    12ca:	05 c0       	rjmp	.+10     	; 0x12d6 <freeMemoryUpdate+0x9e>
            freeClusters = freeClusters + size;
    12cc:	0c 0d       	add	r16, r12
    12ce:	1d 1d       	adc	r17, r13
    12d0:	2e 1d       	adc	r18, r14
    12d2:	3f 1d       	adc	r19, r15
    12d4:	04 c0       	rjmp	.+8      	; 0x12de <freeMemoryUpdate+0xa6>
        else  //when flag = REMOVE
            freeClusters = freeClusters - size;
    12d6:	0c 19       	sub	r16, r12
    12d8:	1d 09       	sbc	r17, r13
    12da:	2e 09       	sbc	r18, r14
    12dc:	3f 09       	sbc	r19, r15
        getSetFreeCluster (inputBuffer,TOTAL_FREE, SET, freeClusters);
    12de:	41 e0       	ldi	r20, 0x01	; 1
    12e0:	61 e0       	ldi	r22, 0x01	; 1
    12e2:	ce 01       	movw	r24, r28
    12e4:	56 d9       	rcall	.-3412   	; 0x592 <getSetFreeCluster>
    }
}
    12e6:	df 91       	pop	r29
    12e8:	cf 91       	pop	r28
    12ea:	1f 91       	pop	r17
    12ec:	0f 91       	pop	r16
    12ee:	ff 90       	pop	r15
    12f0:	ef 90       	pop	r14
    12f2:	df 90       	pop	r13
    12f4:	cf 90       	pop	r12
    12f6:	bf 90       	pop	r11
    12f8:	af 90       	pop	r10
    12fa:	9f 90       	pop	r9
    12fc:	8f 90       	pop	r8
    12fe:	08 95       	ret

00001300 <FILE_PutCh>:
                 It checks whether the requested file is opened or not, it writes the data only if the file is open.

           Note: CTRL+Z(26) needs to be passed to mark the end of file. After which it saves the file and updates the FAT.
 ******************************************************************************************************************/
void FILE_PutCh (fileConfig_st *filePtr, char data)
{
    1300:	2f 92       	push	r2
    1302:	3f 92       	push	r3
    1304:	4f 92       	push	r4
    1306:	5f 92       	push	r5
    1308:	6f 92       	push	r6
    130a:	7f 92       	push	r7
    130c:	8f 92       	push	r8
    130e:	9f 92       	push	r9
    1310:	af 92       	push	r10
    1312:	bf 92       	push	r11
    1314:	cf 92       	push	r12
    1316:	df 92       	push	r13
    1318:	ef 92       	push	r14
    131a:	ff 92       	push	r15
    131c:	0f 93       	push	r16
    131e:	1f 93       	push	r17
    1320:	cf 93       	push	r28
    1322:	df 93       	push	r29
    uint8_t k;
    dir_Structure *dir;
    uint32_t extraMemory;
    if(filePtr->fileOpenedFlag == TRUE)
    1324:	fc 01       	movw	r30, r24
    1326:	e3 5d       	subi	r30, 0xD3	; 211
    1328:	fd 4f       	sbci	r31, 0xFD	; 253
    132a:	20 81       	ld	r18, Z
    132c:	21 30       	cpi	r18, 0x01	; 1
    132e:	09 f0       	breq	.+2      	; 0x1332 <FILE_PutCh+0x32>
    1330:	27 c2       	rjmp	.+1102   	; 0x1780 <FILE_PutCh+0x480>
    {
        if((filePtr->endOfFileDetected == 0) && (data != EOF))
    1332:	34 96       	adiw	r30, 0x04	; 4
    1334:	30 81       	ld	r19, Z
    1336:	31 11       	cpse	r19, r1
    1338:	23 c2       	rjmp	.+1094   	; 0x1780 <FILE_PutCh+0x480>
    133a:	ec 01       	movw	r28, r24
    133c:	6a 31       	cpi	r22, 0x1A	; 26
    133e:	09 f4       	brne	.+2      	; 0x1342 <FILE_PutCh+0x42>
    1340:	cc c0       	rjmp	.+408    	; 0x14da <FILE_PutCh+0x1da>
        {
            if(filePtr->sectorEndFlag == 1) //special case when the last character in previous sector was '\r'
    1342:	31 97       	sbiw	r30, 0x01	; 1
    1344:	80 81       	ld	r24, Z
    1346:	81 30       	cpi	r24, 0x01	; 1
    1348:	c9 f4       	brne	.+50     	; 0x137c <FILE_PutCh+0x7c>
            {
                filePtr->fileBuffer[filePtr->bufferIndex_u16++] = '\n'; //appending 'Line Feed (LF)' character
    134a:	8e a1       	ldd	r24, Y+38	; 0x26
    134c:	9f a1       	ldd	r25, Y+39	; 0x27
    134e:	9c 01       	movw	r18, r24
    1350:	2f 5f       	subi	r18, 0xFF	; 255
    1352:	3f 4f       	sbci	r19, 0xFF	; 255
    1354:	3f a3       	std	Y+39, r19	; 0x27
    1356:	2e a3       	std	Y+38, r18	; 0x26
    1358:	de 01       	movw	r26, r28
    135a:	a8 0f       	add	r26, r24
    135c:	b9 1f       	adc	r27, r25
    135e:	2a e0       	ldi	r18, 0x0A	; 10
    1360:	9c 96       	adiw	r26, 0x2c	; 44
    1362:	2c 93       	st	X, r18
                filePtr->fileSize++;
    1364:	8c 89       	ldd	r24, Y+20	; 0x14
    1366:	9d 89       	ldd	r25, Y+21	; 0x15
    1368:	ae 89       	ldd	r26, Y+22	; 0x16
    136a:	bf 89       	ldd	r27, Y+23	; 0x17
    136c:	01 96       	adiw	r24, 0x01	; 1
    136e:	a1 1d       	adc	r26, r1
    1370:	b1 1d       	adc	r27, r1
    1372:	8c 8b       	std	Y+20, r24	; 0x14
    1374:	9d 8b       	std	Y+21, r25	; 0x15
    1376:	ae 8b       	std	Y+22, r26	; 0x16
    1378:	bf 8b       	std	Y+23, r27	; 0x17
                filePtr->sectorEndFlag = 0;
    137a:	10 82       	st	Z, r1
    137c:	8e a1       	ldd	r24, Y+38	; 0x26
    137e:	9f a1       	ldd	r25, Y+39	; 0x27
            }

            if(data == 0x08)    //'Back Space' key pressed
    1380:	68 30       	cpi	r22, 0x08	; 8
    1382:	91 f4       	brne	.+36     	; 0x13a8 <FILE_PutCh+0xa8>
            {
                if(filePtr->bufferIndex_u16 != 0)
    1384:	00 97       	sbiw	r24, 0x00	; 0
    1386:	09 f4       	brne	.+2      	; 0x138a <FILE_PutCh+0x8a>
    1388:	42 c0       	rjmp	.+132    	; 0x140e <FILE_PutCh+0x10e>
                {
                    filePtr->bufferIndex_u16--;
    138a:	01 97       	sbiw	r24, 0x01	; 1
    138c:	9f a3       	std	Y+39, r25	; 0x27
    138e:	8e a3       	std	Y+38, r24	; 0x26
                    filePtr->fileSize--;
    1390:	8c 89       	ldd	r24, Y+20	; 0x14
    1392:	9d 89       	ldd	r25, Y+21	; 0x15
    1394:	ae 89       	ldd	r26, Y+22	; 0x16
    1396:	bf 89       	ldd	r27, Y+23	; 0x17
    1398:	01 97       	sbiw	r24, 0x01	; 1
    139a:	a1 09       	sbc	r26, r1
    139c:	b1 09       	sbc	r27, r1
    139e:	8c 8b       	std	Y+20, r24	; 0x14
    13a0:	9d 8b       	std	Y+21, r25	; 0x15
    13a2:	ae 8b       	std	Y+22, r26	; 0x16
    13a4:	bf 8b       	std	Y+23, r27	; 0x17
    13a6:	33 c0       	rjmp	.+102    	; 0x140e <FILE_PutCh+0x10e>
                }
            }
            else
            {
                filePtr->fileBuffer[filePtr->bufferIndex_u16++] = data;
    13a8:	9c 01       	movw	r18, r24
    13aa:	2f 5f       	subi	r18, 0xFF	; 255
    13ac:	3f 4f       	sbci	r19, 0xFF	; 255
    13ae:	3f a3       	std	Y+39, r19	; 0x27
    13b0:	2e a3       	std	Y+38, r18	; 0x26
    13b2:	de 01       	movw	r26, r28
    13b4:	a8 0f       	add	r26, r24
    13b6:	b9 1f       	adc	r27, r25
    13b8:	9c 96       	adiw	r26, 0x2c	; 44
    13ba:	6c 93       	st	X, r22
                filePtr->fileSize++;
    13bc:	8c 88       	ldd	r8, Y+20	; 0x14
    13be:	9d 88       	ldd	r9, Y+21	; 0x15
    13c0:	ae 88       	ldd	r10, Y+22	; 0x16
    13c2:	bf 88       	ldd	r11, Y+23	; 0x17
    13c4:	75 01       	movw	r14, r10
    13c6:	64 01       	movw	r12, r8
    13c8:	4f ef       	ldi	r20, 0xFF	; 255
    13ca:	c4 1a       	sub	r12, r20
    13cc:	d4 0a       	sbc	r13, r20
    13ce:	e4 0a       	sbc	r14, r20
    13d0:	f4 0a       	sbc	r15, r20
    13d2:	cc 8a       	std	Y+20, r12	; 0x14
    13d4:	dd 8a       	std	Y+21, r13	; 0x15
    13d6:	ee 8a       	std	Y+22, r14	; 0x16
    13d8:	ff 8a       	std	Y+23, r15	; 0x17
            }


            if(data == '\r')  //'Carriege Return (CR)' character
    13da:	6d 30       	cpi	r22, 0x0D	; 13
    13dc:	c1 f4       	brne	.+48     	; 0x140e <FILE_PutCh+0x10e>
            {
                if(filePtr->bufferIndex_u16 == 512)
    13de:	21 15       	cp	r18, r1
    13e0:	a2 e0       	ldi	r26, 0x02	; 2
    13e2:	3a 07       	cpc	r19, r26
    13e4:	19 f4       	brne	.+6      	; 0x13ec <FILE_PutCh+0xec>
                    filePtr->sectorEndFlag = 1;  //flag to indicate that the appended '\n' char should be put in the next sector
    13e6:	81 e0       	ldi	r24, 0x01	; 1
    13e8:	80 83       	st	Z, r24
    13ea:	11 c0       	rjmp	.+34     	; 0x140e <FILE_PutCh+0x10e>
                else
                {
                    filePtr->fileBuffer[filePtr->bufferIndex_u16++] = '\n'; //appending 'Line Feed (LF)' character
    13ec:	02 96       	adiw	r24, 0x02	; 2
    13ee:	9f a3       	std	Y+39, r25	; 0x27
    13f0:	8e a3       	std	Y+38, r24	; 0x26
    13f2:	fe 01       	movw	r30, r28
    13f4:	e2 0f       	add	r30, r18
    13f6:	f3 1f       	adc	r31, r19
    13f8:	8a e0       	ldi	r24, 0x0A	; 10
    13fa:	84 a7       	std	Z+44, r24	; 0x2c
                    filePtr->fileSize++;
    13fc:	b2 e0       	ldi	r27, 0x02	; 2
    13fe:	8b 0e       	add	r8, r27
    1400:	91 1c       	adc	r9, r1
    1402:	a1 1c       	adc	r10, r1
    1404:	b1 1c       	adc	r11, r1
    1406:	8c 8a       	std	Y+20, r8	; 0x14
    1408:	9d 8a       	std	Y+21, r9	; 0x15
    140a:	ae 8a       	std	Y+22, r10	; 0x16
    140c:	bf 8a       	std	Y+23, r11	; 0x17
                }
            }

            if(filePtr->bufferIndex_u16 >= 512)   //though 'i' will never become greater than 512, it's kept here to avoid
    140e:	8e a1       	ldd	r24, Y+38	; 0x26
    1410:	9f a1       	ldd	r25, Y+39	; 0x27
    1412:	81 15       	cp	r24, r1
    1414:	92 40       	sbci	r25, 0x02	; 2
    1416:	08 f4       	brcc	.+2      	; 0x141a <FILE_PutCh+0x11a>
    1418:	b3 c1       	rjmp	.+870    	; 0x1780 <FILE_PutCh+0x480>
            {               //infinite loop in case it happens to be greater than 512 due to some data corruption
                filePtr->bufferIndex_u16=0;
    141a:	1f a2       	std	Y+39, r1	; 0x27
    141c:	1e a2       	std	Y+38, r1	; 0x26
                SD_writeSingleBlock (filePtr->fileBuffer,filePtr->blockNumber_u32);
    141e:	6e 01       	movw	r12, r28
    1420:	fc e2       	ldi	r31, 0x2C	; 44
    1422:	cf 0e       	add	r12, r31
    1424:	d1 1c       	adc	r13, r1
    1426:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1428:	5d 8d       	ldd	r21, Y+29	; 0x1d
    142a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    142c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    142e:	c6 01       	movw	r24, r12
    1430:	1a d5       	rcall	.+2612   	; 0x1e66 <SD_writeSingleBlock>
                filePtr->sectorIndex++;
    1432:	2c a1       	ldd	r18, Y+36	; 0x24
    1434:	3d a1       	ldd	r19, Y+37	; 0x25
    1436:	2f 5f       	subi	r18, 0xFF	; 255
    1438:	3f 4f       	sbci	r19, 0xFF	; 255
    143a:	3d a3       	std	Y+37, r19	; 0x25
    143c:	2c a3       	std	Y+36, r18	; 0x24
                if(filePtr->sectorIndex == sectorPerCluster)
    143e:	80 91 e3 06 	lds	r24, 0x06E3
    1442:	90 91 e4 06 	lds	r25, 0x06E4
    1446:	28 17       	cp	r18, r24
    1448:	39 07       	cpc	r19, r25
    144a:	d9 f5       	brne	.+118    	; 0x14c2 <FILE_PutCh+0x1c2>
                {
                    filePtr->sectorIndex = 0;
    144c:	1d a2       	std	Y+37, r1	; 0x25
    144e:	1c a2       	std	Y+36, r1	; 0x24
                    filePtr->prevCluster = filePtr->cluster;
    1450:	4c 81       	ldd	r20, Y+4	; 0x04
    1452:	5d 81       	ldd	r21, Y+5	; 0x05
    1454:	6e 81       	ldd	r22, Y+6	; 0x06
    1456:	7f 81       	ldd	r23, Y+7	; 0x07
    1458:	48 87       	std	Y+8, r20	; 0x08
    145a:	59 87       	std	Y+9, r21	; 0x09
    145c:	6a 87       	std	Y+10, r22	; 0x0a
    145e:	7b 87       	std	Y+11, r23	; 0x0b

                    filePtr->cluster = searchNextFreeCluster(filePtr->fileBuffer,filePtr->prevCluster); //look for a free cluster starting from the current cluster
    1460:	c6 01       	movw	r24, r12
    1462:	ec da       	rcall	.-2600   	; 0xa3c <searchNextFreeCluster>
    1464:	6c 83       	std	Y+4, r22	; 0x04
    1466:	7d 83       	std	Y+5, r23	; 0x05
    1468:	8e 83       	std	Y+6, r24	; 0x06
    146a:	9f 83       	std	Y+7, r25	; 0x07

                    if(filePtr->cluster == 0)
    146c:	61 15       	cp	r22, r1
    146e:	71 05       	cpc	r23, r1
    1470:	81 05       	cpc	r24, r1
    1472:	91 05       	cpc	r25, r1
    1474:	09 f4       	brne	.+2      	; 0x1478 <FILE_PutCh+0x178>
    1476:	84 c1       	rjmp	.+776    	; 0x1780 <FILE_PutCh+0x480>
                    {
                        print_DebugMsg("No free cluster!");
                        return;
                    }

                    getSetNextCluster(filePtr->fileBuffer,filePtr->prevCluster, SET, filePtr->cluster);
    1478:	88 84       	ldd	r8, Y+8	; 0x08
    147a:	99 84       	ldd	r9, Y+9	; 0x09
    147c:	aa 84       	ldd	r10, Y+10	; 0x0a
    147e:	bb 84       	ldd	r11, Y+11	; 0x0b
    1480:	7b 01       	movw	r14, r22
    1482:	8c 01       	movw	r16, r24
    1484:	21 e0       	ldi	r18, 0x01	; 1
    1486:	b5 01       	movw	r22, r10
    1488:	a4 01       	movw	r20, r8
    148a:	c6 01       	movw	r24, r12
    148c:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>
                    getSetNextCluster(filePtr->fileBuffer,filePtr->cluster, SET, END_OF_CLUSTERS);   //last cluster of the file, marked END_OF_CLUSTERS
    1490:	4c 81       	ldd	r20, Y+4	; 0x04
    1492:	5d 81       	ldd	r21, Y+5	; 0x05
    1494:	6e 81       	ldd	r22, Y+6	; 0x06
    1496:	7f 81       	ldd	r23, Y+7	; 0x07
    1498:	ee 24       	eor	r14, r14
    149a:	ea 94       	dec	r14
    149c:	fe 2c       	mov	r15, r14
    149e:	0f ef       	ldi	r16, 0xFF	; 255
    14a0:	1f e0       	ldi	r17, 0x0F	; 15
    14a2:	21 e0       	ldi	r18, 0x01	; 1
    14a4:	c6 01       	movw	r24, r12
    14a6:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>

                    filePtr->blockNumber_u32 = getFirstSector (filePtr->cluster);
    14aa:	6c 81       	ldd	r22, Y+4	; 0x04
    14ac:	7d 81       	ldd	r23, Y+5	; 0x05
    14ae:	8e 81       	ldd	r24, Y+6	; 0x06
    14b0:	9f 81       	ldd	r25, Y+7	; 0x07
    14b2:	0e 94 a7 00 	call	0x14e	; 0x14e <getFirstSector>
    14b6:	6c 8f       	std	Y+28, r22	; 0x1c
    14b8:	7d 8f       	std	Y+29, r23	; 0x1d
    14ba:	8e 8f       	std	Y+30, r24	; 0x1e
    14bc:	9f 8f       	std	Y+31, r25	; 0x1f
                    filePtr->bufferIndex_u16=0;
    14be:	1f a2       	std	Y+39, r1	; 0x27
    14c0:	1e a2       	std	Y+38, r1	; 0x26
                }
                filePtr->blockNumber_u32++;
    14c2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    14c4:	9d 8d       	ldd	r25, Y+29	; 0x1d
    14c6:	ae 8d       	ldd	r26, Y+30	; 0x1e
    14c8:	bf 8d       	ldd	r27, Y+31	; 0x1f
    14ca:	01 96       	adiw	r24, 0x01	; 1
    14cc:	a1 1d       	adc	r26, r1
    14ce:	b1 1d       	adc	r27, r1
    14d0:	8c 8f       	std	Y+28, r24	; 0x1c
    14d2:	9d 8f       	std	Y+29, r25	; 0x1d
    14d4:	ae 8f       	std	Y+30, r26	; 0x1e
    14d6:	bf 8f       	std	Y+31, r27	; 0x1f
    14d8:	53 c1       	rjmp	.+678    	; 0x1780 <FILE_PutCh+0x480>
            }
        }
        else if(filePtr->endOfFileDetected == 0)
        {
            filePtr->endOfFileDetected = 1;
    14da:	20 83       	st	Z, r18
            for(;filePtr->bufferIndex_u16<512;filePtr->bufferIndex_u16++)  //fill the rest of the buffer with 0x00
    14dc:	8e a1       	ldd	r24, Y+38	; 0x26
    14de:	9f a1       	ldd	r25, Y+39	; 0x27
    14e0:	81 15       	cp	r24, r1
    14e2:	22 e0       	ldi	r18, 0x02	; 2
    14e4:	92 07       	cpc	r25, r18
    14e6:	40 f4       	brcc	.+16     	; 0x14f8 <FILE_PutCh+0x1f8>
                filePtr->fileBuffer[filePtr->bufferIndex_u16]= 0x00;
    14e8:	fe 01       	movw	r30, r28
    14ea:	e8 0f       	add	r30, r24
    14ec:	f9 1f       	adc	r31, r25
    14ee:	14 a6       	std	Z+44, r1	; 0x2c
            }
        }
        else if(filePtr->endOfFileDetected == 0)
        {
            filePtr->endOfFileDetected = 1;
            for(;filePtr->bufferIndex_u16<512;filePtr->bufferIndex_u16++)  //fill the rest of the buffer with 0x00
    14f0:	01 96       	adiw	r24, 0x01	; 1
    14f2:	9f a3       	std	Y+39, r25	; 0x27
    14f4:	8e a3       	std	Y+38, r24	; 0x26
    14f6:	f2 cf       	rjmp	.-28     	; 0x14dc <FILE_PutCh+0x1dc>
                filePtr->fileBuffer[filePtr->bufferIndex_u16]= 0x00;

            SD_writeSingleBlock (filePtr->fileBuffer,filePtr->blockNumber_u32);
    14f8:	3e 01       	movw	r6, r28
    14fa:	4c e2       	ldi	r20, 0x2C	; 44
    14fc:	64 0e       	add	r6, r20
    14fe:	71 1c       	adc	r7, r1
    1500:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1502:	5d 8d       	ldd	r21, Y+29	; 0x1d
    1504:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1506:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1508:	c3 01       	movw	r24, r6
    150a:	ad d4       	rcall	.+2394   	; 0x1e66 <SD_writeSingleBlock>


            getSetFreeCluster (filePtr->fileBuffer,NEXT_FREE, SET, filePtr->cluster); //update FSinfo next free cluster entry
    150c:	0c 81       	ldd	r16, Y+4	; 0x04
    150e:	1d 81       	ldd	r17, Y+5	; 0x05
    1510:	2e 81       	ldd	r18, Y+6	; 0x06
    1512:	3f 81       	ldd	r19, Y+7	; 0x07
    1514:	41 e0       	ldi	r20, 0x01	; 1
    1516:	62 e0       	ldi	r22, 0x02	; 2
    1518:	c3 01       	movw	r24, r6
    151a:	3b d8       	rcall	.-3978   	; 0x592 <getSetFreeCluster>

            if(filePtr->appendFileFlag)  //executes this loop if file is to be appended
    151c:	fe 01       	movw	r30, r28
    151e:	e1 5d       	subi	r30, 0xD1	; 209
    1520:	fd 4f       	sbci	r31, 0xFD	; 253
    1522:	80 81       	ld	r24, Z
    1524:	88 23       	and	r24, r24
    1526:	d1 f1       	breq	.+116    	; 0x159c <FILE_PutCh+0x29c>
            {
                SD_readSingleBlock (filePtr->fileBuffer,filePtr->appendFileSector);
    1528:	4c 85       	ldd	r20, Y+12	; 0x0c
    152a:	5d 85       	ldd	r21, Y+13	; 0x0d
    152c:	6e 85       	ldd	r22, Y+14	; 0x0e
    152e:	7f 85       	ldd	r23, Y+15	; 0x0f
    1530:	c3 01       	movw	r24, r6
    1532:	6e d4       	rcall	.+2268   	; 0x1e10 <SD_readSingleBlock>
                dir = (dir_Structure *) &filePtr->fileBuffer[filePtr->appendFileLocation];
    1534:	e8 89       	ldd	r30, Y+16	; 0x10
    1536:	f9 89       	ldd	r31, Y+17	; 0x11
    1538:	bc 96       	adiw	r30, 0x2c	; 44
    153a:	ec 0f       	add	r30, r28
    153c:	fd 1f       	adc	r31, r29
                extraMemory = filePtr->fileSize - dir->fileSize;
    153e:	8c 89       	ldd	r24, Y+20	; 0x14
    1540:	9d 89       	ldd	r25, Y+21	; 0x15
    1542:	ae 89       	ldd	r26, Y+22	; 0x16
    1544:	bf 89       	ldd	r27, Y+23	; 0x17
    1546:	44 8d       	ldd	r20, Z+28	; 0x1c
    1548:	55 8d       	ldd	r21, Z+29	; 0x1d
    154a:	66 8d       	ldd	r22, Z+30	; 0x1e
    154c:	77 8d       	ldd	r23, Z+31	; 0x1f
    154e:	6c 01       	movw	r12, r24
    1550:	7d 01       	movw	r14, r26
    1552:	c4 1a       	sub	r12, r20
    1554:	d5 0a       	sbc	r13, r21
    1556:	e6 0a       	sbc	r14, r22
    1558:	f7 0a       	sbc	r15, r23
                dir->fileSize = filePtr->fileSize;
    155a:	84 8f       	std	Z+28, r24	; 0x1c
    155c:	95 8f       	std	Z+29, r25	; 0x1d
    155e:	a6 8f       	std	Z+30, r26	; 0x1e
    1560:	b7 8f       	std	Z+31, r27	; 0x1f
                SD_writeSingleBlock (filePtr->fileBuffer,filePtr->appendFileSector);
    1562:	4c 85       	ldd	r20, Y+12	; 0x0c
    1564:	5d 85       	ldd	r21, Y+13	; 0x0d
    1566:	6e 85       	ldd	r22, Y+14	; 0x0e
    1568:	7f 85       	ldd	r23, Y+15	; 0x0f
    156a:	c3 01       	movw	r24, r6
    156c:	7c d4       	rcall	.+2296   	; 0x1e66 <SD_writeSingleBlock>
                freeMemoryUpdate (filePtr->fileBuffer,REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    156e:	a7 01       	movw	r20, r14
    1570:	96 01       	movw	r18, r12
    1572:	61 e0       	ldi	r22, 0x01	; 1
    1574:	c3 01       	movw	r24, r6
    {
        /* FIle not opened, do not handle the file operation */
    }

    return;
}
    1576:	df 91       	pop	r29
    1578:	cf 91       	pop	r28
    157a:	1f 91       	pop	r17
    157c:	0f 91       	pop	r16
    157e:	ff 90       	pop	r15
    1580:	ef 90       	pop	r14
    1582:	df 90       	pop	r13
    1584:	cf 90       	pop	r12
    1586:	bf 90       	pop	r11
    1588:	af 90       	pop	r10
    158a:	9f 90       	pop	r9
    158c:	8f 90       	pop	r8
    158e:	7f 90       	pop	r7
    1590:	6f 90       	pop	r6
    1592:	5f 90       	pop	r5
    1594:	4f 90       	pop	r4
    1596:	3f 90       	pop	r3
    1598:	2f 90       	pop	r2
                SD_readSingleBlock (filePtr->fileBuffer,filePtr->appendFileSector);
                dir = (dir_Structure *) &filePtr->fileBuffer[filePtr->appendFileLocation];
                extraMemory = filePtr->fileSize - dir->fileSize;
                dir->fileSize = filePtr->fileSize;
                SD_writeSingleBlock (filePtr->fileBuffer,filePtr->appendFileSector);
                freeMemoryUpdate (filePtr->fileBuffer,REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    159a:	4e ce       	rjmp	.-868    	; 0x1238 <freeMemoryUpdate>
                return;
            }

            //executes following portion when new file is created

            filePtr->prevCluster = rootCluster; //root cluster
    159c:	80 91 df 06 	lds	r24, 0x06DF
    15a0:	90 91 e0 06 	lds	r25, 0x06E0
    15a4:	a0 91 e1 06 	lds	r26, 0x06E1
    15a8:	b0 91 e2 06 	lds	r27, 0x06E2
    15ac:	88 87       	std	Y+8, r24	; 0x08
    15ae:	99 87       	std	Y+9, r25	; 0x09
    15b0:	aa 87       	std	Y+10, r26	; 0x0a
    15b2:	bb 87       	std	Y+11, r27	; 0x0b

                    for(filePtr->bufferIndex_u16=0; filePtr->bufferIndex_u16<bytesPerSector; filePtr->bufferIndex_u16+=32)
                    {
                        dir = (dir_Structure *) &filePtr->fileBuffer[filePtr->bufferIndex_u16];

                        if(filePtr->fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    15b4:	5e 01       	movw	r10, r28
    15b6:	82 ed       	ldi	r24, 0xD2	; 210
    15b8:	a8 1a       	sub	r10, r24
    15ba:	8d ef       	ldi	r24, 0xFD	; 253
    15bc:	b8 0a       	sbc	r11, r24
    15be:	1e 01       	movw	r2, r28
    15c0:	ae ec       	ldi	r26, 0xCE	; 206
    15c2:	2a 1a       	sub	r2, r26
    15c4:	ad ef       	ldi	r26, 0xFD	; 253
    15c6:	3a 0a       	sbc	r3, r26
    15c8:	2e 01       	movw	r4, r28
    15ca:	b3 ec       	ldi	r27, 0xC3	; 195
    15cc:	4b 1a       	sub	r4, r27
    15ce:	bd ef       	ldi	r27, 0xFD	; 253
    15d0:	5b 0a       	sbc	r5, r27
                            for(k=0; k<11; k++)
                                dir->name[k] = filePtr->fileName[k];
                            dir->attrib = ATTR_ARCHIVE; //settting file attribute as 'archive'
                            dir->NTreserved = 0;            //always set to 0
                            dir->timeTenth = 0;         //always set to 0
                            dir->createTime = file_GetTime();       // time of creation
    15d2:	9c e1       	ldi	r25, 0x1C	; 28
    15d4:	89 2e       	mov	r8, r25
    15d6:	9d e6       	ldi	r25, 0x6D	; 109
    15d8:	99 2e       	mov	r9, r25
                            dir->createDate = file_GetDate();       // date of creation
    15da:	22 e4       	ldi	r18, 0x42	; 66
    15dc:	c2 2e       	mov	r12, r18
    15de:	27 e4       	ldi	r18, 0x47	; 71
    15e0:	d2 2e       	mov	r13, r18

            filePtr->prevCluster = rootCluster; //root cluster

            while(1)
            {
                filePtr->firstSector = getFirstSector (filePtr->prevCluster);
    15e2:	68 85       	ldd	r22, Y+8	; 0x08
    15e4:	79 85       	ldd	r23, Y+9	; 0x09
    15e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    15e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    15ea:	0e 94 a7 00 	call	0x14e	; 0x14e <getFirstSector>
    15ee:	68 83       	st	Y, r22
    15f0:	79 83       	std	Y+1, r23	; 0x01
    15f2:	8a 83       	std	Y+2, r24	; 0x02
    15f4:	9b 83       	std	Y+3, r25	; 0x03

                for(filePtr->sectorIndex = 0; filePtr->sectorIndex < sectorPerCluster; filePtr->sectorIndex++)
    15f6:	1d a2       	std	Y+37, r1	; 0x25
    15f8:	1c a2       	std	Y+36, r1	; 0x24
    15fa:	8c a1       	ldd	r24, Y+36	; 0x24
    15fc:	9d a1       	ldd	r25, Y+37	; 0x25
    15fe:	20 91 e3 06 	lds	r18, 0x06E3
    1602:	30 91 e4 06 	lds	r19, 0x06E4
    1606:	82 17       	cp	r24, r18
    1608:	93 07       	cpc	r25, r19
    160a:	08 f0       	brcs	.+2      	; 0x160e <FILE_PutCh+0x30e>
    160c:	70 c0       	rjmp	.+224    	; 0x16ee <FILE_PutCh+0x3ee>
                {
                    SD_readSingleBlock (filePtr->fileBuffer,filePtr->firstSector + filePtr->sectorIndex);
    160e:	48 81       	ld	r20, Y
    1610:	59 81       	ldd	r21, Y+1	; 0x01
    1612:	6a 81       	ldd	r22, Y+2	; 0x02
    1614:	7b 81       	ldd	r23, Y+3	; 0x03
    1616:	48 0f       	add	r20, r24
    1618:	59 1f       	adc	r21, r25
    161a:	61 1d       	adc	r22, r1
    161c:	71 1d       	adc	r23, r1
    161e:	c3 01       	movw	r24, r6
    1620:	f7 d3       	rcall	.+2030   	; 0x1e10 <SD_readSingleBlock>


                    for(filePtr->bufferIndex_u16=0; filePtr->bufferIndex_u16<bytesPerSector; filePtr->bufferIndex_u16+=32)
    1622:	1f a2       	std	Y+39, r1	; 0x27
    1624:	1e a2       	std	Y+38, r1	; 0x26
                            dir->firstClusterHI = filePtr->firstClusterHigh;
                            dir->firstClusterLO = filePtr->firstClusterLow;
                            dir->fileSize = filePtr->fileSize;

                            SD_writeSingleBlock (filePtr->fileBuffer,filePtr->firstSector + filePtr->sectorIndex);
                            filePtr->fileCreatedFlag = 1;
    1626:	11 e0       	ldi	r17, 0x01	; 1
                for(filePtr->sectorIndex = 0; filePtr->sectorIndex < sectorPerCluster; filePtr->sectorIndex++)
                {
                    SD_readSingleBlock (filePtr->fileBuffer,filePtr->firstSector + filePtr->sectorIndex);


                    for(filePtr->bufferIndex_u16=0; filePtr->bufferIndex_u16<bytesPerSector; filePtr->bufferIndex_u16+=32)
    1628:	ee a1       	ldd	r30, Y+38	; 0x26
    162a:	ff a1       	ldd	r31, Y+39	; 0x27
    162c:	80 91 d9 04 	lds	r24, 0x04D9
    1630:	90 91 da 04 	lds	r25, 0x04DA
    1634:	e8 17       	cp	r30, r24
    1636:	f9 07       	cpc	r31, r25
    1638:	08 f0       	brcs	.+2      	; 0x163c <FILE_PutCh+0x33c>
    163a:	53 c0       	rjmp	.+166    	; 0x16e2 <FILE_PutCh+0x3e2>
                    {
                        dir = (dir_Structure *) &filePtr->fileBuffer[filePtr->bufferIndex_u16];
    163c:	bc 96       	adiw	r30, 0x2c	; 44
    163e:	ec 0f       	add	r30, r28
    1640:	fd 1f       	adc	r31, r29

                        if(filePtr->fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    1642:	d5 01       	movw	r26, r10
    1644:	8c 91       	ld	r24, X
    1646:	88 23       	and	r24, r24
    1648:	11 f0       	breq	.+4      	; 0x164e <FILE_PutCh+0x34e>
                        {                     //indicating end of the directory file list
                            dir->name[0] = 0x00;
    164a:	10 82       	st	Z, r1
                            return;
    164c:	99 c0       	rjmp	.+306    	; 0x1780 <FILE_PutCh+0x480>
                        }

                        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    164e:	80 81       	ld	r24, Z
    1650:	88 23       	and	r24, r24
    1652:	19 f0       	breq	.+6      	; 0x165a <FILE_PutCh+0x35a>
    1654:	85 3e       	cpi	r24, 0xE5	; 229
    1656:	09 f0       	breq	.+2      	; 0x165a <FILE_PutCh+0x35a>
    1658:	3e c0       	rjmp	.+124    	; 0x16d6 <FILE_PutCh+0x3d6>
    165a:	a1 01       	movw	r20, r2
    165c:	cf 01       	movw	r24, r30
                        {
                            for(k=0; k<11; k++)
                                dir->name[k] = filePtr->fileName[k];
    165e:	da 01       	movw	r26, r20
    1660:	2d 91       	ld	r18, X+
    1662:	ad 01       	movw	r20, r26
    1664:	dc 01       	movw	r26, r24
    1666:	2d 93       	st	X+, r18
    1668:	cd 01       	movw	r24, r26
                            return;
                        }

                        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
                        {
                            for(k=0; k<11; k++)
    166a:	44 15       	cp	r20, r4
    166c:	55 05       	cpc	r21, r5
    166e:	b9 f7       	brne	.-18     	; 0x165e <FILE_PutCh+0x35e>
                                dir->name[k] = filePtr->fileName[k];
                            dir->attrib = ATTR_ARCHIVE; //settting file attribute as 'archive'
    1670:	b0 e2       	ldi	r27, 0x20	; 32
    1672:	b3 87       	std	Z+11, r27	; 0x0b
                            dir->NTreserved = 0;            //always set to 0
    1674:	14 86       	std	Z+12, r1	; 0x0c
                            dir->timeTenth = 0;         //always set to 0
    1676:	15 86       	std	Z+13, r1	; 0x0d
                            dir->createTime = file_GetTime();       // time of creation
    1678:	97 86       	std	Z+15, r9	; 0x0f
    167a:	86 86       	std	Z+14, r8	; 0x0e
                            dir->createDate = file_GetDate();       // date of creation
    167c:	d1 8a       	std	Z+17, r13	; 0x11
    167e:	c0 8a       	std	Z+16, r12	; 0x10
                            dir->lastAccessDate = file_GetDate();   // date of last access
    1680:	d3 8a       	std	Z+19, r13	; 0x13
    1682:	c2 8a       	std	Z+18, r12	; 0x12
                            dir->writeTime = file_GetTime();        // time of last write
    1684:	97 8a       	std	Z+23, r9	; 0x17
    1686:	86 8a       	std	Z+22, r8	; 0x16
                            dir->writeDate = file_GetDate();        // date of last write
    1688:	d1 8e       	std	Z+25, r13	; 0x19
    168a:	c0 8e       	std	Z+24, r12	; 0x18
                            dir->firstClusterHI = filePtr->firstClusterHigh;
    168c:	88 a5       	ldd	r24, Y+40	; 0x28
    168e:	99 a5       	ldd	r25, Y+41	; 0x29
    1690:	95 8b       	std	Z+21, r25	; 0x15
    1692:	84 8b       	std	Z+20, r24	; 0x14
                            dir->firstClusterLO = filePtr->firstClusterLow;
    1694:	8a a5       	ldd	r24, Y+42	; 0x2a
    1696:	9b a5       	ldd	r25, Y+43	; 0x2b
    1698:	93 8f       	std	Z+27, r25	; 0x1b
    169a:	82 8f       	std	Z+26, r24	; 0x1a
                            dir->fileSize = filePtr->fileSize;
    169c:	8c 89       	ldd	r24, Y+20	; 0x14
    169e:	9d 89       	ldd	r25, Y+21	; 0x15
    16a0:	ae 89       	ldd	r26, Y+22	; 0x16
    16a2:	bf 89       	ldd	r27, Y+23	; 0x17
    16a4:	84 8f       	std	Z+28, r24	; 0x1c
    16a6:	95 8f       	std	Z+29, r25	; 0x1d
    16a8:	a6 8f       	std	Z+30, r26	; 0x1e
    16aa:	b7 8f       	std	Z+31, r27	; 0x1f

                            SD_writeSingleBlock (filePtr->fileBuffer,filePtr->firstSector + filePtr->sectorIndex);
    16ac:	8c a1       	ldd	r24, Y+36	; 0x24
    16ae:	9d a1       	ldd	r25, Y+37	; 0x25
    16b0:	48 81       	ld	r20, Y
    16b2:	59 81       	ldd	r21, Y+1	; 0x01
    16b4:	6a 81       	ldd	r22, Y+2	; 0x02
    16b6:	7b 81       	ldd	r23, Y+3	; 0x03
    16b8:	48 0f       	add	r20, r24
    16ba:	59 1f       	adc	r21, r25
    16bc:	61 1d       	adc	r22, r1
    16be:	71 1d       	adc	r23, r1
    16c0:	c3 01       	movw	r24, r6
    16c2:	d1 d3       	rcall	.+1954   	; 0x1e66 <SD_writeSingleBlock>
                            filePtr->fileCreatedFlag = 1;
    16c4:	f5 01       	movw	r30, r10
    16c6:	10 83       	st	Z, r17
                            print_DebugMsg("File Created!");
                            freeMemoryUpdate (filePtr->fileBuffer,REMOVE, filePtr->fileSize); //updating free memory count in FSinfo sector
    16c8:	2c 89       	ldd	r18, Y+20	; 0x14
    16ca:	3d 89       	ldd	r19, Y+21	; 0x15
    16cc:	4e 89       	ldd	r20, Y+22	; 0x16
    16ce:	5f 89       	ldd	r21, Y+23	; 0x17
    16d0:	61 e0       	ldi	r22, 0x01	; 1
    16d2:	c3 01       	movw	r24, r6
    16d4:	b1 dd       	rcall	.-1182   	; 0x1238 <freeMemoryUpdate>
                for(filePtr->sectorIndex = 0; filePtr->sectorIndex < sectorPerCluster; filePtr->sectorIndex++)
                {
                    SD_readSingleBlock (filePtr->fileBuffer,filePtr->firstSector + filePtr->sectorIndex);


                    for(filePtr->bufferIndex_u16=0; filePtr->bufferIndex_u16<bytesPerSector; filePtr->bufferIndex_u16+=32)
    16d6:	8e a1       	ldd	r24, Y+38	; 0x26
    16d8:	9f a1       	ldd	r25, Y+39	; 0x27
    16da:	80 96       	adiw	r24, 0x20	; 32
    16dc:	9f a3       	std	Y+39, r25	; 0x27
    16de:	8e a3       	std	Y+38, r24	; 0x26
    16e0:	a3 cf       	rjmp	.-186    	; 0x1628 <FILE_PutCh+0x328>

            while(1)
            {
                filePtr->firstSector = getFirstSector (filePtr->prevCluster);

                for(filePtr->sectorIndex = 0; filePtr->sectorIndex < sectorPerCluster; filePtr->sectorIndex++)
    16e2:	8c a1       	ldd	r24, Y+36	; 0x24
    16e4:	9d a1       	ldd	r25, Y+37	; 0x25
    16e6:	01 96       	adiw	r24, 0x01	; 1
    16e8:	9d a3       	std	Y+37, r25	; 0x25
    16ea:	8c a3       	std	Y+36, r24	; 0x24
    16ec:	86 cf       	rjmp	.-244    	; 0x15fa <FILE_PutCh+0x2fa>
                            freeMemoryUpdate (filePtr->fileBuffer,REMOVE, filePtr->fileSize); //updating free memory count in FSinfo sector
                        }
                    }
                }

                filePtr->cluster = getSetNextCluster (filePtr->fileBuffer,filePtr->prevCluster, GET, 0);
    16ee:	48 85       	ldd	r20, Y+8	; 0x08
    16f0:	59 85       	ldd	r21, Y+9	; 0x09
    16f2:	6a 85       	ldd	r22, Y+10	; 0x0a
    16f4:	7b 85       	ldd	r23, Y+11	; 0x0b
    16f6:	e1 2c       	mov	r14, r1
    16f8:	f1 2c       	mov	r15, r1
    16fa:	87 01       	movw	r16, r14
    16fc:	20 e0       	ldi	r18, 0x00	; 0
    16fe:	c3 01       	movw	r24, r6
    1700:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>
    1704:	6c 83       	std	Y+4, r22	; 0x04
    1706:	7d 83       	std	Y+5, r23	; 0x05
    1708:	8e 83       	std	Y+6, r24	; 0x06
    170a:	9f 83       	std	Y+7, r25	; 0x07

                if(filePtr->cluster > 0x0ffffff6)
    170c:	67 3f       	cpi	r22, 0xF7	; 247
    170e:	ff ef       	ldi	r31, 0xFF	; 255
    1710:	7f 07       	cpc	r23, r31
    1712:	8f 07       	cpc	r24, r31
    1714:	ff e0       	ldi	r31, 0x0F	; 15
    1716:	9f 07       	cpc	r25, r31
    1718:	30 f1       	brcs	.+76     	; 0x1766 <FILE_PutCh+0x466>
                {
                    if(filePtr->cluster == END_OF_CLUSTERS)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    171a:	6f 3f       	cpi	r22, 0xFF	; 255
    171c:	7f 4f       	sbci	r23, 0xFF	; 255
    171e:	8f 4f       	sbci	r24, 0xFF	; 255
    1720:	9f 40       	sbci	r25, 0x0F	; 15
    1722:	71 f5       	brne	.+92     	; 0x1780 <FILE_PutCh+0x480>
                    {
                        filePtr->cluster = searchNextFreeCluster(filePtr->fileBuffer,filePtr->prevCluster); //find next cluster for root directory entries
    1724:	48 85       	ldd	r20, Y+8	; 0x08
    1726:	59 85       	ldd	r21, Y+9	; 0x09
    1728:	6a 85       	ldd	r22, Y+10	; 0x0a
    172a:	7b 85       	ldd	r23, Y+11	; 0x0b
    172c:	c3 01       	movw	r24, r6
    172e:	86 d9       	rcall	.-3316   	; 0xa3c <searchNextFreeCluster>
    1730:	7b 01       	movw	r14, r22
    1732:	8c 01       	movw	r16, r24
    1734:	6c 83       	std	Y+4, r22	; 0x04
    1736:	7d 83       	std	Y+5, r23	; 0x05
    1738:	8e 83       	std	Y+6, r24	; 0x06
    173a:	9f 83       	std	Y+7, r25	; 0x07
                        getSetNextCluster(filePtr->fileBuffer,filePtr->prevCluster, SET, filePtr->cluster); //link the new cluster of root to the previous cluster
    173c:	48 85       	ldd	r20, Y+8	; 0x08
    173e:	59 85       	ldd	r21, Y+9	; 0x09
    1740:	6a 85       	ldd	r22, Y+10	; 0x0a
    1742:	7b 85       	ldd	r23, Y+11	; 0x0b
    1744:	21 e0       	ldi	r18, 0x01	; 1
    1746:	c3 01       	movw	r24, r6
    1748:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>
                        getSetNextCluster(filePtr->fileBuffer,filePtr->cluster, SET, END_OF_CLUSTERS);  //set the new cluster as end of the root directory
    174c:	4c 81       	ldd	r20, Y+4	; 0x04
    174e:	5d 81       	ldd	r21, Y+5	; 0x05
    1750:	6e 81       	ldd	r22, Y+6	; 0x06
    1752:	7f 81       	ldd	r23, Y+7	; 0x07
    1754:	ee 24       	eor	r14, r14
    1756:	ea 94       	dec	r14
    1758:	fe 2c       	mov	r15, r14
    175a:	0f ef       	ldi	r16, 0xFF	; 255
    175c:	1f e0       	ldi	r17, 0x0F	; 15
    175e:	21 e0       	ldi	r18, 0x01	; 1
    1760:	c3 01       	movw	r24, r6
    1762:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>
                    {
                        print_DebugMsg("End of Cluster Chain");
                        return;
                    }
                }
                if(filePtr->cluster == 0)
    1766:	8c 81       	ldd	r24, Y+4	; 0x04
    1768:	9d 81       	ldd	r25, Y+5	; 0x05
    176a:	ae 81       	ldd	r26, Y+6	; 0x06
    176c:	bf 81       	ldd	r27, Y+7	; 0x07
    176e:	00 97       	sbiw	r24, 0x00	; 0
    1770:	a1 05       	cpc	r26, r1
    1772:	b1 05       	cpc	r27, r1
    1774:	29 f0       	breq	.+10     	; 0x1780 <FILE_PutCh+0x480>
                {
                    print_DebugMsg("Error in getting cluster");
                    return;
                }

                filePtr->prevCluster = filePtr->cluster;
    1776:	88 87       	std	Y+8, r24	; 0x08
    1778:	99 87       	std	Y+9, r25	; 0x09
    177a:	aa 87       	std	Y+10, r26	; 0x0a
    177c:	bb 87       	std	Y+11, r27	; 0x0b
            }
    177e:	31 cf       	rjmp	.-414    	; 0x15e2 <FILE_PutCh+0x2e2>
    {
        /* FIle not opened, do not handle the file operation */
    }

    return;
}
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	1f 91       	pop	r17
    1786:	0f 91       	pop	r16
    1788:	ff 90       	pop	r15
    178a:	ef 90       	pop	r14
    178c:	df 90       	pop	r13
    178e:	cf 90       	pop	r12
    1790:	bf 90       	pop	r11
    1792:	af 90       	pop	r10
    1794:	9f 90       	pop	r9
    1796:	8f 90       	pop	r8
    1798:	7f 90       	pop	r7
    179a:	6f 90       	pop	r6
    179c:	5f 90       	pop	r5
    179e:	4f 90       	pop	r4
    17a0:	3f 90       	pop	r3
    17a2:	2f 90       	pop	r2
    17a4:	08 95       	ret

000017a6 <deletefile>:




uint8_t deletefile (char *fileName)
{
    17a6:	2f 92       	push	r2
    17a8:	3f 92       	push	r3
    17aa:	4f 92       	push	r4
    17ac:	5f 92       	push	r5
    17ae:	6f 92       	push	r6
    17b0:	7f 92       	push	r7
    17b2:	8f 92       	push	r8
    17b4:	9f 92       	push	r9
    17b6:	af 92       	push	r10
    17b8:	bf 92       	push	r11
    17ba:	cf 92       	push	r12
    17bc:	df 92       	push	r13
    17be:	ef 92       	push	r14
    17c0:	ff 92       	push	r15
    17c2:	0f 93       	push	r16
    17c4:	1f 93       	push	r17
    17c6:	cf 93       	push	r28
    17c8:	df 93       	push	r29
    17ca:	00 d0       	rcall	.+0      	; 0x17cc <deletefile+0x26>
    17cc:	00 d0       	rcall	.+0      	; 0x17ce <deletefile+0x28>
    17ce:	00 d0       	rcall	.+0      	; 0x17d0 <deletefile+0x2a>
    17d0:	cd b7       	in	r28, 0x3d	; 61
    17d2:	de b7       	in	r29, 0x3e	; 62
    17d4:	1c 01       	movw	r2, r24
    dir_Structure *dir;
    unsigned int i;
    uint8_t j;


    cluster = rootCluster; //root cluster
    17d6:	80 90 df 06 	lds	r8, 0x06DF
    17da:	90 90 e0 06 	lds	r9, 0x06E0
    17de:	a0 90 e1 06 	lds	r10, 0x06E1
    17e2:	b0 90 e2 06 	lds	r11, 0x06E2
    17e6:	ac 01       	movw	r20, r24
    17e8:	45 5f       	subi	r20, 0xF5	; 245
    17ea:	5f 4f       	sbci	r21, 0xFF	; 255
    17ec:	5e 83       	std	Y+6, r21	; 0x06
    17ee:	4d 83       	std	Y+5, r20	; 0x05

    while(1)
    {
        firstSector = getFirstSector (cluster);
    17f0:	c5 01       	movw	r24, r10
    17f2:	b4 01       	movw	r22, r8
    17f4:	0e 94 a7 00 	call	0x14e	; 0x14e <getFirstSector>
    17f8:	69 83       	std	Y+1, r22	; 0x01
    17fa:	7a 83       	std	Y+2, r23	; 0x02
    17fc:	8b 83       	std	Y+3, r24	; 0x03
    17fe:	9c 83       	std	Y+4, r25	; 0x04

        for(sector = 0; sector < sectorPerCluster; sector++)
    1800:	c1 2c       	mov	r12, r1
    1802:	d1 2c       	mov	r13, r1
    1804:	76 01       	movw	r14, r12
    1806:	80 91 e3 06 	lds	r24, 0x06E3
    180a:	90 91 e4 06 	lds	r25, 0x06E4
    180e:	a0 e0       	ldi	r26, 0x00	; 0
    1810:	b0 e0       	ldi	r27, 0x00	; 0
    1812:	c8 16       	cp	r12, r24
    1814:	d9 06       	cpc	r13, r25
    1816:	ea 06       	cpc	r14, r26
    1818:	fb 06       	cpc	r15, r27
    181a:	e8 f5       	brcc	.+122    	; 0x1896 <deletefile+0xf0>
        {
            SD_readSingleBlock (GlobalBuffer,firstSector + sector);
    181c:	49 80       	ldd	r4, Y+1	; 0x01
    181e:	5a 80       	ldd	r5, Y+2	; 0x02
    1820:	6b 80       	ldd	r6, Y+3	; 0x03
    1822:	7c 80       	ldd	r7, Y+4	; 0x04
    1824:	4c 0c       	add	r4, r12
    1826:	5d 1c       	adc	r5, r13
    1828:	6e 1c       	adc	r6, r14
    182a:	7f 1c       	adc	r7, r15
    182c:	b3 01       	movw	r22, r6
    182e:	a2 01       	movw	r20, r4
    1830:	8f ed       	ldi	r24, 0xDF	; 223
    1832:	94 e0       	ldi	r25, 0x04	; 4
    1834:	ed d2       	rcall	.+1498   	; 0x1e10 <SD_readSingleBlock>


            for(i=0; i<bytesPerSector; i+=32)
    1836:	20 91 d9 04 	lds	r18, 0x04D9
    183a:	30 91 da 04 	lds	r19, 0x04DA
    183e:	0f ed       	ldi	r16, 0xDF	; 223
    1840:	14 e0       	ldi	r17, 0x04	; 4
    1842:	80 e0       	ldi	r24, 0x00	; 0
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	82 17       	cp	r24, r18
    1848:	93 07       	cpc	r25, r19
    184a:	f8 f4       	brcc	.+62     	; 0x188a <deletefile+0xe4>
            {
                dir = (dir_Structure *) &GlobalBuffer[i];

                if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    184c:	d8 01       	movw	r26, r16
    184e:	4c 91       	ld	r20, X
    1850:	44 23       	and	r20, r20
    1852:	09 f4       	brne	.+2      	; 0x1856 <deletefile+0xb0>
    1854:	90 c0       	rjmp	.+288    	; 0x1976 <deletefile+0x1d0>
                {
                    print_DebugMsg("File does not exist!");
                    return FAT32_FILE_DELETED_OR_NOT_FOUND;
                }
                if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    1856:	45 3e       	cpi	r20, 0xE5	; 229
    1858:	a1 f0       	breq	.+40     	; 0x1882 <deletefile+0xdc>
    185a:	fc 01       	movw	r30, r24
    185c:	e1 52       	subi	r30, 0x21	; 33
    185e:	fb 4f       	sbci	r31, 0xFB	; 251
    1860:	43 85       	ldd	r20, Z+11	; 0x0b
    1862:	4f 30       	cpi	r20, 0x0F	; 15
    1864:	71 f0       	breq	.+28     	; 0x1882 <deletefile+0xdc>
    1866:	f1 01       	movw	r30, r2
    1868:	b8 01       	movw	r22, r16
                {
                    for(j=0; j<11; j++)
                        if(dir->name[j] != fileName[j]) break;
    186a:	db 01       	movw	r26, r22
    186c:	5d 91       	ld	r21, X+
    186e:	bd 01       	movw	r22, r26
    1870:	41 91       	ld	r20, Z+
    1872:	54 13       	cpse	r21, r20
    1874:	06 c0       	rjmp	.+12     	; 0x1882 <deletefile+0xdc>
                    print_DebugMsg("File does not exist!");
                    return FAT32_FILE_DELETED_OR_NOT_FOUND;
                }
                if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
                {
                    for(j=0; j<11; j++)
    1876:	4d 81       	ldd	r20, Y+5	; 0x05
    1878:	5e 81       	ldd	r21, Y+6	; 0x06
    187a:	e4 17       	cp	r30, r20
    187c:	f5 07       	cpc	r31, r21
    187e:	a9 f7       	brne	.-22     	; 0x186a <deletefile+0xc4>
    1880:	22 c0       	rjmp	.+68     	; 0x18c6 <deletefile+0x120>
        for(sector = 0; sector < sectorPerCluster; sector++)
        {
            SD_readSingleBlock (GlobalBuffer,firstSector + sector);


            for(i=0; i<bytesPerSector; i+=32)
    1882:	80 96       	adiw	r24, 0x20	; 32
    1884:	00 5e       	subi	r16, 0xE0	; 224
    1886:	1f 4f       	sbci	r17, 0xFF	; 255
    1888:	de cf       	rjmp	.-68     	; 0x1846 <deletefile+0xa0>

    while(1)
    {
        firstSector = getFirstSector (cluster);

        for(sector = 0; sector < sectorPerCluster; sector++)
    188a:	8f ef       	ldi	r24, 0xFF	; 255
    188c:	c8 1a       	sub	r12, r24
    188e:	d8 0a       	sbc	r13, r24
    1890:	e8 0a       	sbc	r14, r24
    1892:	f8 0a       	sbc	r15, r24
    1894:	b8 cf       	rjmp	.-144    	; 0x1806 <deletefile+0x60>
                    }
                }
            }
        }

        cluster = getSetNextCluster (GlobalBuffer,cluster, GET, 0);
    1896:	e1 2c       	mov	r14, r1
    1898:	f1 2c       	mov	r15, r1
    189a:	87 01       	movw	r16, r14
    189c:	20 e0       	ldi	r18, 0x00	; 0
    189e:	b5 01       	movw	r22, r10
    18a0:	a4 01       	movw	r20, r8
    18a2:	8f ed       	ldi	r24, 0xDF	; 223
    18a4:	94 e0       	ldi	r25, 0x04	; 4
    18a6:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>
    18aa:	4b 01       	movw	r8, r22
    18ac:	5c 01       	movw	r10, r24

        if((cluster > 0x0ffffff6) || (cluster ==0))
    18ae:	dc 01       	movw	r26, r24
    18b0:	cb 01       	movw	r24, r22
    18b2:	01 97       	sbiw	r24, 0x01	; 1
    18b4:	a1 09       	sbc	r26, r1
    18b6:	b1 09       	sbc	r27, r1
    18b8:	86 3f       	cpi	r24, 0xF6	; 246
    18ba:	9f 4f       	sbci	r25, 0xFF	; 255
    18bc:	af 4f       	sbci	r26, 0xFF	; 255
    18be:	bf 40       	sbci	r27, 0x0F	; 15
    18c0:	08 f4       	brcc	.+2      	; 0x18c4 <deletefile+0x11e>
    18c2:	96 cf       	rjmp	.-212    	; 0x17f0 <deletefile+0x4a>
    18c4:	58 c0       	rjmp	.+176    	; 0x1976 <deletefile+0x1d0>
                    for(j=0; j<11; j++)
                        if(dir->name[j] != fileName[j]) break;
                    if(j == 11)
                    {
                        print_DebugMsg("Deleting..");
                        firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    18c6:	d8 01       	movw	r26, r16
    18c8:	54 96       	adiw	r26, 0x14	; 20
    18ca:	8d 90       	ld	r8, X+
    18cc:	9c 90       	ld	r9, X
    18ce:	55 97       	sbiw	r26, 0x15	; 21
    18d0:	a1 2c       	mov	r10, r1
    18d2:	b1 2c       	mov	r11, r1
    18d4:	d4 01       	movw	r26, r8
    18d6:	99 27       	eor	r25, r25
    18d8:	88 27       	eor	r24, r24
    18da:	f8 01       	movw	r30, r16
    18dc:	82 8c       	ldd	r8, Z+26	; 0x1a
    18de:	93 8c       	ldd	r9, Z+27	; 0x1b
    18e0:	a1 2c       	mov	r10, r1
    18e2:	b1 2c       	mov	r11, r1
    18e4:	88 2a       	or	r8, r24
    18e6:	99 2a       	or	r9, r25
    18e8:	aa 2a       	or	r10, r26
    18ea:	bb 2a       	or	r11, r27

                        //mark file as 'deleted' in FAT table
                        dir->name[0] = DELETED;
    18ec:	85 ee       	ldi	r24, 0xE5	; 229
    18ee:	80 83       	st	Z, r24
                        SD_writeSingleBlock (GlobalBuffer,firstSector+sector);
    18f0:	b3 01       	movw	r22, r6
    18f2:	a2 01       	movw	r20, r4
    18f4:	8f ed       	ldi	r24, 0xDF	; 223
    18f6:	94 e0       	ldi	r25, 0x04	; 4
    18f8:	b6 d2       	rcall	.+1388   	; 0x1e66 <SD_writeSingleBlock>

                        freeMemoryUpdate (GlobalBuffer,ADD, dir->fileSize);
    18fa:	d8 01       	movw	r26, r16
    18fc:	5c 96       	adiw	r26, 0x1c	; 28
    18fe:	2d 91       	ld	r18, X+
    1900:	3d 91       	ld	r19, X+
    1902:	4d 91       	ld	r20, X+
    1904:	5c 91       	ld	r21, X
    1906:	5f 97       	sbiw	r26, 0x1f	; 31
    1908:	60 e0       	ldi	r22, 0x00	; 0
    190a:	8f ed       	ldi	r24, 0xDF	; 223
    190c:	94 e0       	ldi	r25, 0x04	; 4
    190e:	94 dc       	rcall	.-1752   	; 0x1238 <freeMemoryUpdate>

                        //update next free cluster entry in FSinfo sector
                        cluster = getSetFreeCluster (GlobalBuffer,NEXT_FREE, GET, 0);
    1910:	00 e0       	ldi	r16, 0x00	; 0
    1912:	10 e0       	ldi	r17, 0x00	; 0
    1914:	98 01       	movw	r18, r16
    1916:	40 e0       	ldi	r20, 0x00	; 0
    1918:	62 e0       	ldi	r22, 0x02	; 2
    191a:	8f ed       	ldi	r24, 0xDF	; 223
    191c:	94 e0       	ldi	r25, 0x04	; 4
    191e:	0e 94 c9 02 	call	0x592	; 0x592 <getSetFreeCluster>
                        if(firstCluster < cluster)
    1922:	86 16       	cp	r8, r22
    1924:	97 06       	cpc	r9, r23
    1926:	a8 06       	cpc	r10, r24
    1928:	b9 06       	cpc	r11, r25
    192a:	40 f4       	brcc	.+16     	; 0x193c <deletefile+0x196>
                            getSetFreeCluster (GlobalBuffer,NEXT_FREE, SET, firstCluster);
    192c:	95 01       	movw	r18, r10
    192e:	84 01       	movw	r16, r8
    1930:	41 e0       	ldi	r20, 0x01	; 1
    1932:	62 e0       	ldi	r22, 0x02	; 2
    1934:	8f ed       	ldi	r24, 0xDF	; 223
    1936:	94 e0       	ldi	r25, 0x04	; 4
    1938:	0e 94 c9 02 	call	0x592	; 0x592 <getSetFreeCluster>

                        //mark all the clusters allocated to the file as 'free'
                        while(1)
                        {
                            nextCluster = getSetNextCluster(GlobalBuffer,firstCluster, GET, 0);
    193c:	e1 2c       	mov	r14, r1
    193e:	f1 2c       	mov	r15, r1
    1940:	87 01       	movw	r16, r14
    1942:	20 e0       	ldi	r18, 0x00	; 0
    1944:	b5 01       	movw	r22, r10
    1946:	a4 01       	movw	r20, r8
    1948:	8f ed       	ldi	r24, 0xDF	; 223
    194a:	94 e0       	ldi	r25, 0x04	; 4
    194c:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>
    1950:	6b 01       	movw	r12, r22
    1952:	3c 01       	movw	r6, r24
                            getSetNextCluster(GlobalBuffer,firstCluster, SET, 0);
    1954:	21 e0       	ldi	r18, 0x01	; 1
    1956:	b5 01       	movw	r22, r10
    1958:	a4 01       	movw	r20, r8
    195a:	8f ed       	ldi	r24, 0xDF	; 223
    195c:	94 e0       	ldi	r25, 0x04	; 4
    195e:	0e 94 c4 00 	call	0x188	; 0x188 <getSetNextCluster>
    1962:	46 01       	movw	r8, r12
    1964:	53 01       	movw	r10, r6
                            if(nextCluster > 0x0ffffff6)
    1966:	57 ef       	ldi	r21, 0xF7	; 247
    1968:	85 16       	cp	r8, r21
    196a:	5f ef       	ldi	r21, 0xFF	; 255
    196c:	95 06       	cpc	r9, r21
    196e:	a5 06       	cpc	r10, r21
    1970:	5f e0       	ldi	r21, 0x0F	; 15
    1972:	b5 06       	cpc	r11, r21
    1974:	18 f3       	brcs	.-58     	; 0x193c <deletefile+0x196>
        {
            print_DebugMsg("Error in getting cluster");
            return FAT32_FILE_DELETED_OR_NOT_FOUND;
        }
    }
}
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	26 96       	adiw	r28, 0x06	; 6
    197a:	0f b6       	in	r0, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	de bf       	out	0x3e, r29	; 62
    1980:	0f be       	out	0x3f, r0	; 63
    1982:	cd bf       	out	0x3d, r28	; 61
    1984:	df 91       	pop	r29
    1986:	cf 91       	pop	r28
    1988:	1f 91       	pop	r17
    198a:	0f 91       	pop	r16
    198c:	ff 90       	pop	r15
    198e:	ef 90       	pop	r14
    1990:	df 90       	pop	r13
    1992:	cf 90       	pop	r12
    1994:	bf 90       	pop	r11
    1996:	af 90       	pop	r10
    1998:	9f 90       	pop	r9
    199a:	8f 90       	pop	r8
    199c:	7f 90       	pop	r7
    199e:	6f 90       	pop	r6
    19a0:	5f 90       	pop	r5
    19a2:	4f 90       	pop	r4
    19a4:	3f 90       	pop	r3
    19a6:	2f 90       	pop	r2
    19a8:	08 95       	ret

000019aa <FILE_Delete>:

 * description :
                 This functions deletes the file from SD card .
 ******************************************************************************************************************/
uint8_t FILE_Delete(char *fileName)
{
    19aa:	cf 93       	push	r28
    19ac:	df 93       	push	r29
    19ae:	cd b7       	in	r28, 0x3d	; 61
    19b0:	de b7       	in	r29, 0x3e	; 62
    19b2:	64 97       	sbiw	r28, 0x14	; 20
    19b4:	0f b6       	in	r0, 0x3f	; 63
    19b6:	f8 94       	cli
    19b8:	de bf       	out	0x3e, r29	; 62
    19ba:	0f be       	out	0x3f, r0	; 63
    19bc:	cd bf       	out	0x3d, r28	; 61
    uint8_t returnStatus,i;
    char localfileName[20];
    strcpy(localfileName,fileName);
    19be:	bc 01       	movw	r22, r24
    19c0:	ce 01       	movw	r24, r28
    19c2:	01 96       	adiw	r24, 0x01	; 1
    19c4:	e2 d7       	rcall	.+4036   	; 0x298a <strcpy>

    returnStatus = convertFileName (localfileName);
    19c6:	ce 01       	movw	r24, r28
    19c8:	01 96       	adiw	r24, 0x01	; 1
    19ca:	b8 d8       	rcall	.-3728   	; 0xb3c <convertFileName>

    if(returnStatus == FAT32_VALID_FILE_NAME)
    19cc:	83 30       	cpi	r24, 0x03	; 3
    19ce:	e1 f4       	brne	.+56     	; 0x1a08 <FILE_Delete+0x5e>
    {
        print_DebugMsg("Searching for Opened File");
        for(i=0;i<C_MaxFilesOpening_U8;i++)
        {
            if(fatMappingTable[i].fileOpenedFlag == TRUE)
    19d0:	80 91 18 09 	lds	r24, 0x0918
    19d4:	81 30       	cpi	r24, 0x01	; 1
    19d6:	39 f4       	brne	.+14     	; 0x19e6 <FILE_Delete+0x3c>
            {
                /* Check the file to be deleted is already opened */
                if(strcmp(localfileName,fatMappingTable[i].fileName)==0)
    19d8:	6d e1       	ldi	r22, 0x1D	; 29
    19da:	79 e0       	ldi	r23, 0x09	; 9
    19dc:	ce 01       	movw	r24, r28
    19de:	01 96       	adiw	r24, 0x01	; 1
    19e0:	cb d7       	rcall	.+3990   	; 0x2978 <strcmp>
    19e2:	89 2b       	or	r24, r25
    19e4:	81 f0       	breq	.+32     	; 0x1a06 <FILE_Delete+0x5c>
    if(returnStatus == FAT32_VALID_FILE_NAME)
    {
        print_DebugMsg("Searching for Opened File");
        for(i=0;i<C_MaxFilesOpening_U8;i++)
        {
            if(fatMappingTable[i].fileOpenedFlag == TRUE)
    19e6:	80 91 56 0b 	lds	r24, 0x0B56
    19ea:	81 30       	cpi	r24, 0x01	; 1
    19ec:	39 f4       	brne	.+14     	; 0x19fc <FILE_Delete+0x52>
            {
                /* Check the file to be deleted is already opened */
                if(strcmp(localfileName,fatMappingTable[i].fileName)==0)
    19ee:	6b e5       	ldi	r22, 0x5B	; 91
    19f0:	7b e0       	ldi	r23, 0x0B	; 11
    19f2:	ce 01       	movw	r24, r28
    19f4:	01 96       	adiw	r24, 0x01	; 1
    19f6:	c0 d7       	rcall	.+3968   	; 0x2978 <strcmp>
    19f8:	89 2b       	or	r24, r25
    19fa:	29 f0       	breq	.+10     	; 0x1a06 <FILE_Delete+0x5c>
            returnStatus = FAT32_FILE_OPENED_CANNOT_BE_DELETED;
        }
        else
        {
            print_DebugMsg("Deleting File");
            deletefile(localfileName);
    19fc:	ce 01       	movw	r24, r28
    19fe:	01 96       	adiw	r24, 0x01	; 1
    1a00:	d2 de       	rcall	.-604    	; 0x17a6 <deletefile>
            returnStatus = FAT32_FILE_DELETED_OR_NOT_FOUND;
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	01 c0       	rjmp	.+2      	; 0x1a08 <FILE_Delete+0x5e>
            }
        }

        if(i<C_MaxFilesOpening_U8)
        {
            returnStatus = FAT32_FILE_OPENED_CANNOT_BE_DELETED;
    1a06:	86 e0       	ldi	r24, 0x06	; 6
            returnStatus = FAT32_FILE_DELETED_OR_NOT_FOUND;
        }
    }

    return returnStatus;
}
    1a08:	64 96       	adiw	r28, 0x14	; 20
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	de bf       	out	0x3e, r29	; 62
    1a10:	0f be       	out	0x3f, r0	; 63
    1a12:	cd bf       	out	0x3d, r28	; 61
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	08 95       	ret

00001a1a <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
    1a1a:	98 2f       	mov	r25, r24
    1a1c:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    1a1e:	e8 2f       	mov	r30, r24
    1a20:	e6 95       	lsr	r30
    1a22:	e6 95       	lsr	r30
    1a24:	e6 95       	lsr	r30
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
    1a26:	4e 2f       	mov	r20, r30
    1a28:	50 e0       	ldi	r21, 0x00	; 0
    1a2a:	47 30       	cpi	r20, 0x07	; 7
    1a2c:	51 05       	cpc	r21, r1
    1a2e:	08 f0       	brcs	.+2      	; 0x1a32 <GPIO_PinDirection+0x18>
    1a30:	c4 c0       	rjmp	.+392    	; 0x1bba <GPIO_PinDirection+0x1a0>
    1a32:	fa 01       	movw	r30, r20
    1a34:	ea 5b       	subi	r30, 0xBA	; 186
    1a36:	ff 4f       	sbci	r31, 0xFF	; 255
    1a38:	77 c7       	rjmp	.+3822   	; 0x2928 <__tablejump2__>
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
    1a3a:	4a b3       	in	r20, 0x1a	; 26
    1a3c:	66 23       	and	r22, r22
    1a3e:	59 f0       	breq	.+22     	; 0x1a56 <GPIO_PinDirection+0x3c>
    1a40:	21 e0       	ldi	r18, 0x01	; 1
    1a42:	30 e0       	ldi	r19, 0x00	; 0
    1a44:	b9 01       	movw	r22, r18
    1a46:	02 c0       	rjmp	.+4      	; 0x1a4c <GPIO_PinDirection+0x32>
    1a48:	66 0f       	add	r22, r22
    1a4a:	77 1f       	adc	r23, r23
    1a4c:	9a 95       	dec	r25
    1a4e:	e2 f7       	brpl	.-8      	; 0x1a48 <GPIO_PinDirection+0x2e>
    1a50:	cb 01       	movw	r24, r22
    1a52:	84 2b       	or	r24, r20
    1a54:	0b c0       	rjmp	.+22     	; 0x1a6c <GPIO_PinDirection+0x52>
    1a56:	21 e0       	ldi	r18, 0x01	; 1
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	b9 01       	movw	r22, r18
    1a5c:	02 c0       	rjmp	.+4      	; 0x1a62 <GPIO_PinDirection+0x48>
    1a5e:	66 0f       	add	r22, r22
    1a60:	77 1f       	adc	r23, r23
    1a62:	9a 95       	dec	r25
    1a64:	e2 f7       	brpl	.-8      	; 0x1a5e <GPIO_PinDirection+0x44>
    1a66:	cb 01       	movw	r24, r22
    1a68:	80 95       	com	r24
    1a6a:	84 23       	and	r24, r20
    1a6c:	8a bb       	out	0x1a, r24	; 26
    1a6e:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
    1a70:	47 b3       	in	r20, 0x17	; 23
    1a72:	66 23       	and	r22, r22
    1a74:	59 f0       	breq	.+22     	; 0x1a8c <GPIO_PinDirection+0x72>
    1a76:	21 e0       	ldi	r18, 0x01	; 1
    1a78:	30 e0       	ldi	r19, 0x00	; 0
    1a7a:	b9 01       	movw	r22, r18
    1a7c:	02 c0       	rjmp	.+4      	; 0x1a82 <GPIO_PinDirection+0x68>
    1a7e:	66 0f       	add	r22, r22
    1a80:	77 1f       	adc	r23, r23
    1a82:	9a 95       	dec	r25
    1a84:	e2 f7       	brpl	.-8      	; 0x1a7e <GPIO_PinDirection+0x64>
    1a86:	cb 01       	movw	r24, r22
    1a88:	84 2b       	or	r24, r20
    1a8a:	0b c0       	rjmp	.+22     	; 0x1aa2 <GPIO_PinDirection+0x88>
    1a8c:	21 e0       	ldi	r18, 0x01	; 1
    1a8e:	30 e0       	ldi	r19, 0x00	; 0
    1a90:	b9 01       	movw	r22, r18
    1a92:	02 c0       	rjmp	.+4      	; 0x1a98 <GPIO_PinDirection+0x7e>
    1a94:	66 0f       	add	r22, r22
    1a96:	77 1f       	adc	r23, r23
    1a98:	9a 95       	dec	r25
    1a9a:	e2 f7       	brpl	.-8      	; 0x1a94 <GPIO_PinDirection+0x7a>
    1a9c:	cb 01       	movw	r24, r22
    1a9e:	80 95       	com	r24
    1aa0:	84 23       	and	r24, r20
    1aa2:	87 bb       	out	0x17, r24	; 23
    1aa4:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
    1aa6:	44 b3       	in	r20, 0x14	; 20
    1aa8:	66 23       	and	r22, r22
    1aaa:	59 f0       	breq	.+22     	; 0x1ac2 <GPIO_PinDirection+0xa8>
    1aac:	21 e0       	ldi	r18, 0x01	; 1
    1aae:	30 e0       	ldi	r19, 0x00	; 0
    1ab0:	b9 01       	movw	r22, r18
    1ab2:	02 c0       	rjmp	.+4      	; 0x1ab8 <GPIO_PinDirection+0x9e>
    1ab4:	66 0f       	add	r22, r22
    1ab6:	77 1f       	adc	r23, r23
    1ab8:	9a 95       	dec	r25
    1aba:	e2 f7       	brpl	.-8      	; 0x1ab4 <GPIO_PinDirection+0x9a>
    1abc:	cb 01       	movw	r24, r22
    1abe:	84 2b       	or	r24, r20
    1ac0:	0b c0       	rjmp	.+22     	; 0x1ad8 <GPIO_PinDirection+0xbe>
    1ac2:	21 e0       	ldi	r18, 0x01	; 1
    1ac4:	30 e0       	ldi	r19, 0x00	; 0
    1ac6:	b9 01       	movw	r22, r18
    1ac8:	02 c0       	rjmp	.+4      	; 0x1ace <GPIO_PinDirection+0xb4>
    1aca:	66 0f       	add	r22, r22
    1acc:	77 1f       	adc	r23, r23
    1ace:	9a 95       	dec	r25
    1ad0:	e2 f7       	brpl	.-8      	; 0x1aca <GPIO_PinDirection+0xb0>
    1ad2:	cb 01       	movw	r24, r22
    1ad4:	80 95       	com	r24
    1ad6:	84 23       	and	r24, r20
    1ad8:	84 bb       	out	0x14, r24	; 20
    1ada:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
    1adc:	41 b3       	in	r20, 0x11	; 17
    1ade:	66 23       	and	r22, r22
    1ae0:	59 f0       	breq	.+22     	; 0x1af8 <GPIO_PinDirection+0xde>
    1ae2:	21 e0       	ldi	r18, 0x01	; 1
    1ae4:	30 e0       	ldi	r19, 0x00	; 0
    1ae6:	b9 01       	movw	r22, r18
    1ae8:	02 c0       	rjmp	.+4      	; 0x1aee <GPIO_PinDirection+0xd4>
    1aea:	66 0f       	add	r22, r22
    1aec:	77 1f       	adc	r23, r23
    1aee:	9a 95       	dec	r25
    1af0:	e2 f7       	brpl	.-8      	; 0x1aea <GPIO_PinDirection+0xd0>
    1af2:	cb 01       	movw	r24, r22
    1af4:	84 2b       	or	r24, r20
    1af6:	0b c0       	rjmp	.+22     	; 0x1b0e <GPIO_PinDirection+0xf4>
    1af8:	21 e0       	ldi	r18, 0x01	; 1
    1afa:	30 e0       	ldi	r19, 0x00	; 0
    1afc:	b9 01       	movw	r22, r18
    1afe:	02 c0       	rjmp	.+4      	; 0x1b04 <GPIO_PinDirection+0xea>
    1b00:	66 0f       	add	r22, r22
    1b02:	77 1f       	adc	r23, r23
    1b04:	9a 95       	dec	r25
    1b06:	e2 f7       	brpl	.-8      	; 0x1b00 <GPIO_PinDirection+0xe6>
    1b08:	cb 01       	movw	r24, r22
    1b0a:	80 95       	com	r24
    1b0c:	84 23       	and	r24, r20
    1b0e:	81 bb       	out	0x11, r24	; 17
    1b10:	08 95       	ret
#endif      


#ifdef DDRE
    case 4:
        util_UpdateBit(DDRE,enm_pinNumber,v_pinDirn_u8);
    1b12:	42 b1       	in	r20, 0x02	; 2
    1b14:	66 23       	and	r22, r22
    1b16:	59 f0       	breq	.+22     	; 0x1b2e <GPIO_PinDirection+0x114>
    1b18:	21 e0       	ldi	r18, 0x01	; 1
    1b1a:	30 e0       	ldi	r19, 0x00	; 0
    1b1c:	b9 01       	movw	r22, r18
    1b1e:	02 c0       	rjmp	.+4      	; 0x1b24 <GPIO_PinDirection+0x10a>
    1b20:	66 0f       	add	r22, r22
    1b22:	77 1f       	adc	r23, r23
    1b24:	9a 95       	dec	r25
    1b26:	e2 f7       	brpl	.-8      	; 0x1b20 <GPIO_PinDirection+0x106>
    1b28:	cb 01       	movw	r24, r22
    1b2a:	84 2b       	or	r24, r20
    1b2c:	0b c0       	rjmp	.+22     	; 0x1b44 <GPIO_PinDirection+0x12a>
    1b2e:	21 e0       	ldi	r18, 0x01	; 1
    1b30:	30 e0       	ldi	r19, 0x00	; 0
    1b32:	b9 01       	movw	r22, r18
    1b34:	02 c0       	rjmp	.+4      	; 0x1b3a <GPIO_PinDirection+0x120>
    1b36:	66 0f       	add	r22, r22
    1b38:	77 1f       	adc	r23, r23
    1b3a:	9a 95       	dec	r25
    1b3c:	e2 f7       	brpl	.-8      	; 0x1b36 <GPIO_PinDirection+0x11c>
    1b3e:	cb 01       	movw	r24, r22
    1b40:	80 95       	com	r24
    1b42:	84 23       	and	r24, r20
    1b44:	82 b9       	out	0x02, r24	; 2
    1b46:	08 95       	ret
#endif 

        
#ifdef DDRF
    case 5:
        util_UpdateBit(DDRF,enm_pinNumber,v_pinDirn_u8);
    1b48:	40 91 61 00 	lds	r20, 0x0061
    1b4c:	66 23       	and	r22, r22
    1b4e:	59 f0       	breq	.+22     	; 0x1b66 <GPIO_PinDirection+0x14c>
    1b50:	21 e0       	ldi	r18, 0x01	; 1
    1b52:	30 e0       	ldi	r19, 0x00	; 0
    1b54:	b9 01       	movw	r22, r18
    1b56:	02 c0       	rjmp	.+4      	; 0x1b5c <GPIO_PinDirection+0x142>
    1b58:	66 0f       	add	r22, r22
    1b5a:	77 1f       	adc	r23, r23
    1b5c:	9a 95       	dec	r25
    1b5e:	e2 f7       	brpl	.-8      	; 0x1b58 <GPIO_PinDirection+0x13e>
    1b60:	cb 01       	movw	r24, r22
    1b62:	84 2b       	or	r24, r20
    1b64:	0b c0       	rjmp	.+22     	; 0x1b7c <GPIO_PinDirection+0x162>
    1b66:	21 e0       	ldi	r18, 0x01	; 1
    1b68:	30 e0       	ldi	r19, 0x00	; 0
    1b6a:	b9 01       	movw	r22, r18
    1b6c:	02 c0       	rjmp	.+4      	; 0x1b72 <GPIO_PinDirection+0x158>
    1b6e:	66 0f       	add	r22, r22
    1b70:	77 1f       	adc	r23, r23
    1b72:	9a 95       	dec	r25
    1b74:	e2 f7       	brpl	.-8      	; 0x1b6e <GPIO_PinDirection+0x154>
    1b76:	cb 01       	movw	r24, r22
    1b78:	80 95       	com	r24
    1b7a:	84 23       	and	r24, r20
    1b7c:	80 93 61 00 	sts	0x0061, r24
    1b80:	08 95       	ret
#endif 

        
#ifdef DDRG       
    case 6:
        util_UpdateBit(DDRG,enm_pinNumber,v_pinDirn_u8);
    1b82:	40 91 64 00 	lds	r20, 0x0064
    1b86:	66 23       	and	r22, r22
    1b88:	59 f0       	breq	.+22     	; 0x1ba0 <GPIO_PinDirection+0x186>
    1b8a:	21 e0       	ldi	r18, 0x01	; 1
    1b8c:	30 e0       	ldi	r19, 0x00	; 0
    1b8e:	b9 01       	movw	r22, r18
    1b90:	02 c0       	rjmp	.+4      	; 0x1b96 <GPIO_PinDirection+0x17c>
    1b92:	66 0f       	add	r22, r22
    1b94:	77 1f       	adc	r23, r23
    1b96:	9a 95       	dec	r25
    1b98:	e2 f7       	brpl	.-8      	; 0x1b92 <GPIO_PinDirection+0x178>
    1b9a:	cb 01       	movw	r24, r22
    1b9c:	84 2b       	or	r24, r20
    1b9e:	0b c0       	rjmp	.+22     	; 0x1bb6 <GPIO_PinDirection+0x19c>
    1ba0:	21 e0       	ldi	r18, 0x01	; 1
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	b9 01       	movw	r22, r18
    1ba6:	02 c0       	rjmp	.+4      	; 0x1bac <GPIO_PinDirection+0x192>
    1ba8:	66 0f       	add	r22, r22
    1baa:	77 1f       	adc	r23, r23
    1bac:	9a 95       	dec	r25
    1bae:	e2 f7       	brpl	.-8      	; 0x1ba8 <GPIO_PinDirection+0x18e>
    1bb0:	cb 01       	movw	r24, r22
    1bb2:	80 95       	com	r24
    1bb4:	84 23       	and	r24, r20
    1bb6:	80 93 64 00 	sts	0x0064, r24
    1bba:	08 95       	ret

00001bbc <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
    1bbc:	98 2f       	mov	r25, r24
    1bbe:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    1bc0:	e8 2f       	mov	r30, r24
    1bc2:	e6 95       	lsr	r30
    1bc4:	e6 95       	lsr	r30
    1bc6:	e6 95       	lsr	r30
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
    1bc8:	4e 2f       	mov	r20, r30
    1bca:	50 e0       	ldi	r21, 0x00	; 0
    1bcc:	47 30       	cpi	r20, 0x07	; 7
    1bce:	51 05       	cpc	r21, r1
    1bd0:	08 f0       	brcs	.+2      	; 0x1bd4 <GPIO_PinWrite+0x18>
    1bd2:	c4 c0       	rjmp	.+392    	; 0x1d5c <GPIO_PinWrite+0x1a0>
    1bd4:	fa 01       	movw	r30, r20
    1bd6:	e3 5b       	subi	r30, 0xB3	; 179
    1bd8:	ff 4f       	sbci	r31, 0xFF	; 255
    1bda:	a6 c6       	rjmp	.+3404   	; 0x2928 <__tablejump2__>
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
    1bdc:	4b b3       	in	r20, 0x1b	; 27
    1bde:	66 23       	and	r22, r22
    1be0:	59 f0       	breq	.+22     	; 0x1bf8 <GPIO_PinWrite+0x3c>
    1be2:	21 e0       	ldi	r18, 0x01	; 1
    1be4:	30 e0       	ldi	r19, 0x00	; 0
    1be6:	b9 01       	movw	r22, r18
    1be8:	02 c0       	rjmp	.+4      	; 0x1bee <GPIO_PinWrite+0x32>
    1bea:	66 0f       	add	r22, r22
    1bec:	77 1f       	adc	r23, r23
    1bee:	9a 95       	dec	r25
    1bf0:	e2 f7       	brpl	.-8      	; 0x1bea <GPIO_PinWrite+0x2e>
    1bf2:	cb 01       	movw	r24, r22
    1bf4:	84 2b       	or	r24, r20
    1bf6:	0b c0       	rjmp	.+22     	; 0x1c0e <GPIO_PinWrite+0x52>
    1bf8:	21 e0       	ldi	r18, 0x01	; 1
    1bfa:	30 e0       	ldi	r19, 0x00	; 0
    1bfc:	b9 01       	movw	r22, r18
    1bfe:	02 c0       	rjmp	.+4      	; 0x1c04 <GPIO_PinWrite+0x48>
    1c00:	66 0f       	add	r22, r22
    1c02:	77 1f       	adc	r23, r23
    1c04:	9a 95       	dec	r25
    1c06:	e2 f7       	brpl	.-8      	; 0x1c00 <GPIO_PinWrite+0x44>
    1c08:	cb 01       	movw	r24, r22
    1c0a:	80 95       	com	r24
    1c0c:	84 23       	and	r24, r20
    1c0e:	8b bb       	out	0x1b, r24	; 27
    1c10:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
    1c12:	48 b3       	in	r20, 0x18	; 24
    1c14:	66 23       	and	r22, r22
    1c16:	59 f0       	breq	.+22     	; 0x1c2e <GPIO_PinWrite+0x72>
    1c18:	21 e0       	ldi	r18, 0x01	; 1
    1c1a:	30 e0       	ldi	r19, 0x00	; 0
    1c1c:	b9 01       	movw	r22, r18
    1c1e:	02 c0       	rjmp	.+4      	; 0x1c24 <GPIO_PinWrite+0x68>
    1c20:	66 0f       	add	r22, r22
    1c22:	77 1f       	adc	r23, r23
    1c24:	9a 95       	dec	r25
    1c26:	e2 f7       	brpl	.-8      	; 0x1c20 <GPIO_PinWrite+0x64>
    1c28:	cb 01       	movw	r24, r22
    1c2a:	84 2b       	or	r24, r20
    1c2c:	0b c0       	rjmp	.+22     	; 0x1c44 <GPIO_PinWrite+0x88>
    1c2e:	21 e0       	ldi	r18, 0x01	; 1
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	b9 01       	movw	r22, r18
    1c34:	02 c0       	rjmp	.+4      	; 0x1c3a <GPIO_PinWrite+0x7e>
    1c36:	66 0f       	add	r22, r22
    1c38:	77 1f       	adc	r23, r23
    1c3a:	9a 95       	dec	r25
    1c3c:	e2 f7       	brpl	.-8      	; 0x1c36 <GPIO_PinWrite+0x7a>
    1c3e:	cb 01       	movw	r24, r22
    1c40:	80 95       	com	r24
    1c42:	84 23       	and	r24, r20
    1c44:	88 bb       	out	0x18, r24	; 24
    1c46:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
    1c48:	45 b3       	in	r20, 0x15	; 21
    1c4a:	66 23       	and	r22, r22
    1c4c:	59 f0       	breq	.+22     	; 0x1c64 <GPIO_PinWrite+0xa8>
    1c4e:	21 e0       	ldi	r18, 0x01	; 1
    1c50:	30 e0       	ldi	r19, 0x00	; 0
    1c52:	b9 01       	movw	r22, r18
    1c54:	02 c0       	rjmp	.+4      	; 0x1c5a <GPIO_PinWrite+0x9e>
    1c56:	66 0f       	add	r22, r22
    1c58:	77 1f       	adc	r23, r23
    1c5a:	9a 95       	dec	r25
    1c5c:	e2 f7       	brpl	.-8      	; 0x1c56 <GPIO_PinWrite+0x9a>
    1c5e:	cb 01       	movw	r24, r22
    1c60:	84 2b       	or	r24, r20
    1c62:	0b c0       	rjmp	.+22     	; 0x1c7a <GPIO_PinWrite+0xbe>
    1c64:	21 e0       	ldi	r18, 0x01	; 1
    1c66:	30 e0       	ldi	r19, 0x00	; 0
    1c68:	b9 01       	movw	r22, r18
    1c6a:	02 c0       	rjmp	.+4      	; 0x1c70 <GPIO_PinWrite+0xb4>
    1c6c:	66 0f       	add	r22, r22
    1c6e:	77 1f       	adc	r23, r23
    1c70:	9a 95       	dec	r25
    1c72:	e2 f7       	brpl	.-8      	; 0x1c6c <GPIO_PinWrite+0xb0>
    1c74:	cb 01       	movw	r24, r22
    1c76:	80 95       	com	r24
    1c78:	84 23       	and	r24, r20
    1c7a:	85 bb       	out	0x15, r24	; 21
    1c7c:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
    1c7e:	42 b3       	in	r20, 0x12	; 18
    1c80:	66 23       	and	r22, r22
    1c82:	59 f0       	breq	.+22     	; 0x1c9a <GPIO_PinWrite+0xde>
    1c84:	21 e0       	ldi	r18, 0x01	; 1
    1c86:	30 e0       	ldi	r19, 0x00	; 0
    1c88:	b9 01       	movw	r22, r18
    1c8a:	02 c0       	rjmp	.+4      	; 0x1c90 <GPIO_PinWrite+0xd4>
    1c8c:	66 0f       	add	r22, r22
    1c8e:	77 1f       	adc	r23, r23
    1c90:	9a 95       	dec	r25
    1c92:	e2 f7       	brpl	.-8      	; 0x1c8c <GPIO_PinWrite+0xd0>
    1c94:	cb 01       	movw	r24, r22
    1c96:	84 2b       	or	r24, r20
    1c98:	0b c0       	rjmp	.+22     	; 0x1cb0 <GPIO_PinWrite+0xf4>
    1c9a:	21 e0       	ldi	r18, 0x01	; 1
    1c9c:	30 e0       	ldi	r19, 0x00	; 0
    1c9e:	b9 01       	movw	r22, r18
    1ca0:	02 c0       	rjmp	.+4      	; 0x1ca6 <GPIO_PinWrite+0xea>
    1ca2:	66 0f       	add	r22, r22
    1ca4:	77 1f       	adc	r23, r23
    1ca6:	9a 95       	dec	r25
    1ca8:	e2 f7       	brpl	.-8      	; 0x1ca2 <GPIO_PinWrite+0xe6>
    1caa:	cb 01       	movw	r24, r22
    1cac:	80 95       	com	r24
    1cae:	84 23       	and	r24, r20
    1cb0:	82 bb       	out	0x12, r24	; 18
    1cb2:	08 95       	ret
#endif   


#ifdef PORTE
    case 4:
        util_UpdateBit(PORTE,enm_pinNumber,v_pinValue_u8);
    1cb4:	43 b1       	in	r20, 0x03	; 3
    1cb6:	66 23       	and	r22, r22
    1cb8:	59 f0       	breq	.+22     	; 0x1cd0 <GPIO_PinWrite+0x114>
    1cba:	21 e0       	ldi	r18, 0x01	; 1
    1cbc:	30 e0       	ldi	r19, 0x00	; 0
    1cbe:	b9 01       	movw	r22, r18
    1cc0:	02 c0       	rjmp	.+4      	; 0x1cc6 <GPIO_PinWrite+0x10a>
    1cc2:	66 0f       	add	r22, r22
    1cc4:	77 1f       	adc	r23, r23
    1cc6:	9a 95       	dec	r25
    1cc8:	e2 f7       	brpl	.-8      	; 0x1cc2 <GPIO_PinWrite+0x106>
    1cca:	cb 01       	movw	r24, r22
    1ccc:	84 2b       	or	r24, r20
    1cce:	0b c0       	rjmp	.+22     	; 0x1ce6 <GPIO_PinWrite+0x12a>
    1cd0:	21 e0       	ldi	r18, 0x01	; 1
    1cd2:	30 e0       	ldi	r19, 0x00	; 0
    1cd4:	b9 01       	movw	r22, r18
    1cd6:	02 c0       	rjmp	.+4      	; 0x1cdc <GPIO_PinWrite+0x120>
    1cd8:	66 0f       	add	r22, r22
    1cda:	77 1f       	adc	r23, r23
    1cdc:	9a 95       	dec	r25
    1cde:	e2 f7       	brpl	.-8      	; 0x1cd8 <GPIO_PinWrite+0x11c>
    1ce0:	cb 01       	movw	r24, r22
    1ce2:	80 95       	com	r24
    1ce4:	84 23       	and	r24, r20
    1ce6:	83 b9       	out	0x03, r24	; 3
    1ce8:	08 95       	ret
#endif        

        
#ifdef PORTF        
    case 5:
        util_UpdateBit(PORTF,enm_pinNumber,v_pinValue_u8);
    1cea:	40 91 62 00 	lds	r20, 0x0062
    1cee:	66 23       	and	r22, r22
    1cf0:	59 f0       	breq	.+22     	; 0x1d08 <GPIO_PinWrite+0x14c>
    1cf2:	21 e0       	ldi	r18, 0x01	; 1
    1cf4:	30 e0       	ldi	r19, 0x00	; 0
    1cf6:	b9 01       	movw	r22, r18
    1cf8:	02 c0       	rjmp	.+4      	; 0x1cfe <GPIO_PinWrite+0x142>
    1cfa:	66 0f       	add	r22, r22
    1cfc:	77 1f       	adc	r23, r23
    1cfe:	9a 95       	dec	r25
    1d00:	e2 f7       	brpl	.-8      	; 0x1cfa <GPIO_PinWrite+0x13e>
    1d02:	cb 01       	movw	r24, r22
    1d04:	84 2b       	or	r24, r20
    1d06:	0b c0       	rjmp	.+22     	; 0x1d1e <GPIO_PinWrite+0x162>
    1d08:	21 e0       	ldi	r18, 0x01	; 1
    1d0a:	30 e0       	ldi	r19, 0x00	; 0
    1d0c:	b9 01       	movw	r22, r18
    1d0e:	02 c0       	rjmp	.+4      	; 0x1d14 <GPIO_PinWrite+0x158>
    1d10:	66 0f       	add	r22, r22
    1d12:	77 1f       	adc	r23, r23
    1d14:	9a 95       	dec	r25
    1d16:	e2 f7       	brpl	.-8      	; 0x1d10 <GPIO_PinWrite+0x154>
    1d18:	cb 01       	movw	r24, r22
    1d1a:	80 95       	com	r24
    1d1c:	84 23       	and	r24, r20
    1d1e:	80 93 62 00 	sts	0x0062, r24
    1d22:	08 95       	ret
#endif        

        
#ifdef PORTG        
    case 6:
        util_UpdateBit(PORTG,enm_pinNumber,v_pinValue_u8);
    1d24:	40 91 65 00 	lds	r20, 0x0065
    1d28:	66 23       	and	r22, r22
    1d2a:	59 f0       	breq	.+22     	; 0x1d42 <GPIO_PinWrite+0x186>
    1d2c:	21 e0       	ldi	r18, 0x01	; 1
    1d2e:	30 e0       	ldi	r19, 0x00	; 0
    1d30:	b9 01       	movw	r22, r18
    1d32:	02 c0       	rjmp	.+4      	; 0x1d38 <GPIO_PinWrite+0x17c>
    1d34:	66 0f       	add	r22, r22
    1d36:	77 1f       	adc	r23, r23
    1d38:	9a 95       	dec	r25
    1d3a:	e2 f7       	brpl	.-8      	; 0x1d34 <GPIO_PinWrite+0x178>
    1d3c:	cb 01       	movw	r24, r22
    1d3e:	84 2b       	or	r24, r20
    1d40:	0b c0       	rjmp	.+22     	; 0x1d58 <GPIO_PinWrite+0x19c>
    1d42:	21 e0       	ldi	r18, 0x01	; 1
    1d44:	30 e0       	ldi	r19, 0x00	; 0
    1d46:	b9 01       	movw	r22, r18
    1d48:	02 c0       	rjmp	.+4      	; 0x1d4e <GPIO_PinWrite+0x192>
    1d4a:	66 0f       	add	r22, r22
    1d4c:	77 1f       	adc	r23, r23
    1d4e:	9a 95       	dec	r25
    1d50:	e2 f7       	brpl	.-8      	; 0x1d4a <GPIO_PinWrite+0x18e>
    1d52:	cb 01       	movw	r24, r22
    1d54:	80 95       	com	r24
    1d56:	84 23       	and	r24, r20
    1d58:	80 93 65 00 	sts	0x0065, r24
    1d5c:	08 95       	ret

00001d5e <SD_sendCommand>:
    response = SD_sendCommand(ERASE_SELECTED_BLOCKS, 0); //erase all selected blocks
    if(response != 0x00)
        return response;

    return 0; //normal return
}
    1d5e:	cf 92       	push	r12
    1d60:	df 92       	push	r13
    1d62:	ef 92       	push	r14
    1d64:	ff 92       	push	r15
    1d66:	cf 93       	push	r28
    1d68:	df 93       	push	r29
    1d6a:	c8 2f       	mov	r28, r24
    1d6c:	6a 01       	movw	r12, r20
    1d6e:	7b 01       	movw	r14, r22
    1d70:	80 91 d4 04 	lds	r24, 0x04D4
    1d74:	81 11       	cpse	r24, r1
    1d76:	13 c0       	rjmp	.+38     	; 0x1d9e <SD_sendCommand+0x40>
    1d78:	8f ee       	ldi	r24, 0xEF	; 239
    1d7a:	8c 0f       	add	r24, r28
    1d7c:	82 30       	cpi	r24, 0x02	; 2
    1d7e:	40 f0       	brcs	.+16     	; 0x1d90 <SD_sendCommand+0x32>
    1d80:	88 ee       	ldi	r24, 0xE8	; 232
    1d82:	8c 0f       	add	r24, r28
    1d84:	82 30       	cpi	r24, 0x02	; 2
    1d86:	20 f0       	brcs	.+8      	; 0x1d90 <SD_sendCommand+0x32>
    1d88:	80 ee       	ldi	r24, 0xE0	; 224
    1d8a:	8c 0f       	add	r24, r28
    1d8c:	82 30       	cpi	r24, 0x02	; 2
    1d8e:	38 f4       	brcc	.+14     	; 0x1d9e <SD_sendCommand+0x40>
    1d90:	89 e0       	ldi	r24, 0x09	; 9
    1d92:	cc 0c       	add	r12, r12
    1d94:	dd 1c       	adc	r13, r13
    1d96:	ee 1c       	adc	r14, r14
    1d98:	ff 1c       	adc	r15, r15
    1d9a:	8a 95       	dec	r24
    1d9c:	d1 f7       	brne	.-12     	; 0x1d92 <SD_sendCommand+0x34>
    1d9e:	60 e0       	ldi	r22, 0x00	; 0
    1da0:	88 e0       	ldi	r24, 0x08	; 8
    1da2:	0c df       	rcall	.-488    	; 0x1bbc <GPIO_PinWrite>
    1da4:	8c 2f       	mov	r24, r28
    1da6:	80 64       	ori	r24, 0x40	; 64
    1da8:	48 d1       	rcall	.+656    	; 0x203a <SPI_Write>
    1daa:	8f 2d       	mov	r24, r15
    1dac:	46 d1       	rcall	.+652    	; 0x203a <SPI_Write>
    1dae:	8e 2d       	mov	r24, r14
    1db0:	44 d1       	rcall	.+648    	; 0x203a <SPI_Write>
    1db2:	8d 2d       	mov	r24, r13
    1db4:	42 d1       	rcall	.+644    	; 0x203a <SPI_Write>
    1db6:	8c 2d       	mov	r24, r12
    1db8:	40 d1       	rcall	.+640    	; 0x203a <SPI_Write>
    1dba:	c8 30       	cpi	r28, 0x08	; 8
    1dbc:	11 f4       	brne	.+4      	; 0x1dc2 <SD_sendCommand+0x64>
    1dbe:	87 e8       	ldi	r24, 0x87	; 135
    1dc0:	01 c0       	rjmp	.+2      	; 0x1dc4 <SD_sendCommand+0x66>
    1dc2:	85 e9       	ldi	r24, 0x95	; 149
    1dc4:	3a d1       	rcall	.+628    	; 0x203a <SPI_Write>
    1dc6:	f1 2c       	mov	r15, r1
    1dc8:	3f d1       	rcall	.+638    	; 0x2048 <SPI_Read>
    1dca:	d8 2f       	mov	r29, r24
    1dcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dce:	21 f4       	brne	.+8      	; 0x1dd8 <SD_sendCommand+0x7a>
    1dd0:	fa 94       	dec	r15
    1dd2:	f1 10       	cpse	r15, r1
    1dd4:	f9 cf       	rjmp	.-14     	; 0x1dc8 <SD_sendCommand+0x6a>
    1dd6:	10 c0       	rjmp	.+32     	; 0x1df8 <SD_sendCommand+0x9a>
    1dd8:	81 11       	cpse	r24, r1
    1dda:	0e c0       	rjmp	.+28     	; 0x1df8 <SD_sendCommand+0x9a>
    1ddc:	ca 33       	cpi	r28, 0x3A	; 58
    1dde:	61 f4       	brne	.+24     	; 0x1df8 <SD_sendCommand+0x9a>
    1de0:	33 d1       	rcall	.+614    	; 0x2048 <SPI_Read>
    1de2:	86 ff       	sbrs	r24, 6
    1de4:	04 c0       	rjmp	.+8      	; 0x1dee <SD_sendCommand+0x90>
    1de6:	81 e0       	ldi	r24, 0x01	; 1
    1de8:	80 93 d4 04 	sts	0x04D4, r24
    1dec:	02 c0       	rjmp	.+4      	; 0x1df2 <SD_sendCommand+0x94>
    1dee:	10 92 d4 04 	sts	0x04D4, r1
    1df2:	2a d1       	rcall	.+596    	; 0x2048 <SPI_Read>
    1df4:	29 d1       	rcall	.+594    	; 0x2048 <SPI_Read>
    1df6:	28 d1       	rcall	.+592    	; 0x2048 <SPI_Read>
    1df8:	27 d1       	rcall	.+590    	; 0x2048 <SPI_Read>
    1dfa:	61 e0       	ldi	r22, 0x01	; 1
    1dfc:	88 e0       	ldi	r24, 0x08	; 8
    1dfe:	de de       	rcall	.-580    	; 0x1bbc <GPIO_PinWrite>
    1e00:	8d 2f       	mov	r24, r29
    1e02:	df 91       	pop	r29
    1e04:	cf 91       	pop	r28
    1e06:	ff 90       	pop	r15
    1e08:	ef 90       	pop	r14
    1e0a:	df 90       	pop	r13
    1e0c:	cf 90       	pop	r12
    1e0e:	08 95       	ret

00001e10 <SD_readSingleBlock>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_readSingleBlock(char *inputbuffer,uint32_t startBlock)
{
    1e10:	0f 93       	push	r16
    1e12:	1f 93       	push	r17
    1e14:	cf 93       	push	r28
    1e16:	df 93       	push	r29
    1e18:	8c 01       	movw	r16, r24
    unsigned char response;
    uint16_t i, retry=0;

    response = SD_sendCommand(READ_SINGLE_BLOCK, startBlock); //read a Block command
    1e1a:	81 e1       	ldi	r24, 0x11	; 17
    1e1c:	a0 df       	rcall	.-192    	; 0x1d5e <SD_sendCommand>

    if(response != 0x00)
    1e1e:	81 11       	cpse	r24, r1
    1e20:	1d c0       	rjmp	.+58     	; 0x1e5c <SD_readSingleBlock+0x4c>
    {
        return response; //check for SD status: 0x00 - OK (No flags set)
    }

    SPI_EnableChipSelect();
    1e22:	60 e0       	ldi	r22, 0x00	; 0
    1e24:	88 e0       	ldi	r24, 0x08	; 8
    1e26:	ca de       	rcall	.-620    	; 0x1bbc <GPIO_PinWrite>

    retry = 0;
    while(SPI_Read() != 0xfe) //wait for start block token 0xfe (0x11111110)
    1e28:	c0 e0       	ldi	r28, 0x00	; 0
    1e2a:	d0 e0       	ldi	r29, 0x00	; 0
    1e2c:	0d d1       	rcall	.+538    	; 0x2048 <SPI_Read>
    1e2e:	8e 3f       	cpi	r24, 0xFE	; 254
    1e30:	39 f0       	breq	.+14     	; 0x1e40 <SD_readSingleBlock+0x30>
    1e32:	21 97       	sbiw	r28, 0x01	; 1
    {
        if(retry++ > 0xfffe)
    1e34:	d9 f7       	brne	.-10     	; 0x1e2c <SD_readSingleBlock+0x1c>
        {
            SPI_DisableChipSelect();
    1e36:	61 e0       	ldi	r22, 0x01	; 1
    1e38:	88 e0       	ldi	r24, 0x08	; 8
    1e3a:	c0 de       	rcall	.-640    	; 0x1bbc <GPIO_PinWrite>
            return 1; //return if time-out
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	0e c0       	rjmp	.+28     	; 0x1e5c <SD_readSingleBlock+0x4c>
    1e40:	e8 01       	movw	r28, r16
    1e42:	1e 5f       	subi	r17, 0xFE	; 254
        }
    }

    for(i=0; i<512; i++) //read 512 bytes
        inputbuffer[i] = SPI_Read();
    1e44:	01 d1       	rcall	.+514    	; 0x2048 <SPI_Read>
    1e46:	89 93       	st	Y+, r24
            SPI_DisableChipSelect();
            return 1; //return if time-out
        }
    }

    for(i=0; i<512; i++) //read 512 bytes
    1e48:	c0 17       	cp	r28, r16
    1e4a:	d1 07       	cpc	r29, r17
    1e4c:	d9 f7       	brne	.-10     	; 0x1e44 <SD_readSingleBlock+0x34>
        inputbuffer[i] = SPI_Read();

    SPI_Read(); //receive incoming CRC (16-bit), CRC is ignored here
    1e4e:	fc d0       	rcall	.+504    	; 0x2048 <SPI_Read>
    SPI_Read();
    1e50:	fb d0       	rcall	.+502    	; 0x2048 <SPI_Read>

    SPI_Read(); //extra 8 clock pulses
    1e52:	fa d0       	rcall	.+500    	; 0x2048 <SPI_Read>
    SPI_DisableChipSelect();
    1e54:	61 e0       	ldi	r22, 0x01	; 1
    1e56:	88 e0       	ldi	r24, 0x08	; 8
    1e58:	b1 de       	rcall	.-670    	; 0x1bbc <GPIO_PinWrite>

    return 0;
    1e5a:	80 e0       	ldi	r24, 0x00	; 0
}
    1e5c:	df 91       	pop	r29
    1e5e:	cf 91       	pop	r28
    1e60:	1f 91       	pop	r17
    1e62:	0f 91       	pop	r16
    1e64:	08 95       	ret

00001e66 <SD_writeSingleBlock>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_writeSingleBlock(char *inputbuffer,uint32_t startBlock)
{
    1e66:	0f 93       	push	r16
    1e68:	1f 93       	push	r17
    1e6a:	cf 93       	push	r28
    1e6c:	df 93       	push	r29
    1e6e:	8c 01       	movw	r16, r24
    unsigned char response;
    uint16_t i, retry=0;

    response = SD_sendCommand(WRITE_SINGLE_BLOCK, startBlock); //write a Block command
    1e70:	88 e1       	ldi	r24, 0x18	; 24
    1e72:	75 df       	rcall	.-278    	; 0x1d5e <SD_sendCommand>

    if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)
    1e74:	81 11       	cpse	r24, r1
    1e76:	3b c0       	rjmp	.+118    	; 0x1eee <SD_writeSingleBlock+0x88>

    SPI_EnableChipSelect();
    1e78:	60 e0       	ldi	r22, 0x00	; 0
    1e7a:	88 e0       	ldi	r24, 0x08	; 8
    1e7c:	9f de       	rcall	.-706    	; 0x1bbc <GPIO_PinWrite>

    SPI_Write(0xfe);     //Send start block token 0xfe (0x11111110)
    1e7e:	8e ef       	ldi	r24, 0xFE	; 254
    1e80:	dc d0       	rcall	.+440    	; 0x203a <SPI_Write>
    1e82:	e8 01       	movw	r28, r16
    1e84:	1e 5f       	subi	r17, 0xFE	; 254

    for(i=0; i<512; i++)    //send 512 bytes data
        SPI_Write(inputbuffer[i]);
    1e86:	89 91       	ld	r24, Y+
    1e88:	d8 d0       	rcall	.+432    	; 0x203a <SPI_Write>

    SPI_EnableChipSelect();

    SPI_Write(0xfe);     //Send start block token 0xfe (0x11111110)

    for(i=0; i<512; i++)    //send 512 bytes data
    1e8a:	c0 17       	cp	r28, r16
    1e8c:	d1 07       	cpc	r29, r17
    1e8e:	d9 f7       	brne	.-10     	; 0x1e86 <SD_writeSingleBlock+0x20>
        SPI_Write(inputbuffer[i]);

    SPI_Write(0xff);     //transmit dummy CRC (16-bit), CRC is ignored here
    1e90:	8f ef       	ldi	r24, 0xFF	; 255
    1e92:	d3 d0       	rcall	.+422    	; 0x203a <SPI_Write>
    SPI_Write(0xff);
    1e94:	8f ef       	ldi	r24, 0xFF	; 255
    1e96:	d1 d0       	rcall	.+418    	; 0x203a <SPI_Write>

    response = SPI_Read();
    1e98:	d7 d0       	rcall	.+430    	; 0x2048 <SPI_Read>
    1e9a:	c8 2f       	mov	r28, r24

    if( (response & 0x1f) != 0x05) //response= 0xXXX0AAA1 ; AAA='010' - data accepted
    1e9c:	8f 71       	andi	r24, 0x1F	; 31
    1e9e:	85 30       	cpi	r24, 0x05	; 5
    1ea0:	29 f0       	breq	.+10     	; 0x1eac <SD_writeSingleBlock+0x46>
    {                              //AAA='101'-data rejected due to CRC error
        SPI_DisableChipSelect();              //AAA='110'-data rejected due to write error
    1ea2:	61 e0       	ldi	r22, 0x01	; 1
    1ea4:	88 e0       	ldi	r24, 0x08	; 8
    1ea6:	8a de       	rcall	.-748    	; 0x1bbc <GPIO_PinWrite>
        SPI_Write(inputbuffer[i]);

    SPI_Write(0xff);     //transmit dummy CRC (16-bit), CRC is ignored here
    SPI_Write(0xff);

    response = SPI_Read();
    1ea8:	8c 2f       	mov	r24, r28

    if( (response & 0x1f) != 0x05) //response= 0xXXX0AAA1 ; AAA='010' - data accepted
    {                              //AAA='101'-data rejected due to CRC error
        SPI_DisableChipSelect();              //AAA='110'-data rejected due to write error
        return response;
    1eaa:	21 c0       	rjmp	.+66     	; 0x1eee <SD_writeSingleBlock+0x88>
    1eac:	c0 e0       	ldi	r28, 0x00	; 0
    1eae:	d0 e0       	ldi	r29, 0x00	; 0
    }

    while(!SPI_Read()) //wait for SD card to complete writing and get idle
    1eb0:	cb d0       	rcall	.+406    	; 0x2048 <SPI_Read>
    1eb2:	81 11       	cpse	r24, r1
    1eb4:	07 c0       	rjmp	.+14     	; 0x1ec4 <SD_writeSingleBlock+0x5e>
    {
        if(retry++ > 0xfffe)
    1eb6:	21 96       	adiw	r28, 0x01	; 1
    1eb8:	d9 f7       	brne	.-10     	; 0x1eb0 <SD_writeSingleBlock+0x4a>
        {
            SPI_DisableChipSelect();
    1eba:	61 e0       	ldi	r22, 0x01	; 1
    1ebc:	88 e0       	ldi	r24, 0x08	; 8
    1ebe:	7e de       	rcall	.-772    	; 0x1bbc <GPIO_PinWrite>
            return 1;
    1ec0:	81 e0       	ldi	r24, 0x01	; 1
    1ec2:	15 c0       	rjmp	.+42     	; 0x1eee <SD_writeSingleBlock+0x88>
        }
    }

    SPI_DisableChipSelect();
    1ec4:	61 e0       	ldi	r22, 0x01	; 1
    1ec6:	88 e0       	ldi	r24, 0x08	; 8
    1ec8:	79 de       	rcall	.-782    	; 0x1bbc <GPIO_PinWrite>
    SPI_Write(0xff);   //just spend 8 clock cycle delay before reasserting the CS line
    1eca:	8f ef       	ldi	r24, 0xFF	; 255
    1ecc:	b6 d0       	rcall	.+364    	; 0x203a <SPI_Write>
    SPI_EnableChipSelect();         //re-asserting the CS line to verify if card is still busy
    1ece:	60 e0       	ldi	r22, 0x00	; 0
    1ed0:	88 e0       	ldi	r24, 0x08	; 8
    1ed2:	74 de       	rcall	.-792    	; 0x1bbc <GPIO_PinWrite>

    while(!SPI_Read()) //wait for SD card to complete writing and get idle
    1ed4:	b9 d0       	rcall	.+370    	; 0x2048 <SPI_Read>
    1ed6:	81 11       	cpse	r24, r1
    1ed8:	06 c0       	rjmp	.+12     	; 0x1ee6 <SD_writeSingleBlock+0x80>
    {
        if(retry++ > 0xfffe)
    1eda:	ce 01       	movw	r24, r28
    1edc:	01 96       	adiw	r24, 0x01	; 1
    1ede:	21 96       	adiw	r28, 0x01	; 1
    1ee0:	61 f3       	breq	.-40     	; 0x1eba <SD_writeSingleBlock+0x54>
    1ee2:	ec 01       	movw	r28, r24
    1ee4:	f7 cf       	rjmp	.-18     	; 0x1ed4 <SD_writeSingleBlock+0x6e>
        {
            SPI_DisableChipSelect();
            return 1;
        }
    }
    SPI_DisableChipSelect();
    1ee6:	61 e0       	ldi	r22, 0x01	; 1
    1ee8:	88 e0       	ldi	r24, 0x08	; 8
    1eea:	68 de       	rcall	.-816    	; 0x1bbc <GPIO_PinWrite>


    return 0;
    1eec:	80 e0       	ldi	r24, 0x00	; 0
}
    1eee:	df 91       	pop	r29
    1ef0:	cf 91       	pop	r28
    1ef2:	1f 91       	pop	r17
    1ef4:	0f 91       	pop	r16
    1ef6:	08 95       	ret

00001ef8 <init_SdCard>:


uint8_t init_SdCard(uint8_t *cardType)
{
    1ef8:	ef 92       	push	r14
    1efa:	ff 92       	push	r15
    1efc:	0f 93       	push	r16
    1efe:	1f 93       	push	r17
    1f00:	cf 93       	push	r28
    1f02:	df 93       	push	r29
    1f04:	8c 01       	movw	r16, r24
    1f06:	ca e0       	ldi	r28, 0x0A	; 10
    uint8_t  i, response, sd_version;
    uint16_t retry=0 ;


    for(i=0;i<10;i++)
        SPI_Write(0xff);   //80 clock pulses spent before sending the first command
    1f08:	8f ef       	ldi	r24, 0xFF	; 255
    1f0a:	97 d0       	rcall	.+302    	; 0x203a <SPI_Write>
    1f0c:	c1 50       	subi	r28, 0x01	; 1
{
    uint8_t  i, response, sd_version;
    uint16_t retry=0 ;


    for(i=0;i<10;i++)
    1f0e:	e1 f7       	brne	.-8      	; 0x1f08 <init_SdCard+0x10>
        SPI_Write(0xff);   //80 clock pulses spent before sending the first command


    SPI_EnableChipSelect();
    1f10:	60 e0       	ldi	r22, 0x00	; 0
    1f12:	88 e0       	ldi	r24, 0x08	; 8
    1f14:	53 de       	rcall	.-858    	; 0x1bbc <GPIO_PinWrite>
    1f16:	31 e2       	ldi	r19, 0x21	; 33
    1f18:	e3 2e       	mov	r14, r19
    1f1a:	f1 2c       	mov	r15, r1
    do
    {

        response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
    1f1c:	40 e0       	ldi	r20, 0x00	; 0
    1f1e:	50 e0       	ldi	r21, 0x00	; 0
    1f20:	ba 01       	movw	r22, r20
    1f22:	80 e0       	ldi	r24, 0x00	; 0
    1f24:	1c df       	rcall	.-456    	; 0x1d5e <SD_sendCommand>
    1f26:	91 e0       	ldi	r25, 0x01	; 1
    1f28:	e9 1a       	sub	r14, r25
    1f2a:	f1 08       	sbc	r15, r1
        retry++;
        if(retry>0x20)
    1f2c:	09 f4       	brne	.+2      	; 0x1f30 <init_SdCard+0x38>
    1f2e:	52 c0       	rjmp	.+164    	; 0x1fd4 <init_SdCard+0xdc>
            return SDCARD_NOT_DETECTED;   //time out, card not detected

    } while(response != 0x01);
    1f30:	81 30       	cpi	r24, 0x01	; 1
    1f32:	a1 f7       	brne	.-24     	; 0x1f1c <init_SdCard+0x24>

    SPI_DisableChipSelect();
    1f34:	61 e0       	ldi	r22, 0x01	; 1
    1f36:	88 e0       	ldi	r24, 0x08	; 8
    1f38:	41 de       	rcall	.-894    	; 0x1bbc <GPIO_PinWrite>
    SPI_Write (0xff);
    1f3a:	8f ef       	ldi	r24, 0xFF	; 255
    1f3c:	7e d0       	rcall	.+252    	; 0x203a <SPI_Write>
    SPI_Write (0xff);
    1f3e:	8f ef       	ldi	r24, 0xFF	; 255
    1f40:	7c d0       	rcall	.+248    	; 0x203a <SPI_Write>
    1f42:	ee 24       	eor	r14, r14
    1f44:	ea 94       	dec	r14
    1f46:	f1 2c       	mov	r15, r1

    sd_version = 2; //default set to SD compliance with ver2.x;
    //this may change after checking the next command
    do
    {
        response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC card
    1f48:	4a ea       	ldi	r20, 0xAA	; 170
    1f4a:	51 e0       	ldi	r21, 0x01	; 1
    1f4c:	60 e0       	ldi	r22, 0x00	; 0
    1f4e:	70 e0       	ldi	r23, 0x00	; 0
    1f50:	88 e0       	ldi	r24, 0x08	; 8
    1f52:	05 df       	rcall	.-502    	; 0x1d5e <SD_sendCommand>
    1f54:	e1 e0       	ldi	r30, 0x01	; 1
    1f56:	ee 1a       	sub	r14, r30
    1f58:	f1 08       	sbc	r15, r1
        retry++;
        if(retry>0xfe)
    1f5a:	29 f4       	brne	.+10     	; 0x1f66 <init_SdCard+0x6e>
        {

            sd_version = 1;
            *cardType = SDCARD_TYPE_STANDARD;
    1f5c:	81 e0       	ldi	r24, 0x01	; 1
    1f5e:	f8 01       	movw	r30, r16
    1f60:	80 83       	st	Z, r24
        response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC card
        retry++;
        if(retry>0xfe)
        {

            sd_version = 1;
    1f62:	d1 e0       	ldi	r29, 0x01	; 1
    1f64:	03 c0       	rjmp	.+6      	; 0x1f6c <init_SdCard+0x74>
            *cardType = SDCARD_TYPE_STANDARD;
            break;
        } //time out

    }while(response != 0x01);
    1f66:	81 30       	cpi	r24, 0x01	; 1
    1f68:	79 f7       	brne	.-34     	; 0x1f48 <init_SdCard+0x50>
    SPI_Write (0xff);
    SPI_Write (0xff);

    retry = 0;

    sd_version = 2; //default set to SD compliance with ver2.x;
    1f6a:	d2 e0       	ldi	r29, 0x02	; 2
    1f6c:	ee 24       	eor	r14, r14
    1f6e:	ea 94       	dec	r14
    1f70:	f1 2c       	mov	r15, r1

    retry = 0;

    do
    {
        response = SD_sendCommand(APP_CMD,0); //CMD55, must be sent before sending any ACMD command
    1f72:	40 e0       	ldi	r20, 0x00	; 0
    1f74:	50 e0       	ldi	r21, 0x00	; 0
    1f76:	ba 01       	movw	r22, r20
    1f78:	87 e3       	ldi	r24, 0x37	; 55
    1f7a:	f1 de       	rcall	.-542    	; 0x1d5e <SD_sendCommand>
        response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41
    1f7c:	40 e0       	ldi	r20, 0x00	; 0
    1f7e:	50 e0       	ldi	r21, 0x00	; 0
    1f80:	60 e0       	ldi	r22, 0x00	; 0
    1f82:	70 e4       	ldi	r23, 0x40	; 64
    1f84:	89 e2       	ldi	r24, 0x29	; 41
    1f86:	eb de       	rcall	.-554    	; 0x1d5e <SD_sendCommand>
    1f88:	f1 e0       	ldi	r31, 0x01	; 1
    1f8a:	ef 1a       	sub	r14, r31
    1f8c:	f1 08       	sbc	r15, r1

        retry++;
        if(retry>0xfe)
    1f8e:	21 f1       	breq	.+72     	; 0x1fd8 <init_SdCard+0xe0>
        {

            return SDCARD_INIT_FAILED;  //time out, card initialization failed
        }

    }while(response != 0x00);
    1f90:	81 11       	cpse	r24, r1
    1f92:	ef cf       	rjmp	.-34     	; 0x1f72 <init_SdCard+0x7a>


    retry = 0;
    V_SdHighcapacityFlag_u8 = 0;
    1f94:	10 92 d4 04 	sts	0x04D4, r1

    if (sd_version == 2)
    1f98:	d2 30       	cpi	r29, 0x02	; 2
    1f9a:	f9 f4       	brne	.+62     	; 0x1fda <init_SdCard+0xe2>
    1f9c:	ee 24       	eor	r14, r14
    1f9e:	ea 94       	dec	r14
    1fa0:	f1 2c       	mov	r15, r1
    {
        do
        {
            response = SD_sendCommand(READ_OCR,0);
    1fa2:	40 e0       	ldi	r20, 0x00	; 0
    1fa4:	50 e0       	ldi	r21, 0x00	; 0
    1fa6:	ba 01       	movw	r22, r20
    1fa8:	8a e3       	ldi	r24, 0x3A	; 58
    1faa:	d9 de       	rcall	.-590    	; 0x1d5e <SD_sendCommand>
    1fac:	c8 2f       	mov	r28, r24
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	e8 1a       	sub	r14, r24
    1fb2:	f1 08       	sbc	r15, r1
            retry++;
            if(retry>0xfe)
    1fb4:	19 f4       	brne	.+6      	; 0x1fbc <init_SdCard+0xc4>
            {

                *cardType = SDCARD_TYPE_UNKNOWN;
    1fb6:	f8 01       	movw	r30, r16
    1fb8:	10 82       	st	Z, r1
    1fba:	02 c0       	rjmp	.+4      	; 0x1fc0 <init_SdCard+0xc8>
                break;
            } //time out

        }while(response != 0x00);
    1fbc:	c1 11       	cpse	r28, r1
    1fbe:	f1 cf       	rjmp	.-30     	; 0x1fa2 <init_SdCard+0xaa>

        if(V_SdHighcapacityFlag_u8 == 1)
    1fc0:	80 91 d4 04 	lds	r24, 0x04D4
    1fc4:	81 30       	cpi	r24, 0x01	; 1
    1fc6:	11 f4       	brne	.+4      	; 0x1fcc <init_SdCard+0xd4>
        {
            *cardType = SDCARD_TYPE_HIGH_CAPACITY;
    1fc8:	82 e0       	ldi	r24, 0x02	; 2
    1fca:	01 c0       	rjmp	.+2      	; 0x1fce <init_SdCard+0xd6>
        }
        else
        {
            *cardType = SDCARD_TYPE_STANDARD;
    1fcc:	81 e0       	ldi	r24, 0x01	; 1
    1fce:	f8 01       	movw	r30, r16
    1fd0:	80 83       	st	Z, r24
    1fd2:	03 c0       	rjmp	.+6      	; 0x1fda <init_SdCard+0xe2>
    {

        response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
        retry++;
        if(retry>0x20)
            return SDCARD_NOT_DETECTED;   //time out, card not detected
    1fd4:	c1 e0       	ldi	r28, 0x01	; 1
    1fd6:	01 c0       	rjmp	.+2      	; 0x1fda <init_SdCard+0xe2>

        retry++;
        if(retry>0xfe)
        {

            return SDCARD_INIT_FAILED;  //time out, card initialization failed
    1fd8:	c2 e0       	ldi	r28, 0x02	; 2
            *cardType = SDCARD_TYPE_STANDARD;
        }
    }

    return response;
}
    1fda:	8c 2f       	mov	r24, r28
    1fdc:	df 91       	pop	r29
    1fde:	cf 91       	pop	r28
    1fe0:	1f 91       	pop	r17
    1fe2:	0f 91       	pop	r16
    1fe4:	ff 90       	pop	r15
    1fe6:	ef 90       	pop	r14
    1fe8:	08 95       	ret

00001fea <SD_Init>:
 * description :
                 This function is used to initialize the SD card.
                 It returns the initialization status as mentioned above.
 ****************************************************************************************************/
uint8_t SD_Init(uint8_t *cardType)
{
    1fea:	0f 93       	push	r16
    1fec:	1f 93       	push	r17
    1fee:	cf 93       	push	r28
    1ff0:	8c 01       	movw	r16, r24
    uint8_t response,retry=0;

    SPI_Init();
    1ff2:	10 d0       	rcall	.+32     	; 0x2014 <SPI_Init>
    1ff4:	ca e0       	ldi	r28, 0x0A	; 10

    do{
        response = init_SdCard(cardType);
    1ff6:	c8 01       	movw	r24, r16
    1ff8:	7f df       	rcall	.-258    	; 0x1ef8 <init_SdCard>
        retry++;
    }while((response != SDCARD_INIT_SUCCESSFUL) && (retry!=10) );
    1ffa:	88 23       	and	r24, r24
    1ffc:	31 f0       	breq	.+12     	; 0x200a <SD_Init+0x20>
    1ffe:	c1 50       	subi	r28, 0x01	; 1
    2000:	d1 f7       	brne	.-12     	; 0x1ff6 <SD_Init+0xc>
    {
        response = getBootSectorData (); //read boot sector and keep necessary data in global variables
    }

    return response;
}
    2002:	cf 91       	pop	r28
    2004:	1f 91       	pop	r17
    2006:	0f 91       	pop	r16
    2008:	08 95       	ret
    200a:	cf 91       	pop	r28
    200c:	1f 91       	pop	r17
    200e:	0f 91       	pop	r16
    }while((response != SDCARD_INIT_SUCCESSFUL) && (retry!=10) );


    if(response == SDCARD_INIT_SUCCESSFUL)
    {
        response = getBootSectorData (); //read boot sector and keep necessary data in global variables
    2010:	0c 94 34 04 	jmp	0x868	; 0x868 <getBootSectorData>

00002014 <SPI_Init>:
                 SSEL -- P0.16               
 ****************************************************************************************************/
void SPI_Init(void)
{    

    GPIO_PinDirection(SCK_PIN,OUTPUT);        /* Configure SCK,MOSI,SSEl as Output and MISO as Input */ 
    2014:	61 e0       	ldi	r22, 0x01	; 1
    2016:	89 e0       	ldi	r24, 0x09	; 9
    2018:	00 dd       	rcall	.-1536   	; 0x1a1a <GPIO_PinDirection>
    GPIO_PinDirection(MOSI_PIN,OUTPUT);
    201a:	61 e0       	ldi	r22, 0x01	; 1
    201c:	8a e0       	ldi	r24, 0x0A	; 10
    201e:	fd dc       	rcall	.-1542   	; 0x1a1a <GPIO_PinDirection>
    GPIO_PinDirection(MISO_PIN,INPUT);
    2020:	60 e0       	ldi	r22, 0x00	; 0
    2022:	8b e0       	ldi	r24, 0x0B	; 11
    2024:	fa dc       	rcall	.-1548   	; 0x1a1a <GPIO_PinDirection>
    GPIO_PinDirection(SSEL_PIN,OUTPUT);
    2026:	61 e0       	ldi	r22, 0x01	; 1
    2028:	88 e0       	ldi	r24, 0x08	; 8
    202a:	f7 dc       	rcall	.-1554   	; 0x1a1a <GPIO_PinDirection>

    SPI_DisableChipSelect();                  /* Disable the Slave Select */
    202c:	61 e0       	ldi	r22, 0x01	; 1
    202e:	88 e0       	ldi	r24, 0x08	; 8
    2030:	c5 dd       	rcall	.-1142   	; 0x1bbc <GPIO_PinWrite>

    SPCR = 0x53; //setup SPI: Master mode, MSB first, SCK phase low, SCK idle low
    2032:	83 e5       	ldi	r24, 0x53	; 83
    2034:	8d b9       	out	0x0d, r24	; 13
    SPSR = 0x00;
    2036:	1e b8       	out	0x0e, r1	; 14
    2038:	08 95       	ret

0000203a <SPI_Write>:
                 This function is used to send a byte of data through SPI.              
 ****************************************************************************************************/
uint8_t SPI_Write (uint8_t spiData_u8)
{

    SPDR = spiData_u8;
    203a:	8f b9       	out	0x0f, r24	; 15

    // Wait for transmission complete
    while(!(SPSR & (1<<SPIF)));
    203c:	77 9b       	sbis	0x0e, 7	; 14
    203e:	fe cf       	rjmp	.-4      	; 0x203c <SPI_Write+0x2>
    dummy_u8 = SPDR;
    2040:	9f b1       	in	r25, 0x0f	; 15
    2042:	90 93 68 0b 	sts	0x0B68, r25

    return spiData_u8;
}
    2046:	08 95       	ret

00002048 <SPI_Read>:
 ****************************************************************************************************/
uint8_t SPI_Read(void)
{
    uint8_t spiData_u8;

    SPDR = 0xff;
    2048:	8f ef       	ldi	r24, 0xFF	; 255
    204a:	8f b9       	out	0x0f, r24	; 15
    while(!(SPSR & (1<<SPIF)));
    204c:	77 9b       	sbis	0x0e, 7	; 14
    204e:	fe cf       	rjmp	.-4      	; 0x204c <SPI_Read+0x4>
    spiData_u8 = SPDR;
    2050:	8f b1       	in	r24, 0x0f	; 15

    return spiData_u8;
}
    2052:	08 95       	ret

00002054 <UART_SetBaudRate>:
                 the default baudrate of 9600 is set.

            Refer uart.h file for Supported range of baud rates.
 ***************************************************************************************************/
void UART_SetBaudRate(uint8_t v_uartChannel_u8, uint32_t v_baudRate_u32)
{
    2054:	cf 92       	push	r12
    2056:	df 92       	push	r13
    2058:	ef 92       	push	r14
    205a:	ff 92       	push	r15
    205c:	cf 93       	push	r28
    205e:	c8 2f       	mov	r28, r24
    uint16_t RegValue;

    if((v_baudRate_u32 >= C_MinBaudRate_U32) && (v_baudRate_u32<=C_MaxBaudRate_U32))
    2060:	db 01       	movw	r26, r22
    2062:	ca 01       	movw	r24, r20
    2064:	80 56       	subi	r24, 0x60	; 96
    2066:	99 40       	sbci	r25, 0x09	; 9
    2068:	a1 09       	sbc	r26, r1
    206a:	b1 09       	sbc	r27, r1
    206c:	81 3a       	cpi	r24, 0xA1	; 161
    206e:	98 4b       	sbci	r25, 0xB8	; 184
    2070:	a1 40       	sbci	r26, 0x01	; 1
    2072:	b1 05       	cpc	r27, r1
    2074:	88 f4       	brcc	.+34     	; 0x2098 <UART_SetBaudRate+0x44>
    {
        /* Check if the requested baudate is within range,
         If yes then calculate the value to be loaded into baud rate generator. */
        RegValue = M_GetBaudRateGeneratorValue(v_baudRate_u32);
    2076:	a8 ef       	ldi	r26, 0xF8	; 248
    2078:	bf ef       	ldi	r27, 0xFF	; 255
    207a:	9a 01       	movw	r18, r20
    207c:	ab 01       	movw	r20, r22
    207e:	78 d4       	rcall	.+2288   	; 0x2970 <__mulohisi3>
    2080:	7c 5d       	subi	r23, 0xDC	; 220
    2082:	8b 40       	sbci	r24, 0x0B	; 11
    2084:	9f 4f       	sbci	r25, 0xFF	; 255
    2086:	e4 e0       	ldi	r30, 0x04	; 4
    2088:	22 0f       	add	r18, r18
    208a:	33 1f       	adc	r19, r19
    208c:	44 1f       	adc	r20, r20
    208e:	55 1f       	adc	r21, r21
    2090:	ea 95       	dec	r30
    2092:	d1 f7       	brne	.-12     	; 0x2088 <UART_SetBaudRate+0x34>
    2094:	27 d4       	rcall	.+2126   	; 0x28e4 <__udivmodsi4>
    2096:	02 c0       	rjmp	.+4      	; 0x209c <UART_SetBaudRate+0x48>
    }
    else
    {
        /*   Invalid baudrate requested, hence set it to default baudrate of 9600 */
        RegValue = M_GetBaudRateGeneratorValue(9600);
    2098:	27 e6       	ldi	r18, 0x67	; 103
    209a:	30 e0       	ldi	r19, 0x00	; 0
    }

    if(v_uartChannel_u8 == C_UartZero_U8)
    209c:	c1 11       	cpse	r28, r1
    209e:	04 c0       	rjmp	.+8      	; 0x20a8 <UART_SetBaudRate+0x54>
    {
        UBRR0L = util_ExtractByte0to8(RegValue);
    20a0:	29 b9       	out	0x09, r18	; 9
        UBRR0H = util_ExtractByte8to16(RegValue);
    20a2:	30 93 90 00 	sts	0x0090, r19
    20a6:	06 c0       	rjmp	.+12     	; 0x20b4 <UART_SetBaudRate+0x60>
    }
    else if(v_uartChannel_u8 == C_UartOne_U8)
    20a8:	c1 30       	cpi	r28, 0x01	; 1
    20aa:	21 f4       	brne	.+8      	; 0x20b4 <UART_SetBaudRate+0x60>
    {
        UBRR1L = util_ExtractByte0to8(RegValue);
    20ac:	20 93 99 00 	sts	0x0099, r18
        UBRR1H = util_ExtractByte8to16(RegValue);
    20b0:	30 93 98 00 	sts	0x0098, r19
    }
}
    20b4:	cf 91       	pop	r28
    20b6:	ff 90       	pop	r15
    20b8:	ef 90       	pop	r14
    20ba:	df 90       	pop	r13
    20bc:	cf 90       	pop	r12
    20be:	08 95       	ret

000020c0 <UART_Init>:

            Refer uart.h file for Supported(range) baud rates.        
 ***************************************************************************************************/
void UART_Init(uint8_t v_uartChannel_u8, uint32_t v_baudRate_u32)
{
    if(v_uartChannel_u8 == C_UartZero_U8)
    20c0:	81 11       	cpse	r24, r1
    20c2:	08 c0       	rjmp	.+16     	; 0x20d4 <UART_Init+0x14>
    {
        UCSR0B= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
    20c4:	88 e1       	ldi	r24, 0x18	; 24
    20c6:	8a b9       	out	0x0a, r24	; 10
        UCSR0C= (1<<UCSZ1) | (1<<UCSZ0);                // Asynchronous mode 8-bit data and 1-stop bit
    20c8:	86 e0       	ldi	r24, 0x06	; 6
    20ca:	80 93 95 00 	sts	0x0095, r24
        UCSR0A= 0x00;                                   // Clear the UASRT status register
    20ce:	1b b8       	out	0x0b, r1	; 11
        UART_SetBaudRate(C_UartZero_U8,v_baudRate_u32);
    20d0:	80 e0       	ldi	r24, 0x00	; 0
    20d2:	0b c0       	rjmp	.+22     	; 0x20ea <UART_Init+0x2a>
    }
    else if(v_uartChannel_u8 == C_UartOne_U8)
    20d4:	81 30       	cpi	r24, 0x01	; 1
    20d6:	51 f4       	brne	.+20     	; 0x20ec <UART_Init+0x2c>
    {
        UCSR1B= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
    20d8:	88 e1       	ldi	r24, 0x18	; 24
    20da:	80 93 9a 00 	sts	0x009A, r24
        UCSR1C= (1<<UCSZ1) | (1<<UCSZ0);                // Asynchronous mode 8-bit data and 1-stop bit
    20de:	86 e0       	ldi	r24, 0x06	; 6
    20e0:	80 93 9d 00 	sts	0x009D, r24
        UCSR1A= 0x00;                                   // Clear the UASRT status register
    20e4:	10 92 9b 00 	sts	0x009B, r1
        UART_SetBaudRate(C_UartOne_U8,v_baudRate_u32);
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	b4 cf       	rjmp	.-152    	; 0x2054 <UART_SetBaudRate>
    20ec:	08 95       	ret

000020ee <UART_RxChar>:
 ***************************************************************************************************/
char UART_RxChar(uint8_t var_uartChannel_u8)
{
	char ch = 0;

	switch(var_uartChannel_u8)
    20ee:	88 23       	and	r24, r24
    20f0:	19 f0       	breq	.+6      	; 0x20f8 <UART_RxChar+0xa>
    20f2:	81 30       	cpi	r24, 0x01	; 1
    20f4:	29 f0       	breq	.+10     	; 0x2100 <UART_RxChar+0x12>
    20f6:	0b c0       	rjmp	.+22     	; 0x210e <UART_RxChar+0x20>
	{
		case 0:
		while(util_IsBitCleared(UCSR0A,RXC));  // Wait till the data is received
    20f8:	5f 9b       	sbis	0x0b, 7	; 11
    20fa:	fe cf       	rjmp	.-4      	; 0x20f8 <UART_RxChar+0xa>
		ch = UDR0;
    20fc:	8c b1       	in	r24, 0x0c	; 12
    20fe:	08 95       	ret

		break;


		case 1:
		while(util_IsBitCleared(UCSR1A,RXC));  // Wait till the data is received
    2100:	80 91 9b 00 	lds	r24, 0x009B
    2104:	87 ff       	sbrs	r24, 7
    2106:	fc cf       	rjmp	.-8      	; 0x2100 <UART_RxChar+0x12>
		ch = UDR1;
    2108:	80 91 9c 00 	lds	r24, 0x009C
		break;
    210c:	08 95       	ret
 * description :This function is used to receive a char from UART module.
                It waits till a char is received and returns it after reception.
 ***************************************************************************************************/
char UART_RxChar(uint8_t var_uartChannel_u8)
{
	char ch = 0;
    210e:	80 e0       	ldi	r24, 0x00	; 0
		ch = UDR1;
		break;

	}
	return ch;
}
    2110:	08 95       	ret

00002112 <UART_TxChar>:

 * description  :This function is used to transmit a char through UART module.
 ***************************************************************************************************/
void UART_TxChar(uint8_t v_uartChannel_u8, char v_uartData_u8)
{
    if(v_uartChannel_u8 == C_UartZero_U8)
    2112:	81 11       	cpse	r24, r1
    2114:	04 c0       	rjmp	.+8      	; 0x211e <UART_TxChar+0xc>
    {
        while(util_IsBitCleared(UCSR0A,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
    2116:	5d 9b       	sbis	0x0b, 5	; 11
    2118:	fe cf       	rjmp	.-4      	; 0x2116 <UART_TxChar+0x4>
        UDR0 =v_uartData_u8;
    211a:	6c b9       	out	0x0c, r22	; 12
    211c:	08 95       	ret
    }
    else if(v_uartChannel_u8 == C_UartOne_U8)
    211e:	81 30       	cpi	r24, 0x01	; 1
    2120:	31 f4       	brne	.+12     	; 0x212e <UART_TxChar+0x1c>
    {
        while(util_IsBitCleared(UCSR1A,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
    2122:	80 91 9b 00 	lds	r24, 0x009B
    2126:	85 ff       	sbrs	r24, 5
    2128:	fc cf       	rjmp	.-8      	; 0x2122 <UART_TxChar+0x10>
        UDR1 =v_uartData_u8; 
    212a:	60 93 9c 00 	sts	0x009C, r22
    212e:	08 95       	ret

00002130 <UART_TxNumber.part.2>:
                7.(0x12AB,3) then 3-digits ie. 2AB will be transmitted
                8.(0x12AB,6) then 6-digits ie. 0012AB will be transmitted
                9.(0x12AB,C_DefaultDigitsToTransmit_U8) then 12AB will be transmitted.    
 ***************************************************************************************************/
#if ((Enable_UART_TxNumber==1) || (Enable_UART_TxFloatNumber==1) || (Enable_UART_Printf == 1))
void UART_TxNumber(uint8_t v_uartChannel_u8, uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToTransmit_u8)
    2130:	8f 92       	push	r8
    2132:	9f 92       	push	r9
    2134:	af 92       	push	r10
    2136:	bf 92       	push	r11
    2138:	ef 92       	push	r14
    213a:	ff 92       	push	r15
    213c:	0f 93       	push	r16
    213e:	1f 93       	push	r17
    2140:	cf 93       	push	r28
    2142:	df 93       	push	r29
    2144:	e8 2e       	mov	r14, r24
    2146:	4a 01       	movw	r8, r20
    2148:	5b 01       	movw	r10, r22
    214a:	f2 2e       	mov	r15, r18
    {
        while(v_numOfDigitsToTransmit_u8!=0)
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and transmit */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
    214c:	c1 e0       	ldi	r28, 0x01	; 1
    214e:	d0 e0       	ldi	r29, 0x00	; 0
{
    uint8_t i=0,a[10];

    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToTransmit_u8!=0)
    2150:	ff 20       	and	r15, r15
    2152:	d9 f0       	breq	.+54     	; 0x218a <UART_TxNumber.part.2+0x5a>
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and transmit */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
    2154:	8f ef       	ldi	r24, 0xFF	; 255
    2156:	8f 0d       	add	r24, r15
    2158:	8e 01       	movw	r16, r28
    215a:	02 c0       	rjmp	.+4      	; 0x2160 <UART_TxNumber.part.2+0x30>
    215c:	00 0f       	add	r16, r16
    215e:	11 1f       	adc	r17, r17
    2160:	8a 95       	dec	r24
    2162:	e2 f7       	brpl	.-8      	; 0x215c <UART_TxNumber.part.2+0x2c>
    2164:	01 2e       	mov	r0, r17
    2166:	00 0c       	add	r0, r0
    2168:	22 0b       	sbc	r18, r18
    216a:	33 0b       	sbc	r19, r19
    216c:	08 21       	and	r16, r8
    216e:	19 21       	and	r17, r9
    2170:	2a 21       	and	r18, r10
    2172:	3b 21       	and	r19, r11
    2174:	61 e0       	ldi	r22, 0x01	; 1
    2176:	01 2b       	or	r16, r17
    2178:	02 2b       	or	r16, r18
    217a:	03 2b       	or	r16, r19
    217c:	09 f4       	brne	.+2      	; 0x2180 <UART_TxNumber.part.2+0x50>
    217e:	60 e0       	ldi	r22, 0x00	; 0
            UART_TxChar(v_uartChannel_u8,util_Dec2Ascii(i));
    2180:	60 5d       	subi	r22, 0xD0	; 208
    2182:	8e 2d       	mov	r24, r14
    2184:	c6 df       	rcall	.-116    	; 0x2112 <UART_TxChar>
            v_numOfDigitsToTransmit_u8--;
    2186:	fa 94       	dec	r15
    2188:	e3 cf       	rjmp	.-58     	; 0x2150 <UART_TxNumber.part.2+0x20>
            i--;
        }
    }


}
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	1f 91       	pop	r17
    2190:	0f 91       	pop	r16
    2192:	ff 90       	pop	r15
    2194:	ef 90       	pop	r14
    2196:	bf 90       	pop	r11
    2198:	af 90       	pop	r10
    219a:	9f 90       	pop	r9
    219c:	8f 90       	pop	r8
    219e:	08 95       	ret

000021a0 <UART_TxString>:
               1.The ptr_stringPointer_u8 points to the first char of the string
                    and traverses till the end(NULL CHAR) and transmits a char each time
 ***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(uint8_t v_uartChannel_u8, char *ptr_stringPointer_u8)
{
    21a0:	1f 93       	push	r17
    21a2:	cf 93       	push	r28
    21a4:	df 93       	push	r29
    21a6:	18 2f       	mov	r17, r24
    21a8:	eb 01       	movw	r28, r22
    while(*ptr_stringPointer_u8)
    21aa:	69 91       	ld	r22, Y+
    21ac:	66 23       	and	r22, r22
    21ae:	19 f0       	breq	.+6      	; 0x21b6 <UART_TxString+0x16>
        UART_TxChar(v_uartChannel_u8, *ptr_stringPointer_u8++);// Loop through the string and transmit char by char
    21b0:	81 2f       	mov	r24, r17
    21b2:	af df       	rcall	.-162    	; 0x2112 <UART_TxChar>
    21b4:	fa cf       	rjmp	.-12     	; 0x21aa <UART_TxString+0xa>
}
    21b6:	df 91       	pop	r29
    21b8:	cf 91       	pop	r28
    21ba:	1f 91       	pop	r17
    21bc:	08 95       	ret

000021be <UART_RxString>:
    if not required then comment UART_TxChar(ch) in the code.
  2.BackSlash is not taken care.
 ***************************************************************************************************/
#if (Enable_UART_RxString==1)
uint8_t UART_RxString(uint8_t v_uartChannel_u8, char *ptr_string)
{
    21be:	ff 92       	push	r15
    21c0:	0f 93       	push	r16
    21c2:	1f 93       	push	r17
    21c4:	cf 93       	push	r28
    21c6:	df 93       	push	r29
    21c8:	f8 2e       	mov	r15, r24
    21ca:	8b 01       	movw	r16, r22
    char ch;
    uint8_t len = 0;
    21cc:	c0 e0       	ldi	r28, 0x00	; 0
    while(1)
    {
        ch=UART_RxChar(v_uartChannel_u8);    //Receive a char
    21ce:	8f 2d       	mov	r24, r15
    21d0:	8e df       	rcall	.-228    	; 0x20ee <UART_RxChar>
    21d2:	d8 2f       	mov	r29, r24
        UART_TxChar(v_uartChannel_u8,ch);     //Echo back the received char
    21d4:	68 2f       	mov	r22, r24
    21d6:	8f 2d       	mov	r24, r15
    21d8:	9c df       	rcall	.-200    	; 0x2112 <UART_TxChar>

        if((ch=='\r') || (ch=='\n')) //read till enter key is pressed
    21da:	dd 30       	cpi	r29, 0x0D	; 13
    21dc:	11 f0       	breq	.+4      	; 0x21e2 <UART_RxString+0x24>
    21de:	da 30       	cpi	r29, 0x0A	; 10
    21e0:	69 f4       	brne	.+26     	; 0x21fc <UART_RxString+0x3e>
        {   
            if(len!=0)         /* Wait till atleast 1 char is received */              
    21e2:	cc 23       	and	r28, r28
    21e4:	a1 f3       	breq	.-24     	; 0x21ce <UART_RxString+0x10>
            { 
                ptr_string[len]=0;           //once enter key is pressed null terminate the string and break the loop            
    21e6:	f8 01       	movw	r30, r16
    21e8:	ec 0f       	add	r30, r28
    21ea:	f1 1d       	adc	r31, r1
    21ec:	10 82       	st	Z, r1
            ptr_string[len]=ch; //copy the char into string and increment the index
            len++;
        }
    }
    return len;   
}
    21ee:	8c 2f       	mov	r24, r28
    21f0:	df 91       	pop	r29
    21f2:	cf 91       	pop	r28
    21f4:	1f 91       	pop	r17
    21f6:	0f 91       	pop	r16
    21f8:	ff 90       	pop	r15
    21fa:	08 95       	ret
            { 
                ptr_string[len]=0;           //once enter key is pressed null terminate the string and break the loop            
                break;  
            }                   
        }
        else if((ch=='\b') && (len!=0))
    21fc:	d8 30       	cpi	r29, 0x08	; 8
    21fe:	21 f4       	brne	.+8      	; 0x2208 <UART_RxString+0x4a>
    2200:	cc 23       	and	r28, r28
    2202:	11 f0       	breq	.+4      	; 0x2208 <UART_RxString+0x4a>
        {
            len--;    //If backspace is pressed then decrement the index to remove the old char
    2204:	c1 50       	subi	r28, 0x01	; 1
    2206:	e3 cf       	rjmp	.-58     	; 0x21ce <UART_RxString+0x10>
        }
        else
        {
            ptr_string[len]=ch; //copy the char into string and increment the index
    2208:	f8 01       	movw	r30, r16
    220a:	ec 0f       	add	r30, r28
    220c:	f1 1d       	adc	r31, r1
    220e:	d0 83       	st	Z, r29
            len++;
    2210:	cf 5f       	subi	r28, 0xFF	; 255
    2212:	dd cf       	rjmp	.-70     	; 0x21ce <UART_RxString+0x10>

00002214 <UART_TxNumber>:
                8.(0x12AB,6) then 6-digits ie. 0012AB will be transmitted
                9.(0x12AB,C_DefaultDigitsToTransmit_U8) then 12AB will be transmitted.    
 ***************************************************************************************************/
#if ((Enable_UART_TxNumber==1) || (Enable_UART_TxFloatNumber==1) || (Enable_UART_Printf == 1))
void UART_TxNumber(uint8_t v_uartChannel_u8, uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToTransmit_u8)
{
    2214:	4f 92       	push	r4
    2216:	5f 92       	push	r5
    2218:	6f 92       	push	r6
    221a:	7f 92       	push	r7
    221c:	af 92       	push	r10
    221e:	bf 92       	push	r11
    2220:	cf 92       	push	r12
    2222:	df 92       	push	r13
    2224:	ef 92       	push	r14
    2226:	ff 92       	push	r15
    2228:	0f 93       	push	r16
    222a:	1f 93       	push	r17
    222c:	cf 93       	push	r28
    222e:	df 93       	push	r29
    2230:	cd b7       	in	r28, 0x3d	; 61
    2232:	de b7       	in	r29, 0x3e	; 62
    2234:	2a 97       	sbiw	r28, 0x0a	; 10
    2236:	0f b6       	in	r0, 0x3f	; 63
    2238:	f8 94       	cli
    223a:	de bf       	out	0x3e, r29	; 62
    223c:	0f be       	out	0x3f, r0	; 63
    223e:	cd bf       	out	0x3d, r28	; 61
    2240:	b8 2e       	mov	r11, r24
    2242:	a6 2e       	mov	r10, r22
    2244:	ba 01       	movw	r22, r20
    2246:	a9 01       	movw	r20, r18
    uint8_t i=0,a[10];

    if(C_BINARY_U8 == v_numericSystem_u8)
    2248:	82 e0       	ldi	r24, 0x02	; 2
    224a:	a8 12       	cpse	r10, r24
    224c:	17 c0       	rjmp	.+46     	; 0x227c <UART_TxNumber+0x68>
    224e:	20 2f       	mov	r18, r16
    2250:	8b 2d       	mov	r24, r11
            i--;
        }
    }


}
    2252:	2a 96       	adiw	r28, 0x0a	; 10
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	de bf       	out	0x3e, r29	; 62
    225a:	0f be       	out	0x3f, r0	; 63
    225c:	cd bf       	out	0x3d, r28	; 61
    225e:	df 91       	pop	r29
    2260:	cf 91       	pop	r28
    2262:	1f 91       	pop	r17
    2264:	0f 91       	pop	r16
    2266:	ff 90       	pop	r15
    2268:	ef 90       	pop	r14
    226a:	df 90       	pop	r13
    226c:	cf 90       	pop	r12
    226e:	bf 90       	pop	r11
    2270:	af 90       	pop	r10
    2272:	7f 90       	pop	r7
    2274:	6f 90       	pop	r6
    2276:	5f 90       	pop	r5
    2278:	4f 90       	pop	r4
    227a:	5a cf       	rjmp	.-332    	; 0x2130 <UART_TxNumber.part.2>
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
            UART_TxChar(v_uartChannel_u8,util_Dec2Ascii(i));
            v_numOfDigitsToTransmit_u8--;
        }    
    }     
    else if(v_number_u32==0)
    227c:	41 15       	cp	r20, r1
    227e:	51 05       	cpc	r21, r1
    2280:	61 05       	cpc	r22, r1
    2282:	71 05       	cpc	r23, r1
    2284:	49 f0       	breq	.+18     	; 0x2298 <UART_TxNumber+0x84>
    2286:	fe 01       	movw	r30, r28
    2288:	31 96       	adiw	r30, 0x01	; 1
    228a:	6f 01       	movw	r12, r30
    228c:	7f 01       	movw	r14, r30
                First get the remainder and divide the number by 10 each time.

                example for Decimal number:
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
    228e:	4a 2c       	mov	r4, r10
    2290:	51 2c       	mov	r5, r1
    2292:	61 2c       	mov	r6, r1
    2294:	71 2c       	mov	r7, r1
    2296:	2c c0       	rjmp	.+88     	; 0x22f0 <UART_TxNumber+0xdc>
    else if(v_number_u32==0)
    {
        /* If the number is zero then Transmit Specified number of zeros*/
        /*TODO: trsnamit single zero or multiple, Currently single zero is transmitted*/
        // for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
        UART_TxChar(v_uartChannel_u8,'0');
    2298:	60 e3       	ldi	r22, 0x30	; 48
    229a:	8b 2d       	mov	r24, r11
            i--;
        }
    }


}
    229c:	2a 96       	adiw	r28, 0x0a	; 10
    229e:	0f b6       	in	r0, 0x3f	; 63
    22a0:	f8 94       	cli
    22a2:	de bf       	out	0x3e, r29	; 62
    22a4:	0f be       	out	0x3f, r0	; 63
    22a6:	cd bf       	out	0x3d, r28	; 61
    22a8:	df 91       	pop	r29
    22aa:	cf 91       	pop	r28
    22ac:	1f 91       	pop	r17
    22ae:	0f 91       	pop	r16
    22b0:	ff 90       	pop	r15
    22b2:	ef 90       	pop	r14
    22b4:	df 90       	pop	r13
    22b6:	cf 90       	pop	r12
    22b8:	bf 90       	pop	r11
    22ba:	af 90       	pop	r10
    22bc:	7f 90       	pop	r7
    22be:	6f 90       	pop	r6
    22c0:	5f 90       	pop	r5
    22c2:	4f 90       	pop	r4
    else if(v_number_u32==0)
    {
        /* If the number is zero then Transmit Specified number of zeros*/
        /*TODO: trsnamit single zero or multiple, Currently single zero is transmitted*/
        // for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
        UART_TxChar(v_uartChannel_u8,'0');
    22c4:	26 cf       	rjmp	.-436    	; 0x2112 <UART_TxChar>
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToTransmit_u8 */
            if(v_number_u32!=0)
    22c6:	41 15       	cp	r20, r1
    22c8:	51 05       	cpc	r21, r1
    22ca:	61 05       	cpc	r22, r1
    22cc:	71 05       	cpc	r23, r1
    22ce:	a9 f0       	breq	.+42     	; 0x22fa <UART_TxNumber+0xe6>
                First get the remainder and divide the number by 10 each time.

                example for Decimal number:
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
    22d0:	14 2f       	mov	r17, r20
    22d2:	cb 01       	movw	r24, r22
    22d4:	ba 01       	movw	r22, r20
    22d6:	a3 01       	movw	r20, r6
    22d8:	92 01       	movw	r18, r4
    22da:	04 d3       	rcall	.+1544   	; 0x28e4 <__udivmodsi4>
    22dc:	ba 01       	movw	r22, r20
    22de:	a9 01       	movw	r20, r18
    22e0:	a4 9e       	mul	r10, r20
    22e2:	10 19       	sub	r17, r0
    22e4:	11 24       	eor	r1, r1
    22e6:	f7 01       	movw	r30, r14
    22e8:	10 83       	st	Z, r17
    22ea:	ff ef       	ldi	r31, 0xFF	; 255
    22ec:	ef 1a       	sub	r14, r31
    22ee:	ff 0a       	sbc	r15, r31
    22f0:	1e 2d       	mov	r17, r14
    22f2:	1c 19       	sub	r17, r12
        // for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
        UART_TxChar(v_uartChannel_u8,'0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
    22f4:	10 17       	cp	r17, r16
    22f6:	38 f3       	brcs	.-50     	; 0x22c6 <UART_TxNumber+0xb2>
    22f8:	0f c0       	rjmp	.+30     	; 0x2318 <UART_TxNumber+0x104>
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
                v_number_u32=v_number_u32/v_numericSystem_u8;
            }
            else if( (v_numOfDigitsToTransmit_u8 == C_DefaultDigitsToTransmit_U8) ||
    22fa:	0b 30       	cpi	r16, 0x0B	; 11
    22fc:	68 f4       	brcc	.+26     	; 0x2318 <UART_TxNumber+0x104>
            else
            {
                /*In case user expects more digits to be transmitted than the actual digits in number,
                  then update the remaining digits with zero.
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
    22fe:	f7 01       	movw	r30, r14
    2300:	10 82       	st	Z, r1
    2302:	f3 cf       	rjmp	.-26     	; 0x22ea <UART_TxNumber+0xd6>
        }

        while(i)
        { 
            /* Finally get the ascii values of the digits and transmit*/
            UART_TxChar(v_uartChannel_u8,util_Hex2Ascii(a[i-1]));
    2304:	fe 01       	movw	r30, r28
    2306:	e1 0f       	add	r30, r17
    2308:	f1 1d       	adc	r31, r1
    230a:	60 81       	ld	r22, Z
    230c:	6a 30       	cpi	r22, 0x0A	; 10
    230e:	38 f0       	brcs	.+14     	; 0x231e <UART_TxNumber+0x10a>
    2310:	69 5c       	subi	r22, 0xC9	; 201
    2312:	8b 2d       	mov	r24, r11
    2314:	fe de       	rcall	.-516    	; 0x2112 <UART_TxChar>
            i--;
    2316:	11 50       	subi	r17, 0x01	; 1
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
    2318:	11 11       	cpse	r17, r1
    231a:	f4 cf       	rjmp	.-24     	; 0x2304 <UART_TxNumber+0xf0>
    231c:	02 c0       	rjmp	.+4      	; 0x2322 <UART_TxNumber+0x10e>
        { 
            /* Finally get the ascii values of the digits and transmit*/
            UART_TxChar(v_uartChannel_u8,util_Hex2Ascii(a[i-1]));
    231e:	60 5d       	subi	r22, 0xD0	; 208
    2320:	f8 cf       	rjmp	.-16     	; 0x2312 <UART_TxNumber+0xfe>
            i--;
        }
    }


}
    2322:	2a 96       	adiw	r28, 0x0a	; 10
    2324:	0f b6       	in	r0, 0x3f	; 63
    2326:	f8 94       	cli
    2328:	de bf       	out	0x3e, r29	; 62
    232a:	0f be       	out	0x3f, r0	; 63
    232c:	cd bf       	out	0x3d, r28	; 61
    232e:	df 91       	pop	r29
    2330:	cf 91       	pop	r28
    2332:	1f 91       	pop	r17
    2334:	0f 91       	pop	r16
    2336:	ff 90       	pop	r15
    2338:	ef 90       	pop	r14
    233a:	df 90       	pop	r13
    233c:	cf 90       	pop	r12
    233e:	bf 90       	pop	r11
    2340:	af 90       	pop	r10
    2342:	7f 90       	pop	r7
    2344:	6f 90       	pop	r6
    2346:	5f 90       	pop	r5
    2348:	4f 90       	pop	r4
    234a:	08 95       	ret

0000234c <UART_Printf>:
        uint8_t v_Num_u8;
        UART_Printf("num1:%u",(uint16_t)v_Num_u8);       
 ***************************************************************************************************/
#if ( Enable_UART_Printf   == 1 ) 
void UART_Printf(uint8_t v_uartChannel_u8, const char *argList, ...)
{
    234c:	af 92       	push	r10
    234e:	bf 92       	push	r11
    2350:	cf 92       	push	r12
    2352:	df 92       	push	r13
    2354:	ef 92       	push	r14
    2356:	ff 92       	push	r15
    2358:	0f 93       	push	r16
    235a:	1f 93       	push	r17
    235c:	cf 93       	push	r28
    235e:	df 93       	push	r29
    2360:	00 d0       	rcall	.+0      	; 0x2362 <UART_Printf+0x16>
    2362:	00 d0       	rcall	.+0      	; 0x2364 <UART_Printf+0x18>
    2364:	cd b7       	in	r28, 0x3d	; 61
    2366:	de b7       	in	r29, 0x3e	; 62
    2368:	19 89       	ldd	r17, Y+17	; 0x11
    236a:	aa 88       	ldd	r10, Y+18	; 0x12
    236c:	bb 88       	ldd	r11, Y+19	; 0x13
#if (Enable_UART_TxFloatNumber==1)
    double v_floatNum_f32;
#endif  


    va_start(argp, argList);
    236e:	7e 01       	movw	r14, r28
    2370:	84 e1       	ldi	r24, 0x14	; 20
    2372:	e8 0e       	add	r14, r24
    2374:	f1 1c       	adc	r15, r1

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
    2376:	f5 01       	movw	r30, r10
    2378:	60 81       	ld	r22, Z
    237a:	66 23       	and	r22, r22
    237c:	09 f4       	brne	.+2      	; 0x2380 <UART_Printf+0x34>
    237e:	1a c1       	rjmp	.+564    	; 0x25b4 <UART_Printf+0x268>
    {

        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
    2380:	65 32       	cpi	r22, 0x25	; 37
    2382:	09 f0       	breq	.+2      	; 0x2386 <UART_Printf+0x3a>
    2384:	ff c0       	rjmp	.+510    	; 0x2584 <UART_Printf+0x238>
        {
            ptr++;
    2386:	65 01       	movw	r12, r10
    2388:	9f ef       	ldi	r25, 0xFF	; 255
    238a:	c9 1a       	sub	r12, r25
    238c:	d9 0a       	sbc	r13, r25
            ch = *ptr;
    238e:	f5 01       	movw	r30, r10
    2390:	91 81       	ldd	r25, Z+1	; 0x01
            if((ch>=0x30) && (ch<=0x39))
    2392:	80 ed       	ldi	r24, 0xD0	; 208
    2394:	89 0f       	add	r24, r25
    2396:	8a 30       	cpi	r24, 0x0A	; 10
    2398:	08 f0       	brcs	.+2      	; 0x239c <UART_Printf+0x50>
    239a:	af c0       	rjmp	.+350    	; 0x24fa <UART_Printf+0x1ae>
    239c:	00 e0       	ldi	r16, 0x00	; 0
            {
                v_numOfDigitsToTransmit_u8 = 0;
                while((ch>=0x30) && (ch<=0x39))
    239e:	80 ed       	ldi	r24, 0xD0	; 208
    23a0:	89 0f       	add	r24, r25
    23a2:	8a 30       	cpi	r24, 0x0A	; 10
    23a4:	58 f4       	brcc	.+22     	; 0x23bc <UART_Printf+0x70>
                {
                    v_numOfDigitsToTransmit_u8 = (v_numOfDigitsToTransmit_u8 * 10) + (ch-0x30);
    23a6:	fa e0       	ldi	r31, 0x0A	; 10
    23a8:	0f 9f       	mul	r16, r31
    23aa:	80 0d       	add	r24, r0
    23ac:	11 24       	eor	r1, r1
    23ae:	08 2f       	mov	r16, r24
                    ptr++;
    23b0:	8f ef       	ldi	r24, 0xFF	; 255
    23b2:	c8 1a       	sub	r12, r24
    23b4:	d8 0a       	sbc	r13, r24
                    ch = *ptr;
    23b6:	f6 01       	movw	r30, r12
    23b8:	90 81       	ld	r25, Z
    23ba:	f1 cf       	rjmp	.-30     	; 0x239e <UART_Printf+0x52>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    23bc:	98 35       	cpi	r25, 0x58	; 88
    23be:	09 f4       	brne	.+2      	; 0x23c2 <UART_Printf+0x76>
    23c0:	a0 c0       	rjmp	.+320    	; 0x2502 <UART_Printf+0x1b6>
    23c2:	a0 f4       	brcc	.+40     	; 0x23ec <UART_Printf+0xa0>
    23c4:	93 34       	cpi	r25, 0x43	; 67
    23c6:	29 f1       	breq	.+74     	; 0x2412 <UART_Printf+0xc6>
    23c8:	38 f4       	brcc	.+14     	; 0x23d8 <UART_Printf+0x8c>
    23ca:	95 32       	cpi	r25, 0x25	; 37
    23cc:	09 f4       	brne	.+2      	; 0x23d0 <UART_Printf+0x84>
    23ce:	d6 c0       	rjmp	.+428    	; 0x257c <UART_Printf+0x230>
    23d0:	92 34       	cpi	r25, 0x42	; 66
    23d2:	09 f4       	brne	.+2      	; 0x23d6 <UART_Printf+0x8a>
    23d4:	b4 c0       	rjmp	.+360    	; 0x253e <UART_Printf+0x1f2>
    23d6:	d9 c0       	rjmp	.+434    	; 0x258a <UART_Printf+0x23e>
    23d8:	93 35       	cpi	r25, 0x53	; 83
    23da:	09 f4       	brne	.+2      	; 0x23de <UART_Printf+0x92>
    23dc:	c2 c0       	rjmp	.+388    	; 0x2562 <UART_Printf+0x216>
    23de:	95 35       	cpi	r25, 0x55	; 85
    23e0:	09 f4       	brne	.+2      	; 0x23e4 <UART_Printf+0x98>
    23e2:	72 c0       	rjmp	.+228    	; 0x24c8 <UART_Printf+0x17c>
    23e4:	94 34       	cpi	r25, 0x44	; 68
    23e6:	09 f0       	breq	.+2      	; 0x23ea <UART_Printf+0x9e>
    23e8:	d0 c0       	rjmp	.+416    	; 0x258a <UART_Printf+0x23e>
    23ea:	37 c0       	rjmp	.+110    	; 0x245a <UART_Printf+0x10e>
    23ec:	94 36       	cpi	r25, 0x64	; 100
    23ee:	e9 f0       	breq	.+58     	; 0x242a <UART_Printf+0xde>
    23f0:	20 f4       	brcc	.+8      	; 0x23fa <UART_Printf+0xae>
    23f2:	92 36       	cpi	r25, 0x62	; 98
    23f4:	09 f4       	brne	.+2      	; 0x23f8 <UART_Printf+0xac>
    23f6:	96 c0       	rjmp	.+300    	; 0x2524 <UART_Printf+0x1d8>
    23f8:	d9 c0       	rjmp	.+434    	; 0x25ac <UART_Printf+0x260>
    23fa:	95 37       	cpi	r25, 0x75	; 117
    23fc:	09 f4       	brne	.+2      	; 0x2400 <UART_Printf+0xb4>
    23fe:	51 c0       	rjmp	.+162    	; 0x24a2 <UART_Printf+0x156>
    2400:	98 37       	cpi	r25, 0x78	; 120
    2402:	09 f4       	brne	.+2      	; 0x2406 <UART_Printf+0xba>
    2404:	70 c0       	rjmp	.+224    	; 0x24e6 <UART_Printf+0x19a>
    2406:	ab c0       	rjmp	.+342    	; 0x255e <UART_Printf+0x212>
    2408:	99 35       	cpi	r25, 0x59	; 89
    240a:	60 f4       	brcc	.+24     	; 0x2424 <UART_Printf+0xd8>
    240c:	93 34       	cpi	r25, 0x43	; 67
    240e:	09 f0       	breq	.+2      	; 0x2412 <UART_Printf+0xc6>
    2410:	52 c0       	rjmp	.+164    	; 0x24b6 <UART_Printf+0x16a>
            {
            case 'C':
            case 'c':     /* Argument type is of char, hence read char data from the argp */
                ch = va_arg(argp, int);
    2412:	57 01       	movw	r10, r14
    2414:	f2 e0       	ldi	r31, 0x02	; 2
    2416:	af 0e       	add	r10, r31
    2418:	b1 1c       	adc	r11, r1
                UART_TxChar(v_uartChannel_u8,ch);
    241a:	f7 01       	movw	r30, r14
    241c:	60 81       	ld	r22, Z
    241e:	81 2f       	mov	r24, r17
    2420:	78 de       	rcall	.-784    	; 0x2112 <UART_TxChar>
    2422:	a8 c0       	rjmp	.+336    	; 0x2574 <UART_Printf+0x228>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    2424:	94 36       	cpi	r25, 0x64	; 100
    2426:	b9 f5       	brne	.+110    	; 0x2496 <UART_Printf+0x14a>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    2428:	0f ef       	ldi	r16, 0xFF	; 255
                ch = va_arg(argp, int);
                UART_TxChar(v_uartChannel_u8,ch);
                break;

            case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                v_num_s16 = va_arg(argp, sint16_t);
    242a:	57 01       	movw	r10, r14
    242c:	f2 e0       	ldi	r31, 0x02	; 2
    242e:	af 0e       	add	r10, r31
    2430:	b1 1c       	adc	r11, r1
    2432:	f7 01       	movw	r30, r14
    2434:	e0 80       	ld	r14, Z
    2436:	f1 80       	ldd	r15, Z+1	; 0x01
#if (Enable_UART_TxNumber == 1)
                if(v_num_s16<0)
    2438:	f7 fe       	sbrs	r15, 7
    243a:	06 c0       	rjmp	.+12     	; 0x2448 <UART_Printf+0xfc>
                { /* If the number is -ve then display the 2's complement along with '-' sign */ 
                    v_num_s16 = -v_num_s16;
    243c:	f1 94       	neg	r15
    243e:	e1 94       	neg	r14
    2440:	f1 08       	sbc	r15, r1
                    UART_TxChar(v_uartChannel_u8,'-');
    2442:	6d e2       	ldi	r22, 0x2D	; 45
    2444:	81 2f       	mov	r24, r17
    2446:	65 de       	rcall	.-822    	; 0x2112 <UART_TxChar>
                }
                UART_TxNumber(v_uartChannel_u8,C_DECIMAL_U8,v_num_s16,v_numOfDigitsToTransmit_u8);
    2448:	97 01       	movw	r18, r14
    244a:	ff 0c       	add	r15, r15
    244c:	44 0b       	sbc	r20, r20
    244e:	55 0b       	sbc	r21, r21
    2450:	44 c0       	rjmp	.+136    	; 0x24da <UART_Printf+0x18e>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    2452:	94 34       	cpi	r25, 0x44	; 68
    2454:	09 f0       	breq	.+2      	; 0x2458 <UART_Printf+0x10c>
    2456:	99 c0       	rjmp	.+306    	; 0x258a <UART_Printf+0x23e>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    2458:	0f ef       	ldi	r16, 0xFF	; 255
                UART_TxNumber(v_uartChannel_u8,C_DECIMAL_U8,v_num_s16,v_numOfDigitsToTransmit_u8);
#endif
                break;

            case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                v_num_s32 = va_arg(argp, sint32_t);             
    245a:	57 01       	movw	r10, r14
    245c:	f4 e0       	ldi	r31, 0x04	; 4
    245e:	af 0e       	add	r10, r31
    2460:	b1 1c       	adc	r11, r1
    2462:	f7 01       	movw	r30, r14
    2464:	20 81       	ld	r18, Z
    2466:	31 81       	ldd	r19, Z+1	; 0x01
    2468:	42 81       	ldd	r20, Z+2	; 0x02
    246a:	53 81       	ldd	r21, Z+3	; 0x03
#if (Enable_UART_TxNumber == 1)                
                if(v_num_s32<0)
    246c:	57 ff       	sbrs	r21, 7
    246e:	35 c0       	rjmp	.+106    	; 0x24da <UART_Printf+0x18e>
                { /* If the number is -ve then display the 2's complement along with '-' sign */
                    v_num_s32 = -v_num_s32;
    2470:	50 95       	com	r21
    2472:	40 95       	com	r20
    2474:	30 95       	com	r19
    2476:	21 95       	neg	r18
    2478:	3f 4f       	sbci	r19, 0xFF	; 255
    247a:	4f 4f       	sbci	r20, 0xFF	; 255
    247c:	5f 4f       	sbci	r21, 0xFF	; 255
                    UART_TxChar(v_uartChannel_u8,'-');
    247e:	6d e2       	ldi	r22, 0x2D	; 45
    2480:	81 2f       	mov	r24, r17
    2482:	29 83       	std	Y+1, r18	; 0x01
    2484:	3a 83       	std	Y+2, r19	; 0x02
    2486:	4b 83       	std	Y+3, r20	; 0x03
    2488:	5c 83       	std	Y+4, r21	; 0x04
    248a:	43 de       	rcall	.-890    	; 0x2112 <UART_TxChar>
    248c:	5c 81       	ldd	r21, Y+4	; 0x04
    248e:	4b 81       	ldd	r20, Y+3	; 0x03
    2490:	3a 81       	ldd	r19, Y+2	; 0x02
    2492:	29 81       	ldd	r18, Y+1	; 0x01
    2494:	22 c0       	rjmp	.+68     	; 0x24da <UART_Printf+0x18e>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    2496:	95 36       	cpi	r25, 0x65	; 101
    2498:	08 f4       	brcc	.+2      	; 0x249c <UART_Printf+0x150>
    249a:	40 c0       	rjmp	.+128    	; 0x251c <UART_Printf+0x1d0>
    249c:	95 37       	cpi	r25, 0x75	; 117
    249e:	f9 f4       	brne	.+62     	; 0x24de <UART_Printf+0x192>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    24a0:	0f ef       	ldi	r16, 0xFF	; 255
                UART_TxNumber(v_uartChannel_u8,C_DECIMAL_U8,v_num_s32,v_numOfDigitsToTransmit_u8);
#endif                
                break;    

            case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                v_num_u16 = va_arg(argp, uint16_t);         
    24a2:	57 01       	movw	r10, r14
    24a4:	f2 e0       	ldi	r31, 0x02	; 2
    24a6:	af 0e       	add	r10, r31
    24a8:	b1 1c       	adc	r11, r1
#if (Enable_UART_TxNumber == 1)                
                UART_TxNumber(v_uartChannel_u8,C_DECIMAL_U8,v_num_u16,v_numOfDigitsToTransmit_u8);
    24aa:	f7 01       	movw	r30, r14
    24ac:	20 81       	ld	r18, Z
    24ae:	31 81       	ldd	r19, Z+1	; 0x01
    24b0:	40 e0       	ldi	r20, 0x00	; 0
    24b2:	50 e0       	ldi	r21, 0x00	; 0
    24b4:	12 c0       	rjmp	.+36     	; 0x24da <UART_Printf+0x18e>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    24b6:	94 34       	cpi	r25, 0x44	; 68
    24b8:	08 f4       	brcc	.+2      	; 0x24bc <UART_Printf+0x170>
    24ba:	5e c0       	rjmp	.+188    	; 0x2578 <UART_Printf+0x22c>
    24bc:	93 35       	cpi	r25, 0x53	; 83
    24be:	09 f4       	brne	.+2      	; 0x24c2 <UART_Printf+0x176>
    24c0:	50 c0       	rjmp	.+160    	; 0x2562 <UART_Printf+0x216>
    24c2:	95 35       	cpi	r25, 0x55	; 85
    24c4:	31 f6       	brne	.-116    	; 0x2452 <UART_Printf+0x106>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    24c6:	0f ef       	ldi	r16, 0xFF	; 255
                UART_TxNumber(v_uartChannel_u8,C_DECIMAL_U8,v_num_u16,v_numOfDigitsToTransmit_u8);
#endif                
                break;

            case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                v_num_u32 = va_arg(argp, uint32_t);         
    24c8:	57 01       	movw	r10, r14
    24ca:	f4 e0       	ldi	r31, 0x04	; 4
    24cc:	af 0e       	add	r10, r31
    24ce:	b1 1c       	adc	r11, r1
#if (Enable_UART_TxNumber == 1)                
                UART_TxNumber(v_uartChannel_u8,C_DECIMAL_U8,v_num_u32,v_numOfDigitsToTransmit_u8);
    24d0:	f7 01       	movw	r30, r14
    24d2:	20 81       	ld	r18, Z
    24d4:	31 81       	ldd	r19, Z+1	; 0x01
    24d6:	42 81       	ldd	r20, Z+2	; 0x02
    24d8:	53 81       	ldd	r21, Z+3	; 0x03
    24da:	6a e0       	ldi	r22, 0x0A	; 10
    24dc:	1c c0       	rjmp	.+56     	; 0x2516 <UART_Printf+0x1ca>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    24de:	98 37       	cpi	r25, 0x78	; 120
    24e0:	09 f0       	breq	.+2      	; 0x24e4 <UART_Printf+0x198>
    24e2:	3d c0       	rjmp	.+122    	; 0x255e <UART_Printf+0x212>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    24e4:	0f ef       	ldi	r16, 0xFF	; 255
                UART_TxNumber(v_uartChannel_u8,C_DECIMAL_U8,v_num_u32,v_numOfDigitsToTransmit_u8);
#endif                
                break;            

            case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u16 = va_arg(argp, uint16_t);             
    24e6:	57 01       	movw	r10, r14
    24e8:	f2 e0       	ldi	r31, 0x02	; 2
    24ea:	af 0e       	add	r10, r31
    24ec:	b1 1c       	adc	r11, r1
#if (Enable_UART_TxNumber == 1)                
                UART_TxNumber(v_uartChannel_u8,C_HEX_U8, v_num_u16,v_numOfDigitsToTransmit_u8);
    24ee:	f7 01       	movw	r30, r14
    24f0:	20 81       	ld	r18, Z
    24f2:	31 81       	ldd	r19, Z+1	; 0x01
    24f4:	40 e0       	ldi	r20, 0x00	; 0
    24f6:	50 e0       	ldi	r21, 0x00	; 0
    24f8:	0d c0       	rjmp	.+26     	; 0x2514 <UART_Printf+0x1c8>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    24fa:	98 35       	cpi	r25, 0x58	; 88
    24fc:	09 f0       	breq	.+2      	; 0x2500 <UART_Printf+0x1b4>
    24fe:	84 cf       	rjmp	.-248    	; 0x2408 <UART_Printf+0xbc>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    2500:	0f ef       	ldi	r16, 0xFF	; 255
                UART_TxNumber(v_uartChannel_u8,C_HEX_U8, v_num_u16,v_numOfDigitsToTransmit_u8);
#endif                
                break;

            case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u32 = va_arg(argp, uint32_t);                     
    2502:	57 01       	movw	r10, r14
    2504:	f4 e0       	ldi	r31, 0x04	; 4
    2506:	af 0e       	add	r10, r31
    2508:	b1 1c       	adc	r11, r1
#if (Enable_UART_TxNumber == 1)                        
                UART_TxNumber(v_uartChannel_u8,C_HEX_U8, v_num_u32,v_numOfDigitsToTransmit_u8);
    250a:	f7 01       	movw	r30, r14
    250c:	20 81       	ld	r18, Z
    250e:	31 81       	ldd	r19, Z+1	; 0x01
    2510:	42 81       	ldd	r20, Z+2	; 0x02
    2512:	53 81       	ldd	r21, Z+3	; 0x03
    2514:	60 e1       	ldi	r22, 0x10	; 16
    2516:	81 2f       	mov	r24, r17
    2518:	7d de       	rcall	.-774    	; 0x2214 <UART_TxNumber>
    251a:	2c c0       	rjmp	.+88     	; 0x2574 <UART_Printf+0x228>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    251c:	92 36       	cpi	r25, 0x62	; 98
    251e:	09 f0       	breq	.+2      	; 0x2522 <UART_Printf+0x1d6>
    2520:	45 c0       	rjmp	.+138    	; 0x25ac <UART_Printf+0x260>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    2522:	0f ef       	ldi	r16, 0xFF	; 255
#endif                
                break;


            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u16 = va_arg(argp, uint16_t);     
    2524:	57 01       	movw	r10, r14
    2526:	f2 e0       	ldi	r31, 0x02	; 2
    2528:	af 0e       	add	r10, r31
    252a:	b1 1c       	adc	r11, r1
    252c:	f7 01       	movw	r30, r14
    252e:	40 81       	ld	r20, Z
    2530:	51 81       	ldd	r21, Z+1	; 0x01
#if (Enable_UART_TxNumber == 1)                        
                if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    2532:	0f 3f       	cpi	r16, 0xFF	; 255
    2534:	09 f4       	brne	.+2      	; 0x2538 <UART_Printf+0x1ec>
                {
                    v_numOfDigitsToTransmit_u8 = 16;
    2536:	00 e1       	ldi	r16, 0x10	; 16
                }
                UART_TxNumber(v_uartChannel_u8,C_BINARY_U8, v_num_u16,v_numOfDigitsToTransmit_u8);
    2538:	60 e0       	ldi	r22, 0x00	; 0
    253a:	70 e0       	ldi	r23, 0x00	; 0
    253c:	0c c0       	rjmp	.+24     	; 0x2556 <UART_Printf+0x20a>
#endif                
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);         
    253e:	57 01       	movw	r10, r14
    2540:	f4 e0       	ldi	r31, 0x04	; 4
    2542:	af 0e       	add	r10, r31
    2544:	b1 1c       	adc	r11, r1
    2546:	f7 01       	movw	r30, r14
    2548:	40 81       	ld	r20, Z
    254a:	51 81       	ldd	r21, Z+1	; 0x01
    254c:	62 81       	ldd	r22, Z+2	; 0x02
    254e:	73 81       	ldd	r23, Z+3	; 0x03
#if (Enable_UART_TxNumber == 1)                
                if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    2550:	0f 3f       	cpi	r16, 0xFF	; 255
    2552:	09 f4       	brne	.+2      	; 0x2556 <UART_Printf+0x20a>
                    v_numOfDigitsToTransmit_u8 = 16;                
    2554:	00 e1       	ldi	r16, 0x10	; 16
    2556:	20 2f       	mov	r18, r16
    2558:	81 2f       	mov	r24, r17
    255a:	ea dd       	rcall	.-1068   	; 0x2130 <UART_TxNumber.part.2>
    255c:	0b c0       	rjmp	.+22     	; 0x2574 <UART_Printf+0x228>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    255e:	93 37       	cpi	r25, 0x73	; 115
    2560:	a1 f4       	brne	.+40     	; 0x258a <UART_Printf+0x23e>
                break;                


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
    2562:	57 01       	movw	r10, r14
    2564:	f2 e0       	ldi	r31, 0x02	; 2
    2566:	af 0e       	add	r10, r31
    2568:	b1 1c       	adc	r11, r1
                UART_TxString(v_uartChannel_u8,str);                
    256a:	f7 01       	movw	r30, r14
    256c:	60 81       	ld	r22, Z
    256e:	71 81       	ldd	r23, Z+1	; 0x01
    2570:	81 2f       	mov	r24, r17
    2572:	16 de       	rcall	.-980    	; 0x21a0 <UART_TxString>
                break;                


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
    2574:	75 01       	movw	r14, r10
                UART_TxString(v_uartChannel_u8,str);                
                break;
    2576:	09 c0       	rjmp	.+18     	; 0x258a <UART_Printf+0x23e>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    2578:	95 32       	cpi	r25, 0x25	; 37
    257a:	61 f4       	brne	.+24     	; 0x2594 <UART_Printf+0x248>
                str = va_arg(argp, char *);
                UART_TxString(v_uartChannel_u8,str);                
                break;

            case '%':
                UART_TxChar(v_uartChannel_u8,'%');
    257c:	65 e2       	ldi	r22, 0x25	; 37
    257e:	81 2f       	mov	r24, r17
    2580:	c8 dd       	rcall	.-1136   	; 0x2112 <UART_TxChar>
                break;
    2582:	03 c0       	rjmp	.+6      	; 0x258a <UART_Printf+0x23e>
            }
        }
        else
        {
            /* As '%' is not detected transmit the char passed */
            UART_TxChar(v_uartChannel_u8,ch);
    2584:	81 2f       	mov	r24, r17
    2586:	c5 dd       	rcall	.-1142   	; 0x2112 <UART_TxChar>
    2588:	65 01       	movw	r12, r10


    va_start(argp, argList);

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
    258a:	56 01       	movw	r10, r12
    258c:	ff ef       	ldi	r31, 0xFF	; 255
    258e:	af 1a       	sub	r10, r31
    2590:	bf 0a       	sbc	r11, r31
    2592:	f1 ce       	rjmp	.-542    	; 0x2376 <UART_Printf+0x2a>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    2594:	92 34       	cpi	r25, 0x42	; 66
    2596:	c9 f7       	brne	.-14     	; 0x258a <UART_Printf+0x23e>
                UART_TxNumber(v_uartChannel_u8,C_BINARY_U8, v_num_u16,v_numOfDigitsToTransmit_u8);
#endif                
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);         
    2598:	57 01       	movw	r10, r14
    259a:	f4 e0       	ldi	r31, 0x04	; 4
    259c:	af 0e       	add	r10, r31
    259e:	b1 1c       	adc	r11, r1
    25a0:	f7 01       	movw	r30, r14
    25a2:	40 81       	ld	r20, Z
    25a4:	51 81       	ldd	r21, Z+1	; 0x01
    25a6:	62 81       	ldd	r22, Z+2	; 0x02
    25a8:	73 81       	ldd	r23, Z+3	; 0x03
    25aa:	d4 cf       	rjmp	.-88     	; 0x2554 <UART_Printf+0x208>
            {
                v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
            }               


            switch(ch)       /* Decode the type of the argument */
    25ac:	93 36       	cpi	r25, 0x63	; 99
    25ae:	09 f4       	brne	.+2      	; 0x25b2 <UART_Printf+0x266>
    25b0:	30 cf       	rjmp	.-416    	; 0x2412 <UART_Printf+0xc6>
    25b2:	eb cf       	rjmp	.-42     	; 0x258a <UART_Printf+0x23e>
            UART_TxChar(v_uartChannel_u8,ch);
        }
    }

    va_end(argp);
}
    25b4:	0f 90       	pop	r0
    25b6:	0f 90       	pop	r0
    25b8:	0f 90       	pop	r0
    25ba:	0f 90       	pop	r0
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	1f 91       	pop	r17
    25c2:	0f 91       	pop	r16
    25c4:	ff 90       	pop	r15
    25c6:	ef 90       	pop	r14
    25c8:	df 90       	pop	r13
    25ca:	cf 90       	pop	r12
    25cc:	bf 90       	pop	r11
    25ce:	af 90       	pop	r10
    25d0:	08 95       	ret

000025d2 <main>:
#define MEMORY_STATICS    '6'



int main()
{
    25d2:	cf 93       	push	r28
    25d4:	df 93       	push	r29
    25d6:	cd b7       	in	r28, 0x3d	; 61
    25d8:	de b7       	in	r29, 0x3e	; 62
    25da:	e2 97       	sbiw	r28, 0x32	; 50
    25dc:	0f b6       	in	r0, 0x3f	; 63
    25de:	f8 94       	cli
    25e0:	de bf       	out	0x3e, r29	; 62
    25e2:	0f be       	out	0x3f, r0	; 63
    25e4:	cd bf       	out	0x3d, r28	; 61
	char ch,sourceFileName[12],destFileName[12];
	fileConfig_st *srcFilePtr,*destFilePtr;
	fileInfo fileList;
	uint32_t totalMemory,freeMemory;

	UART0_Init(115200);
    25e6:	40 e0       	ldi	r20, 0x00	; 0
    25e8:	52 ec       	ldi	r21, 0xC2	; 194
    25ea:	61 e0       	ldi	r22, 0x01	; 1
    25ec:	70 e0       	ldi	r23, 0x00	; 0
    25ee:	80 e0       	ldi	r24, 0x00	; 0
    25f0:	67 dd       	rcall	.-1330   	; 0x20c0 <UART_Init>
	returnStatus = SD_Init(&sdcardType);
    25f2:	ce 01       	movw	r24, r28
    25f4:	c1 96       	adiw	r24, 0x31	; 49
    25f6:	f9 dc       	rcall	.-1550   	; 0x1fea <SD_Init>
    25f8:	8a ab       	std	Y+50, r24	; 0x32

	if(returnStatus)
    25fa:	88 23       	and	r24, r24
    25fc:	a9 f0       	breq	.+42     	; 0x2628 <main+0x56>
	{
		if(returnStatus == SDCARD_NOT_DETECTED)
    25fe:	81 30       	cpi	r24, 0x01	; 1
    2600:	29 f4       	brne	.+10     	; 0x260c <main+0x3a>
		{
			UART0_TxString("\n\r SD card not detected..");
    2602:	64 e0       	ldi	r22, 0x04	; 4
    2604:	71 e0       	ldi	r23, 0x01	; 1
    2606:	80 e0       	ldi	r24, 0x00	; 0
    2608:	cb dd       	rcall	.-1130   	; 0x21a0 <UART_TxString>
    260a:	0d c0       	rjmp	.+26     	; 0x2626 <main+0x54>
		}
		else if(returnStatus == SDCARD_INIT_FAILED)
    260c:	82 30       	cpi	r24, 0x02	; 2
    260e:	29 f4       	brne	.+10     	; 0x261a <main+0x48>
		{
			UART0_TxString("\n\r Card Initialization failed..");
    2610:	6e e1       	ldi	r22, 0x1E	; 30
    2612:	71 e0       	ldi	r23, 0x01	; 1
    2614:	80 e0       	ldi	r24, 0x00	; 0
    2616:	c4 dd       	rcall	.-1144   	; 0x21a0 <UART_TxString>
    2618:	06 c0       	rjmp	.+12     	; 0x2626 <main+0x54>
		}
		else if(returnStatus == SDCARD_FAT_INVALID)
    261a:	83 30       	cpi	r24, 0x03	; 3
    261c:	21 f4       	brne	.+8      	; 0x2626 <main+0x54>
		{
			UART0_TxString("\n\r Invalid Fat filesystem");
    261e:	6e e3       	ldi	r22, 0x3E	; 62
    2620:	71 e0       	ldi	r23, 0x01	; 1
    2622:	80 e0       	ldi	r24, 0x00	; 0
    2624:	bd dd       	rcall	.-1158   	; 0x21a0 <UART_TxString>
		}
		while(1);
    2626:	ff cf       	rjmp	.-2      	; 0x2626 <main+0x54>
	}
	else
	{
		UART0_TxString("\n\rSD Card Detected!");
    2628:	68 e5       	ldi	r22, 0x58	; 88
    262a:	71 e0       	ldi	r23, 0x01	; 1
    262c:	80 e0       	ldi	r24, 0x00	; 0
    262e:	b8 dd       	rcall	.-1168   	; 0x21a0 <UART_TxString>


			case MEMORY_STATICS: //Print the SD CARD memory Total/Free in bytes
			UART0_TxString("\n\rMemory Statics is being calculated..");
			FILE_GetMemoryStatics(&totalMemory,&freeMemory);
			UART0_Printf("\n\rTotal memory:%Ubytes  Free memory:%Ubytes",totalMemory,freeMemory);
    2630:	8d e9       	ldi	r24, 0x9D	; 157
    2632:	e8 2e       	mov	r14, r24
    2634:	84 e0       	ldi	r24, 0x04	; 4
    2636:	f8 2e       	mov	r15, r24
			while(1)
			{
				returnStatus = FILE_GetList(&fileList);
				if(returnStatus != FAT32_END_OF_FILE_LIST)
				{
					UART0_Printf("\n\r%s   %Ubytes",fileList.fileName,fileList.fileSize);
    2638:	6e 01       	movw	r12, r28
    263a:	85 e0       	ldi	r24, 0x05	; 5
    263c:	c8 0e       	add	r12, r24
    263e:	d1 1c       	adc	r13, r1
    2640:	97 e6       	ldi	r25, 0x67	; 103
    2642:	a9 2e       	mov	r10, r25
    2644:	94 e0       	ldi	r25, 0x04	; 4
    2646:	b9 2e       	mov	r11, r25
	}


	while(1)
	{
		UART0_TxString("\n\r\n\rPress any key to continue");
    2648:	6c e6       	ldi	r22, 0x6C	; 108
    264a:	71 e0       	ldi	r23, 0x01	; 1
    264c:	80 e0       	ldi	r24, 0x00	; 0
    264e:	a8 dd       	rcall	.-1200   	; 0x21a0 <UART_TxString>
		UART0_RxChar();
    2650:	80 e0       	ldi	r24, 0x00	; 0
    2652:	4d dd       	rcall	.-1382   	; 0x20ee <UART_RxChar>
		UART0_TxString("\n\r\n\r------File options---------\n\r");
    2654:	6a e8       	ldi	r22, 0x8A	; 138
    2656:	71 e0       	ldi	r23, 0x01	; 1
    2658:	80 e0       	ldi	r24, 0x00	; 0
    265a:	a2 dd       	rcall	.-1212   	; 0x21a0 <UART_TxString>
		UART0_TxString("1: Read File \n\r");
    265c:	6c ea       	ldi	r22, 0xAC	; 172
    265e:	71 e0       	ldi	r23, 0x01	; 1
    2660:	80 e0       	ldi	r24, 0x00	; 0
    2662:	9e dd       	rcall	.-1220   	; 0x21a0 <UART_TxString>
		UART0_TxString("2: Write File \n\r");
    2664:	6c eb       	ldi	r22, 0xBC	; 188
    2666:	71 e0       	ldi	r23, 0x01	; 1
    2668:	80 e0       	ldi	r24, 0x00	; 0
    266a:	9a dd       	rcall	.-1228   	; 0x21a0 <UART_TxString>
		UART0_TxString("3: File Copy \n\r");
    266c:	6d ec       	ldi	r22, 0xCD	; 205
    266e:	71 e0       	ldi	r23, 0x01	; 1
    2670:	80 e0       	ldi	r24, 0x00	; 0
    2672:	96 dd       	rcall	.-1236   	; 0x21a0 <UART_TxString>
		UART0_TxString("4: Delete File \n\r");
    2674:	6d ed       	ldi	r22, 0xDD	; 221
    2676:	71 e0       	ldi	r23, 0x01	; 1
    2678:	80 e0       	ldi	r24, 0x00	; 0
    267a:	92 dd       	rcall	.-1244   	; 0x21a0 <UART_TxString>
		UART0_TxString("5: Get File List \n\r");
    267c:	6f ee       	ldi	r22, 0xEF	; 239
    267e:	71 e0       	ldi	r23, 0x01	; 1
    2680:	80 e0       	ldi	r24, 0x00	; 0
    2682:	8e dd       	rcall	.-1252   	; 0x21a0 <UART_TxString>
		UART0_TxString("6: Memory Statics \n\r");
    2684:	63 e0       	ldi	r22, 0x03	; 3
    2686:	72 e0       	ldi	r23, 0x02	; 2
    2688:	80 e0       	ldi	r24, 0x00	; 0
    268a:	8a dd       	rcall	.-1260   	; 0x21a0 <UART_TxString>
		UART0_TxString("--------------------------- \n\r");
    268c:	68 e1       	ldi	r22, 0x18	; 24
    268e:	72 e0       	ldi	r23, 0x02	; 2
    2690:	80 e0       	ldi	r24, 0x00	; 0
    2692:	86 dd       	rcall	.-1268   	; 0x21a0 <UART_TxString>
		UART0_TxString("Choose one of the options: \n\r");
    2694:	67 e3       	ldi	r22, 0x37	; 55
    2696:	72 e0       	ldi	r23, 0x02	; 2
    2698:	80 e0       	ldi	r24, 0x00	; 0
    269a:	82 dd       	rcall	.-1276   	; 0x21a0 <UART_TxString>


		do
		{
			option = UART0_RxChar();
    269c:	80 e0       	ldi	r24, 0x00	; 0
    269e:	27 dd       	rcall	.-1458   	; 0x20ee <UART_RxChar>
    26a0:	18 2f       	mov	r17, r24
		}while((option<'1') || (option>'6'));
    26a2:	8f ec       	ldi	r24, 0xCF	; 207
    26a4:	81 0f       	add	r24, r17
    26a6:	86 30       	cpi	r24, 0x06	; 6
    26a8:	c8 f7       	brcc	.-14     	; 0x269c <main+0xca>

		UART0_TxChar(option);
    26aa:	61 2f       	mov	r22, r17
    26ac:	80 e0       	ldi	r24, 0x00	; 0
    26ae:	31 dd       	rcall	.-1438   	; 0x2112 <UART_TxChar>
		UART0_TxString("\n\r\n\r");
    26b0:	65 e5       	ldi	r22, 0x55	; 85
    26b2:	72 e0       	ldi	r23, 0x02	; 2
    26b4:	80 e0       	ldi	r24, 0x00	; 0
    26b6:	74 dd       	rcall	.-1304   	; 0x21a0 <UART_TxString>

		switch(option)
    26b8:	14 33       	cpi	r17, 0x34	; 52
    26ba:	09 f4       	brne	.+2      	; 0x26be <main+0xec>
    26bc:	a8 c0       	rjmp	.+336    	; 0x280e <main+0x23c>
    26be:	30 f4       	brcc	.+12     	; 0x26cc <main+0xfa>
    26c0:	12 33       	cpi	r17, 0x32	; 50
    26c2:	71 f1       	breq	.+92     	; 0x2720 <main+0x14e>
    26c4:	13 33       	cpi	r17, 0x33	; 51
    26c6:	09 f4       	brne	.+2      	; 0x26ca <main+0xf8>
    26c8:	5d c0       	rjmp	.+186    	; 0x2784 <main+0x1b2>
    26ca:	06 c0       	rjmp	.+12     	; 0x26d8 <main+0x106>
    26cc:	15 33       	cpi	r17, 0x35	; 53
    26ce:	09 f4       	brne	.+2      	; 0x26d2 <main+0x100>
    26d0:	b9 c0       	rjmp	.+370    	; 0x2844 <main+0x272>
    26d2:	16 33       	cpi	r17, 0x36	; 54
    26d4:	09 f4       	brne	.+2      	; 0x26d8 <main+0x106>
    26d6:	d2 c0       	rjmp	.+420    	; 0x287c <main+0x2aa>
		{

			case FILE_READ: /* Read a File */
			UART0_TxString("\n\rEnter File name max 11 chars including file type: ");
    26d8:	6a e5       	ldi	r22, 0x5A	; 90
    26da:	72 e0       	ldi	r23, 0x02	; 2
    26dc:	80 e0       	ldi	r24, 0x00	; 0
    26de:	60 dd       	rcall	.-1344   	; 0x21a0 <UART_TxString>
			UART0_RxString(sourceFileName);
    26e0:	be 01       	movw	r22, r28
    26e2:	63 5e       	subi	r22, 0xE3	; 227
    26e4:	7f 4f       	sbci	r23, 0xFF	; 255
    26e6:	80 e0       	ldi	r24, 0x00	; 0
    26e8:	6a dd       	rcall	.-1324   	; 0x21be <UART_RxString>

			srcFilePtr = FILE_Open(sourceFileName,READ,&returnStatus);
    26ea:	ae 01       	movw	r20, r28
    26ec:	4e 5c       	subi	r20, 0xCE	; 206
    26ee:	5f 4f       	sbci	r21, 0xFF	; 255
    26f0:	60 e0       	ldi	r22, 0x00	; 0
    26f2:	ce 01       	movw	r24, r28
    26f4:	4d 96       	adiw	r24, 0x1d	; 29
    26f6:	0e 94 42 07 	call	0xe84	; 0xe84 <FILE_Open>
    26fa:	8c 01       	movw	r16, r24
			if(srcFilePtr == 0)
    26fc:	89 2b       	or	r24, r25
    26fe:	19 f4       	brne	.+6      	; 0x2706 <main+0x134>
			{
				UART0_TxString("\n\rFile Opening Failed");
    2700:	6f e8       	ldi	r22, 0x8F	; 143
    2702:	72 e0       	ldi	r23, 0x02	; 2
    2704:	9c c0       	rjmp	.+312    	; 0x283e <main+0x26c>
			}
			else
			{
				UART0_TxString("File Content: ");
    2706:	65 ea       	ldi	r22, 0xA5	; 165
    2708:	72 e0       	ldi	r23, 0x02	; 2
    270a:	80 e0       	ldi	r24, 0x00	; 0
    270c:	49 dd       	rcall	.-1390   	; 0x21a0 <UART_TxString>
				while(1)
				{
					ch = FILE_GetCh(srcFilePtr);
    270e:	c8 01       	movw	r24, r16
    2710:	0e 94 35 01 	call	0x26a	; 0x26a <FILE_GetCh>
					if(ch == EOF)
    2714:	8a 31       	cpi	r24, 0x1A	; 26
    2716:	51 f1       	breq	.+84     	; 0x276c <main+0x19a>
					break;
					UART0_TxChar(ch);
    2718:	68 2f       	mov	r22, r24
    271a:	80 e0       	ldi	r24, 0x00	; 0
    271c:	fa dc       	rcall	.-1548   	; 0x2112 <UART_TxChar>
				}
    271e:	f7 cf       	rjmp	.-18     	; 0x270e <main+0x13c>
			break;



			case FILE_WRITE: /* Write to a File */
			UART0_TxString("\n\rEnter File name max 11 chars including file type: ");
    2720:	6a e5       	ldi	r22, 0x5A	; 90
    2722:	72 e0       	ldi	r23, 0x02	; 2
    2724:	80 e0       	ldi	r24, 0x00	; 0
    2726:	3c dd       	rcall	.-1416   	; 0x21a0 <UART_TxString>
			UART0_RxString(sourceFileName);
    2728:	be 01       	movw	r22, r28
    272a:	63 5e       	subi	r22, 0xE3	; 227
    272c:	7f 4f       	sbci	r23, 0xFF	; 255
    272e:	80 e0       	ldi	r24, 0x00	; 0
    2730:	46 dd       	rcall	.-1396   	; 0x21be <UART_RxString>

			srcFilePtr = FILE_Open(sourceFileName,WRITE,&returnStatus);
    2732:	ae 01       	movw	r20, r28
    2734:	4e 5c       	subi	r20, 0xCE	; 206
    2736:	5f 4f       	sbci	r21, 0xFF	; 255
    2738:	62 e0       	ldi	r22, 0x02	; 2
    273a:	ce 01       	movw	r24, r28
    273c:	4d 96       	adiw	r24, 0x1d	; 29
    273e:	0e 94 42 07 	call	0xe84	; 0xe84 <FILE_Open>
    2742:	8c 01       	movw	r16, r24
			if(srcFilePtr == 0)
    2744:	89 2b       	or	r24, r25
    2746:	e1 f2       	breq	.-72     	; 0x2700 <main+0x12e>
			{
				UART0_TxString("\n\rFile Opening Failed");
			}
			else
			{
				UART0_TxString("\n\rEnter text ending with '>' :");
    2748:	64 eb       	ldi	r22, 0xB4	; 180
    274a:	72 e0       	ldi	r23, 0x02	; 2
    274c:	80 e0       	ldi	r24, 0x00	; 0
    274e:	28 dd       	rcall	.-1456   	; 0x21a0 <UART_TxString>
				while(1)
				{
					ch = UART0_RxChar();
    2750:	80 e0       	ldi	r24, 0x00	; 0
    2752:	cd dc       	rcall	.-1638   	; 0x20ee <UART_RxChar>
    2754:	98 2e       	mov	r9, r24
					if(ch == '>')
    2756:	9e e3       	ldi	r25, 0x3E	; 62
    2758:	89 13       	cpse	r24, r25
    275a:	0c c0       	rjmp	.+24     	; 0x2774 <main+0x1a2>
					{
						FILE_PutCh(srcFilePtr,EOF);
    275c:	6a e1       	ldi	r22, 0x1A	; 26
    275e:	c8 01       	movw	r24, r16
    2760:	0e 94 80 09 	call	0x1300	; 0x1300 <FILE_PutCh>
					else
					{   UART0_TxChar(ch);
						FILE_PutCh(srcFilePtr,ch);
					}
				}
				UART0_TxString("\n\rData saved to file, closing the file.");
    2764:	63 ed       	ldi	r22, 0xD3	; 211
    2766:	72 e0       	ldi	r23, 0x02	; 2
    2768:	80 e0       	ldi	r24, 0x00	; 0
    276a:	1a dd       	rcall	.-1484   	; 0x21a0 <UART_TxString>
				FILE_Close(srcFilePtr);
    276c:	c8 01       	movw	r24, r16
    276e:	0e 94 74 00 	call	0xe8	; 0xe8 <FILE_Close>
    2772:	6a cf       	rjmp	.-300    	; 0x2648 <main+0x76>
					{
						FILE_PutCh(srcFilePtr,EOF);
						break;
					}
					else
					{   UART0_TxChar(ch);
    2774:	68 2f       	mov	r22, r24
    2776:	80 e0       	ldi	r24, 0x00	; 0
    2778:	cc dc       	rcall	.-1640   	; 0x2112 <UART_TxChar>
						FILE_PutCh(srcFilePtr,ch);
    277a:	69 2d       	mov	r22, r9
    277c:	c8 01       	movw	r24, r16
    277e:	0e 94 80 09 	call	0x1300	; 0x1300 <FILE_PutCh>
					}
				}
    2782:	e6 cf       	rjmp	.-52     	; 0x2750 <main+0x17e>
			break;



			case FILE_COPY: /* File Copy */
			UART0_TxString("\n\rEnter source File name max 11 chars including file type: ");
    2784:	6b ef       	ldi	r22, 0xFB	; 251
    2786:	72 e0       	ldi	r23, 0x02	; 2
    2788:	80 e0       	ldi	r24, 0x00	; 0
    278a:	0a dd       	rcall	.-1516   	; 0x21a0 <UART_TxString>
			UART0_RxString(sourceFileName);
    278c:	be 01       	movw	r22, r28
    278e:	63 5e       	subi	r22, 0xE3	; 227
    2790:	7f 4f       	sbci	r23, 0xFF	; 255
    2792:	80 e0       	ldi	r24, 0x00	; 0
    2794:	14 dd       	rcall	.-1496   	; 0x21be <UART_RxString>

			srcFilePtr = FILE_Open(sourceFileName,READ,&returnStatus);
    2796:	ae 01       	movw	r20, r28
    2798:	4e 5c       	subi	r20, 0xCE	; 206
    279a:	5f 4f       	sbci	r21, 0xFF	; 255
    279c:	60 e0       	ldi	r22, 0x00	; 0
    279e:	ce 01       	movw	r24, r28
    27a0:	4d 96       	adiw	r24, 0x1d	; 29
    27a2:	0e 94 42 07 	call	0xe84	; 0xe84 <FILE_Open>
    27a6:	8c 01       	movw	r16, r24
			if(srcFilePtr == 0)
    27a8:	89 2b       	or	r24, r25
    27aa:	19 f4       	brne	.+6      	; 0x27b2 <main+0x1e0>
			{
				UART0_TxString("\n\rSource File Opening Failed");
    27ac:	67 e3       	ldi	r22, 0x37	; 55
    27ae:	73 e0       	ldi	r23, 0x03	; 3
    27b0:	46 c0       	rjmp	.+140    	; 0x283e <main+0x26c>
			}
			else
			{
				UART0_TxString("\n\rEnter destination File name max 11 chars including file type: ");
    27b2:	64 e5       	ldi	r22, 0x54	; 84
    27b4:	73 e0       	ldi	r23, 0x03	; 3
    27b6:	80 e0       	ldi	r24, 0x00	; 0
    27b8:	f3 dc       	rcall	.-1562   	; 0x21a0 <UART_TxString>
				UART0_RxString(destFileName);
    27ba:	be 01       	movw	r22, r28
    27bc:	6f 5e       	subi	r22, 0xEF	; 239
    27be:	7f 4f       	sbci	r23, 0xFF	; 255
    27c0:	80 e0       	ldi	r24, 0x00	; 0
    27c2:	fd dc       	rcall	.-1542   	; 0x21be <UART_RxString>

				destFilePtr = FILE_Open(destFileName,WRITE,&returnStatus);
    27c4:	ae 01       	movw	r20, r28
    27c6:	4e 5c       	subi	r20, 0xCE	; 206
    27c8:	5f 4f       	sbci	r21, 0xFF	; 255
    27ca:	62 e0       	ldi	r22, 0x02	; 2
    27cc:	ce 01       	movw	r24, r28
    27ce:	41 96       	adiw	r24, 0x11	; 17
    27d0:	0e 94 42 07 	call	0xe84	; 0xe84 <FILE_Open>
    27d4:	4c 01       	movw	r8, r24

				if(destFilePtr == 0)
    27d6:	89 2b       	or	r24, r25
    27d8:	19 f4       	brne	.+6      	; 0x27e0 <main+0x20e>
				{
					UART0_TxString("\n\rDestination File Opening Failed");
    27da:	65 e9       	ldi	r22, 0x95	; 149
    27dc:	73 e0       	ldi	r23, 0x03	; 3
    27de:	c4 cf       	rjmp	.-120    	; 0x2768 <main+0x196>

				}
				else
				{
					UART0_TxString("\n\rCopying the file.");
    27e0:	67 eb       	ldi	r22, 0xB7	; 183
    27e2:	73 e0       	ldi	r23, 0x03	; 3
    27e4:	80 e0       	ldi	r24, 0x00	; 0
    27e6:	dc dc       	rcall	.-1608   	; 0x21a0 <UART_TxString>
					while(1)
					{
						ch = FILE_GetCh(srcFilePtr);
    27e8:	c8 01       	movw	r24, r16
    27ea:	0e 94 35 01 	call	0x26a	; 0x26a <FILE_GetCh>
    27ee:	78 2e       	mov	r7, r24
						FILE_PutCh(destFilePtr,ch);
    27f0:	68 2f       	mov	r22, r24
    27f2:	c4 01       	movw	r24, r8
    27f4:	0e 94 80 09 	call	0x1300	; 0x1300 <FILE_PutCh>
						if(ch == EOF)
    27f8:	8a e1       	ldi	r24, 0x1A	; 26
    27fa:	78 12       	cpse	r7, r24
    27fc:	f5 cf       	rjmp	.-22     	; 0x27e8 <main+0x216>
						{
							break;
						}
					}
					UART0_TxString("\n\rDone Copying..");
    27fe:	6b ec       	ldi	r22, 0xCB	; 203
    2800:	73 e0       	ldi	r23, 0x03	; 3
    2802:	80 e0       	ldi	r24, 0x00	; 0
    2804:	cd dc       	rcall	.-1638   	; 0x21a0 <UART_TxString>
					FILE_Close(destFilePtr);
    2806:	c4 01       	movw	r24, r8
    2808:	0e 94 74 00 	call	0xe8	; 0xe8 <FILE_Close>
    280c:	af cf       	rjmp	.-162    	; 0x276c <main+0x19a>
			break;



			case FILE_DELETE: // FIle Delete
			UART0_TxString("\n\rEnter File name to be deleted max 11 chars including file type: ");
    280e:	6c ed       	ldi	r22, 0xDC	; 220
    2810:	73 e0       	ldi	r23, 0x03	; 3
    2812:	80 e0       	ldi	r24, 0x00	; 0
    2814:	c5 dc       	rcall	.-1654   	; 0x21a0 <UART_TxString>
			UART0_RxString(sourceFileName);
    2816:	be 01       	movw	r22, r28
    2818:	63 5e       	subi	r22, 0xE3	; 227
    281a:	7f 4f       	sbci	r23, 0xFF	; 255
    281c:	80 e0       	ldi	r24, 0x00	; 0
    281e:	cf dc       	rcall	.-1634   	; 0x21be <UART_RxString>

			UART0_TxString("\n\rDeleting File: ");
    2820:	6f e1       	ldi	r22, 0x1F	; 31
    2822:	74 e0       	ldi	r23, 0x04	; 4
    2824:	80 e0       	ldi	r24, 0x00	; 0
    2826:	bc dc       	rcall	.-1672   	; 0x21a0 <UART_TxString>
			returnStatus = FILE_Delete(sourceFileName);
    2828:	ce 01       	movw	r24, r28
    282a:	4d 96       	adiw	r24, 0x1d	; 29
    282c:	be d8       	rcall	.-3716   	; 0x19aa <FILE_Delete>
    282e:	8a ab       	std	Y+50, r24	; 0x32
			if(returnStatus == FAT32_FILE_OPENED_CANNOT_BE_DELETED)
    2830:	86 30       	cpi	r24, 0x06	; 6
    2832:	19 f4       	brne	.+6      	; 0x283a <main+0x268>
			{
				UART0_TxString("\n\rFile is open cannot be deleted");
    2834:	61 e3       	ldi	r22, 0x31	; 49
    2836:	74 e0       	ldi	r23, 0x04	; 4
    2838:	02 c0       	rjmp	.+4      	; 0x283e <main+0x26c>
			}
			else
			{
				UART0_TxString("\n\rDone! File Deleted");
    283a:	62 e5       	ldi	r22, 0x52	; 82
    283c:	74 e0       	ldi	r23, 0x04	; 4
    283e:	80 e0       	ldi	r24, 0x00	; 0
    2840:	af dc       	rcall	.-1698   	; 0x21a0 <UART_TxString>
    2842:	02 cf       	rjmp	.-508    	; 0x2648 <main+0x76>


			case FILE_LIST: //Print the files with size
			while(1)
			{
				returnStatus = FILE_GetList(&fileList);
    2844:	ce 01       	movw	r24, r28
    2846:	01 96       	adiw	r24, 0x01	; 1
    2848:	0e 94 b6 01 	call	0x36c	; 0x36c <FILE_GetList>
    284c:	8a ab       	std	Y+50, r24	; 0x32
				if(returnStatus != FAT32_END_OF_FILE_LIST)
    284e:	89 30       	cpi	r24, 0x09	; 9
    2850:	09 f4       	brne	.+2      	; 0x2854 <main+0x282>
    2852:	fa ce       	rjmp	.-524    	; 0x2648 <main+0x76>
				{
					UART0_Printf("\n\r%s   %Ubytes",fileList.fileName,fileList.fileSize);
    2854:	8c 81       	ldd	r24, Y+4	; 0x04
    2856:	8f 93       	push	r24
    2858:	8b 81       	ldd	r24, Y+3	; 0x03
    285a:	8f 93       	push	r24
    285c:	8a 81       	ldd	r24, Y+2	; 0x02
    285e:	8f 93       	push	r24
    2860:	89 81       	ldd	r24, Y+1	; 0x01
    2862:	8f 93       	push	r24
    2864:	df 92       	push	r13
    2866:	cf 92       	push	r12
    2868:	bf 92       	push	r11
    286a:	af 92       	push	r10
    286c:	1f 92       	push	r1
    286e:	6e dd       	rcall	.-1316   	; 0x234c <UART_Printf>
				}
				else
				{
					break;
				}
			}
    2870:	0f b6       	in	r0, 0x3f	; 63
    2872:	f8 94       	cli
    2874:	de bf       	out	0x3e, r29	; 62
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	cd bf       	out	0x3d, r28	; 61
    287a:	e4 cf       	rjmp	.-56     	; 0x2844 <main+0x272>
			break;


			case MEMORY_STATICS: //Print the SD CARD memory Total/Free in bytes
			UART0_TxString("\n\rMemory Statics is being calculated..");
    287c:	66 e7       	ldi	r22, 0x76	; 118
    287e:	74 e0       	ldi	r23, 0x04	; 4
    2880:	80 e0       	ldi	r24, 0x00	; 0
    2882:	8e dc       	rcall	.-1764   	; 0x21a0 <UART_TxString>
			FILE_GetMemoryStatics(&totalMemory,&freeMemory);
    2884:	be 01       	movw	r22, r28
    2886:	67 5d       	subi	r22, 0xD7	; 215
    2888:	7f 4f       	sbci	r23, 0xFF	; 255
    288a:	ce 01       	movw	r24, r28
    288c:	8d 96       	adiw	r24, 0x2d	; 45
    288e:	0e 94 3a 03 	call	0x674	; 0x674 <FILE_GetMemoryStatics>
			UART0_Printf("\n\rTotal memory:%Ubytes  Free memory:%Ubytes",totalMemory,freeMemory);
    2892:	8c a5       	ldd	r24, Y+44	; 0x2c
    2894:	8f 93       	push	r24
    2896:	8b a5       	ldd	r24, Y+43	; 0x2b
    2898:	8f 93       	push	r24
    289a:	8a a5       	ldd	r24, Y+42	; 0x2a
    289c:	8f 93       	push	r24
    289e:	89 a5       	ldd	r24, Y+41	; 0x29
    28a0:	8f 93       	push	r24
    28a2:	88 a9       	ldd	r24, Y+48	; 0x30
    28a4:	8f 93       	push	r24
    28a6:	8f a5       	ldd	r24, Y+47	; 0x2f
    28a8:	8f 93       	push	r24
    28aa:	8e a5       	ldd	r24, Y+46	; 0x2e
    28ac:	8f 93       	push	r24
    28ae:	8d a5       	ldd	r24, Y+45	; 0x2d
    28b0:	8f 93       	push	r24
    28b2:	ff 92       	push	r15
    28b4:	ef 92       	push	r14
    28b6:	1f 92       	push	r1
    28b8:	49 dd       	rcall	.-1390   	; 0x234c <UART_Printf>
			break;
    28ba:	0f b6       	in	r0, 0x3f	; 63
    28bc:	f8 94       	cli
    28be:	de bf       	out	0x3e, r29	; 62
    28c0:	0f be       	out	0x3f, r0	; 63
    28c2:	cd bf       	out	0x3d, r28	; 61
    28c4:	c1 ce       	rjmp	.-638    	; 0x2648 <main+0x76>

000028c6 <__mulsi3>:
    28c6:	db 01       	movw	r26, r22
    28c8:	8f 93       	push	r24
    28ca:	9f 93       	push	r25
    28cc:	45 d0       	rcall	.+138    	; 0x2958 <__muluhisi3>
    28ce:	bf 91       	pop	r27
    28d0:	af 91       	pop	r26
    28d2:	a2 9f       	mul	r26, r18
    28d4:	80 0d       	add	r24, r0
    28d6:	91 1d       	adc	r25, r1
    28d8:	a3 9f       	mul	r26, r19
    28da:	90 0d       	add	r25, r0
    28dc:	b2 9f       	mul	r27, r18
    28de:	90 0d       	add	r25, r0
    28e0:	11 24       	eor	r1, r1
    28e2:	08 95       	ret

000028e4 <__udivmodsi4>:
    28e4:	a1 e2       	ldi	r26, 0x21	; 33
    28e6:	1a 2e       	mov	r1, r26
    28e8:	aa 1b       	sub	r26, r26
    28ea:	bb 1b       	sub	r27, r27
    28ec:	fd 01       	movw	r30, r26
    28ee:	0d c0       	rjmp	.+26     	; 0x290a <__udivmodsi4_ep>

000028f0 <__udivmodsi4_loop>:
    28f0:	aa 1f       	adc	r26, r26
    28f2:	bb 1f       	adc	r27, r27
    28f4:	ee 1f       	adc	r30, r30
    28f6:	ff 1f       	adc	r31, r31
    28f8:	a2 17       	cp	r26, r18
    28fa:	b3 07       	cpc	r27, r19
    28fc:	e4 07       	cpc	r30, r20
    28fe:	f5 07       	cpc	r31, r21
    2900:	20 f0       	brcs	.+8      	; 0x290a <__udivmodsi4_ep>
    2902:	a2 1b       	sub	r26, r18
    2904:	b3 0b       	sbc	r27, r19
    2906:	e4 0b       	sbc	r30, r20
    2908:	f5 0b       	sbc	r31, r21

0000290a <__udivmodsi4_ep>:
    290a:	66 1f       	adc	r22, r22
    290c:	77 1f       	adc	r23, r23
    290e:	88 1f       	adc	r24, r24
    2910:	99 1f       	adc	r25, r25
    2912:	1a 94       	dec	r1
    2914:	69 f7       	brne	.-38     	; 0x28f0 <__udivmodsi4_loop>
    2916:	60 95       	com	r22
    2918:	70 95       	com	r23
    291a:	80 95       	com	r24
    291c:	90 95       	com	r25
    291e:	9b 01       	movw	r18, r22
    2920:	ac 01       	movw	r20, r24
    2922:	bd 01       	movw	r22, r26
    2924:	cf 01       	movw	r24, r30
    2926:	08 95       	ret

00002928 <__tablejump2__>:
    2928:	ee 0f       	add	r30, r30
    292a:	ff 1f       	adc	r31, r31
    292c:	00 24       	eor	r0, r0
    292e:	00 1c       	adc	r0, r0
    2930:	0b be       	out	0x3b, r0	; 59
    2932:	07 90       	elpm	r0, Z+
    2934:	f6 91       	elpm	r31, Z
    2936:	e0 2d       	mov	r30, r0
    2938:	09 94       	ijmp

0000293a <__umulhisi3>:
    293a:	a2 9f       	mul	r26, r18
    293c:	b0 01       	movw	r22, r0
    293e:	b3 9f       	mul	r27, r19
    2940:	c0 01       	movw	r24, r0
    2942:	a3 9f       	mul	r26, r19
    2944:	70 0d       	add	r23, r0
    2946:	81 1d       	adc	r24, r1
    2948:	11 24       	eor	r1, r1
    294a:	91 1d       	adc	r25, r1
    294c:	b2 9f       	mul	r27, r18
    294e:	70 0d       	add	r23, r0
    2950:	81 1d       	adc	r24, r1
    2952:	11 24       	eor	r1, r1
    2954:	91 1d       	adc	r25, r1
    2956:	08 95       	ret

00002958 <__muluhisi3>:
    2958:	f0 df       	rcall	.-32     	; 0x293a <__umulhisi3>
    295a:	a5 9f       	mul	r26, r21
    295c:	90 0d       	add	r25, r0
    295e:	b4 9f       	mul	r27, r20
    2960:	90 0d       	add	r25, r0
    2962:	a4 9f       	mul	r26, r20
    2964:	80 0d       	add	r24, r0
    2966:	91 1d       	adc	r25, r1
    2968:	11 24       	eor	r1, r1
    296a:	08 95       	ret

0000296c <__mulshisi3>:
    296c:	b7 ff       	sbrs	r27, 7
    296e:	f4 cf       	rjmp	.-24     	; 0x2958 <__muluhisi3>

00002970 <__mulohisi3>:
    2970:	f3 df       	rcall	.-26     	; 0x2958 <__muluhisi3>
    2972:	82 1b       	sub	r24, r18
    2974:	93 0b       	sbc	r25, r19
    2976:	08 95       	ret

00002978 <strcmp>:
    2978:	fb 01       	movw	r30, r22
    297a:	dc 01       	movw	r26, r24
    297c:	8d 91       	ld	r24, X+
    297e:	01 90       	ld	r0, Z+
    2980:	80 19       	sub	r24, r0
    2982:	01 10       	cpse	r0, r1
    2984:	d9 f3       	breq	.-10     	; 0x297c <strcmp+0x4>
    2986:	99 0b       	sbc	r25, r25
    2988:	08 95       	ret

0000298a <strcpy>:
    298a:	fb 01       	movw	r30, r22
    298c:	dc 01       	movw	r26, r24
    298e:	01 90       	ld	r0, Z+
    2990:	0d 92       	st	X+, r0
    2992:	00 20       	and	r0, r0
    2994:	e1 f7       	brne	.-8      	; 0x298e <strcpy+0x4>
    2996:	08 95       	ret

00002998 <_exit>:
    2998:	f8 94       	cli

0000299a <__stop_program>:
    299a:	ff cf       	rjmp	.-2      	; 0x299a <__stop_program>
