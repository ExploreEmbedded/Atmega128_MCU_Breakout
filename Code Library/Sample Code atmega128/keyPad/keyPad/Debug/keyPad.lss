
keyPad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  0000044e  000004e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000044e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  00800106  00800106  000004e8  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000004e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00000c40  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000c22  00000000  00000000  00000d00  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000003fa  00000000  00000000  00001922  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005f4  00000000  00000000  00001d1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000013c  00000000  00000000  00002310  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003dc  00000000  00000000  0000244c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004ab  00000000  00000000  00002828  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ee e4       	ldi	r30, 0x4E	; 78
  a0:	f4 e0       	ldi	r31, 0x04	; 4
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a6 30       	cpi	r26, 0x06	; 6
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a6 e0       	ldi	r26, 0x06	; 6
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ab 30       	cpi	r26, 0x0B	; 11
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 19 02 	call	0x432	; 0x432 <main>
  c6:	0c 94 25 02 	jmp	0x44a	; 0x44a <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <KEYPAD_Init>:
        1.ROW lines are configured as Output.
        2.Column Lines are configured as Input.
 ***************************************************************************************************/
void KEYPAD_Init()
{
	M_RowColDirection= C_RowOutputColInput_U8; // Configure Row lines as O/P and Column lines as I/P
  ce:	80 ef       	ldi	r24, 0xF0	; 240
  d0:	87 bb       	out	0x17, r24	; 23
}
  d2:	08 95       	ret

000000d4 <KEYPAD_WaitForKeyRelease>:
	uint8_t key;
	do
	{
		do
		{
			M_ROW=0x0F;           // Pull the ROW lines to low and Column lines high.
  d4:	9f e0       	ldi	r25, 0x0F	; 15
  d6:	98 bb       	out	0x18, r25	; 24
			key=M_COL & 0x0F;     // Read the Columns, to check the key press
  d8:	86 b3       	in	r24, 0x16	; 22
  da:	8f 70       	andi	r24, 0x0F	; 15
		}while(key!=0x0F);
  dc:	8f 30       	cpi	r24, 0x0F	; 15
  de:	d9 f7       	brne	.-10     	; 0xd6 <KEYPAD_WaitForKeyRelease+0x2>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  e0:	e7 eb       	ldi	r30, 0xB7	; 183
  e2:	fb e0       	ldi	r31, 0x0B	; 11
  e4:	31 97       	sbiw	r30, 0x01	; 1
  e6:	f1 f7       	brne	.-4      	; 0xe4 <KEYPAD_WaitForKeyRelease+0x10>
  e8:	00 c0       	rjmp	.+0      	; 0xea <KEYPAD_WaitForKeyRelease+0x16>
  ea:	00 00       	nop

		DELAY_ms(1);

		M_ROW=0x0F;           // Pull the ROW lines to low and Column lines high.
  ec:	98 bb       	out	0x18, r25	; 24
		key=M_COL & 0x0F;     // Read the Columns, to check the key press
  ee:	86 b3       	in	r24, 0x16	; 22
  f0:	8f 70       	andi	r24, 0x0F	; 15
	}while(key!=0x0F);   // Wait till the Key is released,
  f2:	8f 30       	cpi	r24, 0x0F	; 15
  f4:	81 f7       	brne	.-32     	; 0xd6 <KEYPAD_WaitForKeyRelease+0x2>
	                     // If no Key is pressed, Column lines will be High(0x0F)
}
  f6:	08 95       	ret

000000f8 <KEYPAD_WaitForKeyPress>:
	uint8_t var_keyPress_u8;
	do
	{
		do
		{
			M_ROW=0x0F;		  // Pull the ROW lines to low and Column lines high.
  f8:	9f e0       	ldi	r25, 0x0F	; 15
  fa:	98 bb       	out	0x18, r25	; 24
			var_keyPress_u8=M_COL & 0x0F;	  // Read the Columns, to check the key press
  fc:	86 b3       	in	r24, 0x16	; 22
  fe:	8f 70       	andi	r24, 0x0F	; 15
		}while(var_keyPress_u8==0x0F); // Wait till the Key is pressed,
 100:	8f 30       	cpi	r24, 0x0F	; 15
 102:	d9 f3       	breq	.-10     	; 0xfa <KEYPAD_WaitForKeyPress+0x2>
 104:	e7 eb       	ldi	r30, 0xB7	; 183
 106:	fb e0       	ldi	r31, 0x0B	; 11
 108:	31 97       	sbiw	r30, 0x01	; 1
 10a:	f1 f7       	brne	.-4      	; 0x108 <KEYPAD_WaitForKeyPress+0x10>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <KEYPAD_WaitForKeyPress+0x16>
 10e:	00 00       	nop
		// if a Key is pressed the corresponding Column line go low

		DELAY_ms(1);		  // Wait for some time(debounce Time);

		M_ROW=0x0F;		  // After debounce time, perform the above operation
 110:	98 bb       	out	0x18, r25	; 24
		var_keyPress_u8=M_COL & 0x0F;	  // to ensure the Key press.
 112:	86 b3       	in	r24, 0x16	; 22
 114:	8f 70       	andi	r24, 0x0F	; 15

	}while(var_keyPress_u8==0x0F);
 116:	8f 30       	cpi	r24, 0x0F	; 15
 118:	81 f3       	breq	.-32     	; 0xfa <KEYPAD_WaitForKeyPress+0x2>
}
 11a:	08 95       	ret

0000011c <KEYPAD_GetKey>:
 ***************************************************************************************************/
uint8_t KEYPAD_GetKey()
{
	uint8_t var_keyPress_u8;

	KEYPAD_WaitForKeyRelease();    // Wait for the previous key release
 11c:	0e 94 6a 00 	call	0xd4	; 0xd4 <KEYPAD_WaitForKeyRelease>
 120:	87 eb       	ldi	r24, 0xB7	; 183
 122:	9b e0       	ldi	r25, 0x0B	; 11
 124:	01 97       	sbiw	r24, 0x01	; 1
 126:	f1 f7       	brne	.-4      	; 0x124 <KEYPAD_GetKey+0x8>
 128:	00 c0       	rjmp	.+0      	; 0x12a <KEYPAD_GetKey+0xe>
 12a:	00 00       	nop
	DELAY_ms(1);

	KEYPAD_WaitForKeyPress();      // Wait for the new key press
 12c:	0e 94 7c 00 	call	0xf8	; 0xf8 <KEYPAD_WaitForKeyPress>
 130:	94 e0       	ldi	r25, 0x04	; 4
        4.Return the ScanCode(Combination of ROW & COL) for decoding the key.
 ***************************************************************************************************/
static uint8_t keypad_ScanKey()
{

	uint8_t var_keyScanCode_u8 = 0xEF,i, var_keyPress_u8;
 132:	8f ee       	ldi	r24, 0xEF	; 239

	for(i=0;i<0x04;i++)                // Scan All the 4-Rows for key press
	{
		M_ROW=var_keyScanCode_u8;        // Select 1-Row at a time for Scanning the Key
 134:	88 bb       	out	0x18, r24	; 24
 136:	e7 eb       	ldi	r30, 0xB7	; 183
 138:	fb e0       	ldi	r31, 0x0B	; 11
 13a:	31 97       	sbiw	r30, 0x01	; 1
 13c:	f1 f7       	brne	.-4      	; 0x13a <KEYPAD_GetKey+0x1e>
 13e:	00 c0       	rjmp	.+0      	; 0x140 <KEYPAD_GetKey+0x24>
 140:	00 00       	nop
		DELAY_ms(1);
		var_keyPress_u8=M_COL & 0x0F;    // Read the Column, for key press
 142:	26 b3       	in	r18, 0x16	; 22
 144:	2f 70       	andi	r18, 0x0F	; 15

		if(var_keyPress_u8!=0x0F)        // If the KEY press is detected for the selected
 146:	2f 30       	cpi	r18, 0x0F	; 15
 148:	21 f4       	brne	.+8      	; 0x152 <KEYPAD_GetKey+0x36>
			break;                     // ROW then stop Scanning,

		var_keyScanCode_u8=((var_keyScanCode_u8<<1)+0x01); // Rotate the ScanKey to SCAN the remaining Rows
 14a:	88 0f       	add	r24, r24
 14c:	8f 5f       	subi	r24, 0xFF	; 255
 14e:	91 50       	subi	r25, 0x01	; 1
static uint8_t keypad_ScanKey()
{

	uint8_t var_keyScanCode_u8 = 0xEF,i, var_keyPress_u8;

	for(i=0;i<0x04;i++)                // Scan All the 4-Rows for key press
 150:	89 f7       	brne	.-30     	; 0x134 <KEYPAD_GetKey+0x18>
		if(var_keyPress_u8!=0x0F)        // If the KEY press is detected for the selected
			break;                     // ROW then stop Scanning,

		var_keyScanCode_u8=((var_keyScanCode_u8<<1)+0x01); // Rotate the ScanKey to SCAN the remaining Rows
	}
	var_keyPress_u8 = var_keyPress_u8 + (var_keyScanCode_u8 & 0xf0); // Return the row and COL status to decode the key
 152:	80 7f       	andi	r24, 0xF0	; 240
 154:	28 0f       	add	r18, r24
	DELAY_ms(1);

	KEYPAD_WaitForKeyPress();      // Wait for the new key press
	var_keyPress_u8 = keypad_ScanKey();        // Scan for the key pressed.

	switch(var_keyPress_u8)                       // Decode the key
 156:	2e 3b       	cpi	r18, 0xBE	; 190
 158:	09 f4       	brne	.+2      	; 0x15c <KEYPAD_GetKey+0x40>
 15a:	40 c0       	rjmp	.+128    	; 0x1dc <KEYPAD_GetKey+0xc0>
 15c:	2f 3b       	cpi	r18, 0xBF	; 191
 15e:	98 f4       	brcc	.+38     	; 0x186 <KEYPAD_GetKey+0x6a>
 160:	2e 37       	cpi	r18, 0x7E	; 126
 162:	09 f4       	brne	.+2      	; 0x166 <KEYPAD_GetKey+0x4a>
 164:	43 c0       	rjmp	.+134    	; 0x1ec <KEYPAD_GetKey+0xd0>
 166:	2f 37       	cpi	r18, 0x7F	; 127
 168:	38 f4       	brcc	.+14     	; 0x178 <KEYPAD_GetKey+0x5c>
 16a:	2b 37       	cpi	r18, 0x7B	; 123
 16c:	d9 f1       	breq	.+118    	; 0x1e4 <KEYPAD_GetKey+0xc8>
 16e:	2d 37       	cpi	r18, 0x7D	; 125
 170:	d9 f1       	breq	.+118    	; 0x1e8 <KEYPAD_GetKey+0xcc>
 172:	27 37       	cpi	r18, 0x77	; 119
 174:	e9 f5       	brne	.+122    	; 0x1f0 <KEYPAD_GetKey+0xd4>
 176:	34 c0       	rjmp	.+104    	; 0x1e0 <KEYPAD_GetKey+0xc4>
 178:	2b 3b       	cpi	r18, 0xBB	; 187
 17a:	61 f1       	breq	.+88     	; 0x1d4 <KEYPAD_GetKey+0xb8>
 17c:	2d 3b       	cpi	r18, 0xBD	; 189
 17e:	61 f1       	breq	.+88     	; 0x1d8 <KEYPAD_GetKey+0xbc>
 180:	27 3b       	cpi	r18, 0xB7	; 183
 182:	b1 f5       	brne	.+108    	; 0x1f0 <KEYPAD_GetKey+0xd4>
 184:	25 c0       	rjmp	.+74     	; 0x1d0 <KEYPAD_GetKey+0xb4>
 186:	2e 3d       	cpi	r18, 0xDE	; 222
 188:	09 f1       	breq	.+66     	; 0x1cc <KEYPAD_GetKey+0xb0>
 18a:	2f 3d       	cpi	r18, 0xDF	; 223
 18c:	38 f4       	brcc	.+14     	; 0x19c <KEYPAD_GetKey+0x80>
 18e:	2b 3d       	cpi	r18, 0xDB	; 219
 190:	c9 f0       	breq	.+50     	; 0x1c4 <KEYPAD_GetKey+0xa8>
 192:	2d 3d       	cpi	r18, 0xDD	; 221
 194:	c9 f0       	breq	.+50     	; 0x1c8 <KEYPAD_GetKey+0xac>
 196:	27 3d       	cpi	r18, 0xD7	; 215
 198:	59 f5       	brne	.+86     	; 0x1f0 <KEYPAD_GetKey+0xd4>
 19a:	12 c0       	rjmp	.+36     	; 0x1c0 <KEYPAD_GetKey+0xa4>
 19c:	2b 3e       	cpi	r18, 0xEB	; 235
 19e:	51 f1       	breq	.+84     	; 0x1f4 <KEYPAD_GetKey+0xd8>
 1a0:	2c 3e       	cpi	r18, 0xEC	; 236
 1a2:	18 f4       	brcc	.+6      	; 0x1aa <KEYPAD_GetKey+0x8e>
 1a4:	27 3e       	cpi	r18, 0xE7	; 231
 1a6:	21 f5       	brne	.+72     	; 0x1f0 <KEYPAD_GetKey+0xd4>
 1a8:	05 c0       	rjmp	.+10     	; 0x1b4 <KEYPAD_GetKey+0x98>
 1aa:	2d 3e       	cpi	r18, 0xED	; 237
 1ac:	29 f0       	breq	.+10     	; 0x1b8 <KEYPAD_GetKey+0x9c>
 1ae:	2e 3e       	cpi	r18, 0xEE	; 238
 1b0:	f9 f4       	brne	.+62     	; 0x1f0 <KEYPAD_GetKey+0xd4>
 1b2:	04 c0       	rjmp	.+8      	; 0x1bc <KEYPAD_GetKey+0xa0>
	{
	case 0xe7: var_keyPress_u8='C'; break;
 1b4:	83 e4       	ldi	r24, 0x43	; 67
 1b6:	08 95       	ret
	case 0xeb: var_keyPress_u8='D'; break;
	case 0xed: var_keyPress_u8='E'; break;
 1b8:	85 e4       	ldi	r24, 0x45	; 69
 1ba:	08 95       	ret
	case 0xee: var_keyPress_u8='F'; break;
 1bc:	86 e4       	ldi	r24, 0x46	; 70
 1be:	08 95       	ret
	case 0xd7: var_keyPress_u8='8'; break;
 1c0:	88 e3       	ldi	r24, 0x38	; 56
 1c2:	08 95       	ret
	case 0xdb: var_keyPress_u8='9'; break;
 1c4:	89 e3       	ldi	r24, 0x39	; 57
 1c6:	08 95       	ret
	case 0xdd: var_keyPress_u8='A'; break;
 1c8:	81 e4       	ldi	r24, 0x41	; 65
 1ca:	08 95       	ret
	case 0xde: var_keyPress_u8='B'; break;
 1cc:	82 e4       	ldi	r24, 0x42	; 66
 1ce:	08 95       	ret
	case 0xb7: var_keyPress_u8='4'; break;
 1d0:	84 e3       	ldi	r24, 0x34	; 52
 1d2:	08 95       	ret
	case 0xbb: var_keyPress_u8='5'; break;
 1d4:	85 e3       	ldi	r24, 0x35	; 53
 1d6:	08 95       	ret
	case 0xbd: var_keyPress_u8='6'; break;
 1d8:	86 e3       	ldi	r24, 0x36	; 54
 1da:	08 95       	ret
	case 0xbe: var_keyPress_u8='7'; break;
 1dc:	87 e3       	ldi	r24, 0x37	; 55
 1de:	08 95       	ret
	case 0x77: var_keyPress_u8='0'; break;
 1e0:	80 e3       	ldi	r24, 0x30	; 48
 1e2:	08 95       	ret
	case 0x7b: var_keyPress_u8='1'; break;
 1e4:	81 e3       	ldi	r24, 0x31	; 49
 1e6:	08 95       	ret
	case 0x7d: var_keyPress_u8='2'; break;
 1e8:	82 e3       	ldi	r24, 0x32	; 50
 1ea:	08 95       	ret
	case 0x7e: var_keyPress_u8='3'; break;
 1ec:	83 e3       	ldi	r24, 0x33	; 51
 1ee:	08 95       	ret
	default  : var_keyPress_u8='z'; break;
 1f0:	8a e7       	ldi	r24, 0x7A	; 122
 1f2:	08 95       	ret
	var_keyPress_u8 = keypad_ScanKey();        // Scan for the key pressed.

	switch(var_keyPress_u8)                       // Decode the key
	{
	case 0xe7: var_keyPress_u8='C'; break;
	case 0xeb: var_keyPress_u8='D'; break;
 1f4:	84 e4       	ldi	r24, 0x44	; 68
	case 0x7d: var_keyPress_u8='2'; break;
	case 0x7e: var_keyPress_u8='3'; break;
	default  : var_keyPress_u8='z'; break;
	}
	return(var_keyPress_u8);                      // Return the key
}
 1f6:	08 95       	ret

000001f8 <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
 1f8:	98 2f       	mov	r25, r24
 1fa:	84 ff       	sbrs	r24, 4
 1fc:	02 c0       	rjmp	.+4      	; 0x202 <lcd_SendNibble+0xa>
 1fe:	ac 9a       	sbi	0x15, 4	; 21
 200:	01 c0       	rjmp	.+2      	; 0x204 <lcd_SendNibble+0xc>
 202:	ac 98       	cbi	0x15, 4	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
 204:	95 ff       	sbrs	r25, 5
 206:	02 c0       	rjmp	.+4      	; 0x20c <lcd_SendNibble+0x14>
 208:	ad 9a       	sbi	0x15, 5	; 21
 20a:	01 c0       	rjmp	.+2      	; 0x20e <lcd_SendNibble+0x16>
 20c:	ad 98       	cbi	0x15, 5	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
 20e:	96 ff       	sbrs	r25, 6
 210:	02 c0       	rjmp	.+4      	; 0x216 <lcd_SendNibble+0x1e>
 212:	ae 9a       	sbi	0x15, 6	; 21
 214:	01 c0       	rjmp	.+2      	; 0x218 <lcd_SendNibble+0x20>
 216:	ae 98       	cbi	0x15, 6	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 218:	88 23       	and	r24, r24
 21a:	14 f4       	brge	.+4      	; 0x220 <lcd_SendNibble+0x28>
 21c:	af 9a       	sbi	0x15, 7	; 21
 21e:	08 95       	ret
 220:	af 98       	cbi	0x15, 7	; 21
 222:	08 95       	ret

00000224 <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
 224:	a7 98       	cbi	0x14, 7	; 20
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 226:	95 98       	cbi	0x12, 5	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
 228:	96 9a       	sbi	0x12, 6	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 22a:	ea e0       	ldi	r30, 0x0A	; 10
 22c:	f1 e0       	ldi	r31, 0x01	; 1
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
 22e:	97 98       	cbi	0x12, 7	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 230:	88 e2       	ldi	r24, 0x28	; 40
 232:	8a 95       	dec	r24
 234:	f1 f7       	brne	.-4      	; 0x232 <lcd_BusyCheck+0xe>
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
 236:	97 9a       	sbi	0x12, 7	; 18
 238:	98 e2       	ldi	r25, 0x28	; 40
 23a:	9a 95       	dec	r25
 23c:	f1 f7       	brne	.-4      	; 0x23a <lcd_BusyCheck+0x16>
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
 23e:	83 b3       	in	r24, 0x13	; 19


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 240:	90 81       	ld	r25, Z
 242:	94 30       	cpi	r25, 0x04	; 4
 244:	41 f4       	brne	.+16     	; 0x256 <lcd_BusyCheck+0x32>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
 246:	97 98       	cbi	0x12, 7	; 18
 248:	98 e2       	ldi	r25, 0x28	; 40
 24a:	9a 95       	dec	r25
 24c:	f1 f7       	brne	.-4      	; 0x24a <lcd_BusyCheck+0x26>
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
 24e:	97 9a       	sbi	0x12, 7	; 18
 250:	98 e2       	ldi	r25, 0x28	; 40
 252:	9a 95       	dec	r25
 254:	f1 f7       	brne	.-4      	; 0x252 <lcd_BusyCheck+0x2e>
			DELAY_us(10);
		}	
	}while(busyflag);
 256:	88 23       	and	r24, r24
 258:	54 f3       	brlt	.-44     	; 0x22e <lcd_BusyCheck+0xa>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
 25a:	a7 9a       	sbi	0x14, 7	; 20
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
 25c:	08 95       	ret

0000025e <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 25e:	95 98       	cbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 260:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 262:	97 9a       	sbi	0x12, 7	; 18
 264:	88 e2       	ldi	r24, 0x28	; 40
 266:	8a 95       	dec	r24
 268:	f1 f7       	brne	.-4      	; 0x266 <lcd_SendCmdSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 26a:	97 98       	cbi	0x12, 7	; 18
}
 26c:	08 95       	ret

0000026e <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 26e:	95 9a       	sbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 270:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 272:	97 9a       	sbi	0x12, 7	; 18
 274:	88 e2       	ldi	r24, 0x28	; 40
 276:	8a 95       	dec	r24
 278:	f1 f7       	brne	.-4      	; 0x276 <lcd_SendDataSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 27a:	97 98       	cbi	0x12, 7	; 18
}
 27c:	08 95       	ret

0000027e <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 27e:	cf 93       	push	r28
 280:	c8 2f       	mov	r28, r24
	lcd_BusyCheck();
 282:	0e 94 12 01 	call	0x224	; 0x224 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 286:	80 91 0a 01 	lds	r24, 0x010A
 28a:	88 30       	cpi	r24, 0x08	; 8
 28c:	21 f4       	brne	.+8      	; 0x296 <LCD_CmdWrite+0x18>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 28e:	c5 bb       	out	0x15, r28	; 21
		lcd_SendCmdSignals();  // Signals for command write operation
 290:	0e 94 2f 01 	call	0x25e	; 0x25e <lcd_SendCmdSignals>
 294:	0e c0       	rjmp	.+28     	; 0x2b2 <LCD_CmdWrite+0x34>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 296:	84 30       	cpi	r24, 0x04	; 4
 298:	61 f4       	brne	.+24     	; 0x2b2 <LCD_CmdWrite+0x34>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 29a:	8c 2f       	mov	r24, r28
 29c:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 2a0:	0e 94 2f 01 	call	0x25e	; 0x25e <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 2a4:	8c 2f       	mov	r24, r28
 2a6:	82 95       	swap	r24
 2a8:	80 7f       	andi	r24, 0xF0	; 240
 2aa:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
		lcd_SendCmdSignals();
 2ae:	0e 94 2f 01 	call	0x25e	; 0x25e <lcd_SendCmdSignals>
	}
}
 2b2:	cf 91       	pop	r28
 2b4:	08 95       	ret

000002b6 <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 2b6:	80 91 07 01 	lds	r24, 0x0107
 2ba:	8f 5f       	subi	r24, 0xFF	; 255
 2bc:	80 93 07 01 	sts	0x0107, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 2c0:	10 92 06 01 	sts	0x0106, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 2c4:	90 91 08 01 	lds	r25, 0x0108
 2c8:	98 17       	cp	r25, r24
 2ca:	18 f4       	brcc	.+6      	; 0x2d2 <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	80 93 07 01 	sts	0x0107, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 2d2:	80 91 07 01 	lds	r24, 0x0107
 2d6:	e0 e0       	ldi	r30, 0x00	; 0
 2d8:	f1 e0       	ldi	r31, 0x01	; 1
 2da:	e8 0f       	add	r30, r24
 2dc:	f1 1d       	adc	r31, r1
 2de:	80 81       	ld	r24, Z
 2e0:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_CmdWrite>
}
 2e4:	08 95       	ret

000002e6 <LCD_GoToLine>:
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 2e6:	90 91 08 01 	lds	r25, 0x0108
 2ea:	98 17       	cp	r25, r24
 2ec:	58 f0       	brcs	.+22     	; 0x304 <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 2ee:	10 92 06 01 	sts	0x0106, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 2f2:	80 93 07 01 	sts	0x0107, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 2f6:	e0 e0       	ldi	r30, 0x00	; 0
 2f8:	f1 e0       	ldi	r31, 0x01	; 1
 2fa:	e8 0f       	add	r30, r24
 2fc:	f1 1d       	adc	r31, r1
 2fe:	80 81       	ld	r24, Z
 300:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_CmdWrite>
 304:	08 95       	ret

00000306 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 306:	81 e0       	ldi	r24, 0x01	; 1
 308:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 30c:	81 e0       	ldi	r24, 0x01	; 1
 30e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <LCD_GoToLine>
}
 312:	08 95       	ret

00000314 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 314:	9f ef       	ldi	r25, 0xFF	; 255
 316:	94 bb       	out	0x14, r25	; 20
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 318:	91 bb       	out	0x11, r25	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 31a:	80 93 0a 01 	sts	0x010A, r24
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 31e:	40 93 09 01 	sts	0x0109, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 322:	60 93 08 01 	sts	0x0108, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 326:	63 30       	cpi	r22, 0x03	; 3
 328:	40 f0       	brcs	.+16     	; 0x33a <LCD_Init+0x26>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 32a:	4f 70       	andi	r20, 0x0F	; 15
 32c:	84 2f       	mov	r24, r20
 32e:	80 57       	subi	r24, 0x70	; 112
 330:	80 93 03 01 	sts	0x0103, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 334:	40 53       	subi	r20, 0x30	; 48
 336:	40 93 04 01 	sts	0x0104, r20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 33a:	8f e7       	ldi	r24, 0x7F	; 127
 33c:	99 ea       	ldi	r25, 0xA9	; 169
 33e:	a3 e0       	ldi	r26, 0x03	; 3
 340:	81 50       	subi	r24, 0x01	; 1
 342:	90 40       	sbci	r25, 0x00	; 0
 344:	a0 40       	sbci	r26, 0x00	; 0
 346:	e1 f7       	brne	.-8      	; 0x340 <LCD_Init+0x2c>
 348:	00 c0       	rjmp	.+0      	; 0x34a <LCD_Init+0x36>
 34a:	00 00       	nop
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 34c:	80 91 0a 01 	lds	r24, 0x010A
 350:	88 30       	cpi	r24, 0x08	; 8
 352:	21 f4       	brne	.+8      	; 0x35c <LCD_Init+0x48>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 354:	88 e3       	ldi	r24, 0x38	; 56
 356:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_CmdWrite>
 35a:	34 c0       	rjmp	.+104    	; 0x3c4 <LCD_Init+0xb0>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 35c:	84 30       	cpi	r24, 0x04	; 4
 35e:	91 f5       	brne	.+100    	; 0x3c4 <LCD_Init+0xb0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 360:	80 e3       	ldi	r24, 0x30	; 48
 362:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
	lcd_SendCmdSignals();
 366:	0e 94 2f 01 	call	0x25e	; 0x25e <lcd_SendCmdSignals>
 36a:	8f e7       	ldi	r24, 0x7F	; 127
 36c:	99 ea       	ldi	r25, 0xA9	; 169
 36e:	a3 e0       	ldi	r26, 0x03	; 3
 370:	81 50       	subi	r24, 0x01	; 1
 372:	90 40       	sbci	r25, 0x00	; 0
 374:	a0 40       	sbci	r26, 0x00	; 0
 376:	e1 f7       	brne	.-8      	; 0x370 <LCD_Init+0x5c>
 378:	00 c0       	rjmp	.+0      	; 0x37a <LCD_Init+0x66>
 37a:	00 00       	nop
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 37c:	80 e3       	ldi	r24, 0x30	; 48
 37e:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
	lcd_SendCmdSignals();
 382:	0e 94 2f 01 	call	0x25e	; 0x25e <lcd_SendCmdSignals>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 386:	a7 e5       	ldi	r26, 0x57	; 87
 388:	b2 e0       	ldi	r27, 0x02	; 2
 38a:	11 97       	sbiw	r26, 0x01	; 1
 38c:	f1 f7       	brne	.-4      	; 0x38a <LCD_Init+0x76>
 38e:	00 c0       	rjmp	.+0      	; 0x390 <LCD_Init+0x7c>
 390:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x30);
 392:	80 e3       	ldi	r24, 0x30	; 48
 394:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
	lcd_SendCmdSignals();
 398:	0e 94 2f 01 	call	0x25e	; 0x25e <lcd_SendCmdSignals>
 39c:	87 e5       	ldi	r24, 0x57	; 87
 39e:	92 e0       	ldi	r25, 0x02	; 2
 3a0:	01 97       	sbiw	r24, 0x01	; 1
 3a2:	f1 f7       	brne	.-4      	; 0x3a0 <LCD_Init+0x8c>
 3a4:	00 c0       	rjmp	.+0      	; 0x3a6 <LCD_Init+0x92>
 3a6:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x20);
 3a8:	80 e2       	ldi	r24, 0x20	; 32
 3aa:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
	lcd_SendCmdSignals();
 3ae:	0e 94 2f 01 	call	0x25e	; 0x25e <lcd_SendCmdSignals>
 3b2:	a7 e5       	ldi	r26, 0x57	; 87
 3b4:	b2 e0       	ldi	r27, 0x02	; 2
 3b6:	11 97       	sbiw	r26, 0x01	; 1
 3b8:	f1 f7       	brne	.-4      	; 0x3b6 <LCD_Init+0xa2>
 3ba:	00 c0       	rjmp	.+0      	; 0x3bc <LCD_Init+0xa8>
 3bc:	00 00       	nop
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 3be:	88 e2       	ldi	r24, 0x28	; 40
 3c0:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 3c4:	8e e0       	ldi	r24, 0x0E	; 14
 3c6:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 3ca:	0e 94 83 01 	call	0x306	; 0x306 <LCD_Clear>
}
 3ce:	08 95       	ret

000003d0 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 3d0:	cf 93       	push	r28
 3d2:	c8 2f       	mov	r28, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 3d4:	90 91 09 01 	lds	r25, 0x0109
 3d8:	80 91 06 01 	lds	r24, 0x0106
 3dc:	89 17       	cp	r24, r25
 3de:	18 f4       	brcc	.+6      	; 0x3e6 <LCD_DisplayChar+0x16>
 3e0:	ca 30       	cpi	r28, 0x0A	; 10
 3e2:	29 f4       	brne	.+10     	; 0x3ee <LCD_DisplayChar+0x1e>
 3e4:	22 c0       	rjmp	.+68     	; 0x42a <LCD_DisplayChar+0x5a>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 3e6:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 3ea:	ca 30       	cpi	r28, 0x0A	; 10
 3ec:	01 f1       	breq	.+64     	; 0x42e <LCD_DisplayChar+0x5e>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 3ee:	0e 94 12 01 	call	0x224	; 0x224 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 3f2:	80 91 0a 01 	lds	r24, 0x010A
 3f6:	88 30       	cpi	r24, 0x08	; 8
 3f8:	21 f4       	brne	.+8      	; 0x402 <LCD_DisplayChar+0x32>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 3fa:	c5 bb       	out	0x15, r28	; 21
		lcd_SendDataSignals();  // Signals for data write operation
 3fc:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_SendDataSignals>
 400:	0e c0       	rjmp	.+28     	; 0x41e <LCD_DisplayChar+0x4e>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 402:	84 30       	cpi	r24, 0x04	; 4
 404:	61 f4       	brne	.+24     	; 0x41e <LCD_DisplayChar+0x4e>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 406:	8c 2f       	mov	r24, r28
 408:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 40c:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 410:	8c 2f       	mov	r24, r28
 412:	82 95       	swap	r24
 414:	80 7f       	andi	r24, 0xF0	; 240
 416:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <lcd_SendNibble>
		lcd_SendDataSignals();
 41a:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 41e:	80 91 06 01 	lds	r24, 0x0106
 422:	8f 5f       	subi	r24, 0xFF	; 255
 424:	80 93 06 01 	sts	0x0106, r24
 428:	02 c0       	rjmp	.+4      	; 0x42e <LCD_DisplayChar+0x5e>
{
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 42a:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <LCD_GoToNextLine>
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
	}
}
 42e:	cf 91       	pop	r28
 430:	08 95       	ret

00000432 <main>:

/* Program to demonstrate the hex-Keypad interface*/
int  main()
{
  uint8_t key;
  LCD_Init(4,2,16);            /*Initialize the 2x16 LCD in 8-bit mode */
 432:	84 e0       	ldi	r24, 0x04	; 4
 434:	62 e0       	ldi	r22, 0x02	; 2
 436:	40 e1       	ldi	r20, 0x10	; 16
 438:	0e 94 8a 01 	call	0x314	; 0x314 <LCD_Init>
  KEYPAD_Init();               /*Configure the ROWs and COLUMNs for keypad scanning*/
 43c:	0e 94 67 00 	call	0xce	; 0xce <KEYPAD_Init>

	while(1)
	{
		key = KEYPAD_GetKey(); /*Get the Ascii value of the key Pressed */
 440:	0e 94 8e 00 	call	0x11c	; 0x11c <KEYPAD_GetKey>
		LCD_DisplayChar(key);  /*Display the key pressed */
 444:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <LCD_DisplayChar>
 448:	fb cf       	rjmp	.-10     	; 0x440 <main+0xe>

0000044a <_exit>:
 44a:	f8 94       	cli

0000044c <__stop_program>:
 44c:	ff cf       	rjmp	.-2      	; 0x44c <__stop_program>
