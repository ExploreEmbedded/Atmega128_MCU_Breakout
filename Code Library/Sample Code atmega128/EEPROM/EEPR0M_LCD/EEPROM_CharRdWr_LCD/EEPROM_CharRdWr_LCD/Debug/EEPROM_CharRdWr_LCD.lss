
EEPROM_CharRdWr_LCD.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  00000716  000007aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000716  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  00800122  00800122  000007cc  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000007cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000e98  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000100  00000000  00000000  00000f20  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e0d  00000000  00000000  00001020  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000480  00000000  00000000  00001e2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000087a  00000000  00000000  000022ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000200  00000000  00000000  00002b28  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000548  00000000  00000000  00002d28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000008dd  00000000  00000000  00003270  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 e1       	ldi	r30, 0x16	; 22
  a0:	f7 e0       	ldi	r31, 0x07	; 7
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 32       	cpi	r26, 0x22	; 34
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a2 e2       	ldi	r26, 0x22	; 34
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a7 32       	cpi	r26, 0x27	; 39
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 84 00 	call	0x108	; 0x108 <main>
  c6:	0c 94 89 03 	jmp	0x712	; 0x712 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <DELAY_sec>:
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  ce:	00 97       	sbiw	r24, 0x00	; 0
  d0:	59 f0       	breq	.+22     	; 0xe8 <DELAY_sec+0x1a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  d2:	2f ef       	ldi	r18, 0xFF	; 255
  d4:	33 ed       	ldi	r19, 0xD3	; 211
  d6:	40 e3       	ldi	r20, 0x30	; 48
  d8:	21 50       	subi	r18, 0x01	; 1
  da:	30 40       	sbci	r19, 0x00	; 0
  dc:	40 40       	sbci	r20, 0x00	; 0
  de:	e1 f7       	brne	.-8      	; 0xd8 <DELAY_sec+0xa>
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <DELAY_sec+0x14>
  e2:	00 00       	nop
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
  e4:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  e6:	a9 f7       	brne	.-22     	; 0xd2 <DELAY_sec+0x4>
  e8:	08 95       	ret

000000ea <EEPROM_WriteByte>:
 * description: This function is used to write the data at specified EEPROM_address..

 **************************************************************************************************/
void EEPROM_WriteByte(uint16_t var_eepromAddress_u16, uint8_t var_eepromData_u8)
{
	while(util_IsBitSet(EECR,EEWE)); // Wait for completion of previous write.
  ea:	e1 99       	sbic	0x1c, 1	; 28
  ec:	fe cf       	rjmp	.-4      	; 0xea <EEPROM_WriteByte>
	                                 // EEWE will be cleared by hardware once Eeprom write is completed.

	EEAR = var_eepromAddress_u16;  //Load the eeprom address and data
  ee:	9f bb       	out	0x1f, r25	; 31
  f0:	8e bb       	out	0x1e, r24	; 30
	EEDR = var_eepromData_u8;
  f2:	6d bb       	out	0x1d, r22	; 29

	util_BitSet(EECR,EEMWE);    // Eeprom Master Write Enable
  f4:	e2 9a       	sbi	0x1c, 2	; 28
	util_BitSet(EECR,EEWE);     // Start eeprom write by setting EEWE
  f6:	e1 9a       	sbi	0x1c, 1	; 28
}
  f8:	08 95       	ret

000000fa <EEPROM_ReadByte>:

 * description: This function is used to read the data from specified EEPROM_address.        
 ***************************************************************************************************/
uint8_t EEPROM_ReadByte(uint16_t var_eepromAddress_u16)
{
	while(util_IsBitSet(EECR,EEWE));  //Wait for completion of previous write if any.
  fa:	e1 99       	sbic	0x1c, 1	; 28
  fc:	fe cf       	rjmp	.-4      	; 0xfa <EEPROM_ReadByte>

	EEAR = var_eepromAddress_u16;    //Load the address from where the data needs to be read.
  fe:	9f bb       	out	0x1f, r25	; 31
 100:	8e bb       	out	0x1e, r24	; 30
	util_BitSet(EECR,EERE);   // start eeprom read by setting EERE
 102:	e0 9a       	sbi	0x1c, 0	; 28

	return EEDR;             // Return data from data register
 104:	8d b3       	in	r24, 0x1d	; 29
}
 106:	08 95       	ret

00000108 <main>:
void main() 
{
   unsigned char eeprom_address=0x00, write_char = 'X', read_char;

  /* Initialize the lcd before displaying any thing on the lcd */
    LCD_Init(4,2,16);												  
 108:	84 e0       	ldi	r24, 0x04	; 4
 10a:	62 e0       	ldi	r22, 0x02	; 2
 10c:	40 e1       	ldi	r20, 0x10	; 16
 10e:	0e 94 3c 01 	call	0x278	; 0x278 <LCD_Init>
 
   while(1)
    {					
	   	   LCD_GoToLine(1);							// Move the cursor to first line
           LCD_DisplayString("Eeprom Write: ");         //Display the message on first line
 112:	c0 e0       	ldi	r28, 0x00	; 0
 114:	d1 e0       	ldi	r29, 0x01	; 1
		   LCD_DisplayChar(write_char);			        //Display the char to be written 
		   EEPROM_WriteByte(eeprom_address,write_char);	// Write the data at memoryLocation	0x00

		   LCD_GoToLine(2);							// Move the cursor to Second line
		   LCD_DisplayString("Eeprom Read: ");          //Display the message on first line
 116:	0f e0       	ldi	r16, 0x0F	; 15
 118:	11 e0       	ldi	r17, 0x01	; 1
  /* Initialize the lcd before displaying any thing on the lcd */
    LCD_Init(4,2,16);												  
 
   while(1)
    {					
	   	   LCD_GoToLine(1);							// Move the cursor to first line
 11a:	81 e0       	ldi	r24, 0x01	; 1
 11c:	0e 94 25 01 	call	0x24a	; 0x24a <LCD_GoToLine>
           LCD_DisplayString("Eeprom Write: ");         //Display the message on first line
 120:	ce 01       	movw	r24, r28
 122:	0e 94 cb 01 	call	0x396	; 0x396 <LCD_DisplayString>
		   LCD_DisplayChar(write_char);			        //Display the char to be written 
 126:	88 e5       	ldi	r24, 0x58	; 88
 128:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>
		   EEPROM_WriteByte(eeprom_address,write_char);	// Write the data at memoryLocation	0x00
 12c:	80 e0       	ldi	r24, 0x00	; 0
 12e:	90 e0       	ldi	r25, 0x00	; 0
 130:	68 e5       	ldi	r22, 0x58	; 88
 132:	0e 94 75 00 	call	0xea	; 0xea <EEPROM_WriteByte>

		   LCD_GoToLine(2);							// Move the cursor to Second line
 136:	82 e0       	ldi	r24, 0x02	; 2
 138:	0e 94 25 01 	call	0x24a	; 0x24a <LCD_GoToLine>
		   LCD_DisplayString("Eeprom Read: ");          //Display the message on first line
 13c:	c8 01       	movw	r24, r16
 13e:	0e 94 cb 01 	call	0x396	; 0x396 <LCD_DisplayString>
		   read_char = EEPROM_ReadByte(eeprom_address);	// Read the data from memoryLocation 0x00
 142:	80 e0       	ldi	r24, 0x00	; 0
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	0e 94 7d 00 	call	0xfa	; 0xfa <EEPROM_ReadByte>
		   LCD_DisplayChar(read_char);			        //Display the read data 
 14a:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>
 14e:	e5 cf       	rjmp	.-54     	; 0x11a <main+0x12>

00000150 <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
 150:	98 2f       	mov	r25, r24
 152:	84 ff       	sbrs	r24, 4
 154:	02 c0       	rjmp	.+4      	; 0x15a <lcd_SendNibble+0xa>
 156:	ac 9a       	sbi	0x15, 4	; 21
 158:	01 c0       	rjmp	.+2      	; 0x15c <lcd_SendNibble+0xc>
 15a:	ac 98       	cbi	0x15, 4	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
 15c:	95 ff       	sbrs	r25, 5
 15e:	02 c0       	rjmp	.+4      	; 0x164 <lcd_SendNibble+0x14>
 160:	ad 9a       	sbi	0x15, 5	; 21
 162:	01 c0       	rjmp	.+2      	; 0x166 <lcd_SendNibble+0x16>
 164:	ad 98       	cbi	0x15, 5	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
 166:	96 ff       	sbrs	r25, 6
 168:	02 c0       	rjmp	.+4      	; 0x16e <lcd_SendNibble+0x1e>
 16a:	ae 9a       	sbi	0x15, 6	; 21
 16c:	01 c0       	rjmp	.+2      	; 0x170 <lcd_SendNibble+0x20>
 16e:	ae 98       	cbi	0x15, 6	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 170:	88 23       	and	r24, r24
 172:	14 f4       	brge	.+4      	; 0x178 <lcd_SendNibble+0x28>
 174:	af 9a       	sbi	0x15, 7	; 21
 176:	08 95       	ret
 178:	af 98       	cbi	0x15, 7	; 21
 17a:	08 95       	ret

0000017c <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
 17c:	a7 98       	cbi	0x14, 7	; 20
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 17e:	95 98       	cbi	0x12, 5	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
 180:	96 9a       	sbi	0x12, 6	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 182:	e6 e2       	ldi	r30, 0x26	; 38
 184:	f1 e0       	ldi	r31, 0x01	; 1
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
 186:	97 98       	cbi	0x12, 7	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 188:	85 e3       	ldi	r24, 0x35	; 53
 18a:	8a 95       	dec	r24
 18c:	f1 f7       	brne	.-4      	; 0x18a <lcd_BusyCheck+0xe>
 18e:	00 00       	nop
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
 190:	97 9a       	sbi	0x12, 7	; 18
 192:	95 e3       	ldi	r25, 0x35	; 53
 194:	9a 95       	dec	r25
 196:	f1 f7       	brne	.-4      	; 0x194 <lcd_BusyCheck+0x18>
 198:	00 00       	nop
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
 19a:	83 b3       	in	r24, 0x13	; 19


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 19c:	90 81       	ld	r25, Z
 19e:	94 30       	cpi	r25, 0x04	; 4
 1a0:	51 f4       	brne	.+20     	; 0x1b6 <lcd_BusyCheck+0x3a>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
 1a2:	97 98       	cbi	0x12, 7	; 18
 1a4:	95 e3       	ldi	r25, 0x35	; 53
 1a6:	9a 95       	dec	r25
 1a8:	f1 f7       	brne	.-4      	; 0x1a6 <lcd_BusyCheck+0x2a>
 1aa:	00 00       	nop
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
 1ac:	97 9a       	sbi	0x12, 7	; 18
 1ae:	95 e3       	ldi	r25, 0x35	; 53
 1b0:	9a 95       	dec	r25
 1b2:	f1 f7       	brne	.-4      	; 0x1b0 <lcd_BusyCheck+0x34>
 1b4:	00 00       	nop
			DELAY_us(10);
		}	
	}while(busyflag);
 1b6:	88 23       	and	r24, r24
 1b8:	34 f3       	brlt	.-52     	; 0x186 <lcd_BusyCheck+0xa>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
 1ba:	a7 9a       	sbi	0x14, 7	; 20
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
 1bc:	08 95       	ret

000001be <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 1be:	95 98       	cbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 1c0:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 1c2:	97 9a       	sbi	0x12, 7	; 18
 1c4:	85 e3       	ldi	r24, 0x35	; 53
 1c6:	8a 95       	dec	r24
 1c8:	f1 f7       	brne	.-4      	; 0x1c6 <lcd_SendCmdSignals+0x8>
 1ca:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 1cc:	97 98       	cbi	0x12, 7	; 18
}
 1ce:	08 95       	ret

000001d0 <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 1d0:	95 9a       	sbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 1d2:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 1d4:	97 9a       	sbi	0x12, 7	; 18
 1d6:	85 e3       	ldi	r24, 0x35	; 53
 1d8:	8a 95       	dec	r24
 1da:	f1 f7       	brne	.-4      	; 0x1d8 <lcd_SendDataSignals+0x8>
 1dc:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 1de:	97 98       	cbi	0x12, 7	; 18
}
 1e0:	08 95       	ret

000001e2 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 1e2:	cf 93       	push	r28
 1e4:	c8 2f       	mov	r28, r24
	lcd_BusyCheck();
 1e6:	0e 94 be 00 	call	0x17c	; 0x17c <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 1ea:	80 91 26 01 	lds	r24, 0x0126
 1ee:	88 30       	cpi	r24, 0x08	; 8
 1f0:	21 f4       	brne	.+8      	; 0x1fa <LCD_CmdWrite+0x18>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 1f2:	c5 bb       	out	0x15, r28	; 21
		lcd_SendCmdSignals();  // Signals for command write operation
 1f4:	0e 94 df 00 	call	0x1be	; 0x1be <lcd_SendCmdSignals>
 1f8:	0e c0       	rjmp	.+28     	; 0x216 <LCD_CmdWrite+0x34>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 1fa:	84 30       	cpi	r24, 0x04	; 4
 1fc:	61 f4       	brne	.+24     	; 0x216 <LCD_CmdWrite+0x34>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 1fe:	8c 2f       	mov	r24, r28
 200:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 204:	0e 94 df 00 	call	0x1be	; 0x1be <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 208:	8c 2f       	mov	r24, r28
 20a:	82 95       	swap	r24
 20c:	80 7f       	andi	r24, 0xF0	; 240
 20e:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
		lcd_SendCmdSignals();
 212:	0e 94 df 00 	call	0x1be	; 0x1be <lcd_SendCmdSignals>
	}
}
 216:	cf 91       	pop	r28
 218:	08 95       	ret

0000021a <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 21a:	80 91 23 01 	lds	r24, 0x0123
 21e:	8f 5f       	subi	r24, 0xFF	; 255
 220:	80 93 23 01 	sts	0x0123, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 224:	10 92 22 01 	sts	0x0122, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 228:	90 91 24 01 	lds	r25, 0x0124
 22c:	98 17       	cp	r25, r24
 22e:	18 f4       	brcc	.+6      	; 0x236 <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 230:	81 e0       	ldi	r24, 0x01	; 1
 232:	80 93 23 01 	sts	0x0123, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 236:	80 91 23 01 	lds	r24, 0x0123
 23a:	ed e1       	ldi	r30, 0x1D	; 29
 23c:	f1 e0       	ldi	r31, 0x01	; 1
 23e:	e8 0f       	add	r30, r24
 240:	f1 1d       	adc	r31, r1
 242:	80 81       	ld	r24, Z
 244:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_CmdWrite>
}
 248:	08 95       	ret

0000024a <LCD_GoToLine>:
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 24a:	90 91 24 01 	lds	r25, 0x0124
 24e:	98 17       	cp	r25, r24
 250:	58 f0       	brcs	.+22     	; 0x268 <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 252:	10 92 22 01 	sts	0x0122, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 256:	80 93 23 01 	sts	0x0123, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 25a:	ed e1       	ldi	r30, 0x1D	; 29
 25c:	f1 e0       	ldi	r31, 0x01	; 1
 25e:	e8 0f       	add	r30, r24
 260:	f1 1d       	adc	r31, r1
 262:	80 81       	ld	r24, Z
 264:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_CmdWrite>
 268:	08 95       	ret

0000026a <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 26a:	81 e0       	ldi	r24, 0x01	; 1
 26c:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 270:	81 e0       	ldi	r24, 0x01	; 1
 272:	0e 94 25 01 	call	0x24a	; 0x24a <LCD_GoToLine>
}
 276:	08 95       	ret

00000278 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 278:	9f ef       	ldi	r25, 0xFF	; 255
 27a:	94 bb       	out	0x14, r25	; 20
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 27c:	91 bb       	out	0x11, r25	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 27e:	80 93 26 01 	sts	0x0126, r24
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 282:	40 93 25 01 	sts	0x0125, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 286:	60 93 24 01 	sts	0x0124, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 28a:	63 30       	cpi	r22, 0x03	; 3
 28c:	40 f0       	brcs	.+16     	; 0x29e <LCD_Init+0x26>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 28e:	4f 70       	andi	r20, 0x0F	; 15
 290:	84 2f       	mov	r24, r20
 292:	80 57       	subi	r24, 0x70	; 112
 294:	80 93 20 01 	sts	0x0120, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 298:	40 53       	subi	r20, 0x30	; 48
 29a:	40 93 21 01 	sts	0x0121, r20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 29e:	8f ef       	ldi	r24, 0xFF	; 255
 2a0:	91 ee       	ldi	r25, 0xE1	; 225
 2a2:	a4 e0       	ldi	r26, 0x04	; 4
 2a4:	81 50       	subi	r24, 0x01	; 1
 2a6:	90 40       	sbci	r25, 0x00	; 0
 2a8:	a0 40       	sbci	r26, 0x00	; 0
 2aa:	e1 f7       	brne	.-8      	; 0x2a4 <LCD_Init+0x2c>
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <LCD_Init+0x36>
 2ae:	00 00       	nop
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 2b0:	80 91 26 01 	lds	r24, 0x0126
 2b4:	88 30       	cpi	r24, 0x08	; 8
 2b6:	21 f4       	brne	.+8      	; 0x2c0 <LCD_Init+0x48>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 2b8:	88 e3       	ldi	r24, 0x38	; 56
 2ba:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_CmdWrite>
 2be:	34 c0       	rjmp	.+104    	; 0x328 <LCD_Init+0xb0>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 2c0:	84 30       	cpi	r24, 0x04	; 4
 2c2:	91 f5       	brne	.+100    	; 0x328 <LCD_Init+0xb0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 2c4:	80 e3       	ldi	r24, 0x30	; 48
 2c6:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2ca:	0e 94 df 00 	call	0x1be	; 0x1be <lcd_SendCmdSignals>
 2ce:	8f ef       	ldi	r24, 0xFF	; 255
 2d0:	91 ee       	ldi	r25, 0xE1	; 225
 2d2:	a4 e0       	ldi	r26, 0x04	; 4
 2d4:	81 50       	subi	r24, 0x01	; 1
 2d6:	90 40       	sbci	r25, 0x00	; 0
 2d8:	a0 40       	sbci	r26, 0x00	; 0
 2da:	e1 f7       	brne	.-8      	; 0x2d4 <LCD_Init+0x5c>
 2dc:	00 c0       	rjmp	.+0      	; 0x2de <LCD_Init+0x66>
 2de:	00 00       	nop
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 2e0:	80 e3       	ldi	r24, 0x30	; 48
 2e2:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2e6:	0e 94 df 00 	call	0x1be	; 0x1be <lcd_SendCmdSignals>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2ea:	af e1       	ldi	r26, 0x1F	; 31
 2ec:	b3 e0       	ldi	r27, 0x03	; 3
 2ee:	11 97       	sbiw	r26, 0x01	; 1
 2f0:	f1 f7       	brne	.-4      	; 0x2ee <LCD_Init+0x76>
 2f2:	00 c0       	rjmp	.+0      	; 0x2f4 <LCD_Init+0x7c>
 2f4:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x30);
 2f6:	80 e3       	ldi	r24, 0x30	; 48
 2f8:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2fc:	0e 94 df 00 	call	0x1be	; 0x1be <lcd_SendCmdSignals>
 300:	8f e1       	ldi	r24, 0x1F	; 31
 302:	93 e0       	ldi	r25, 0x03	; 3
 304:	01 97       	sbiw	r24, 0x01	; 1
 306:	f1 f7       	brne	.-4      	; 0x304 <LCD_Init+0x8c>
 308:	00 c0       	rjmp	.+0      	; 0x30a <LCD_Init+0x92>
 30a:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x20);
 30c:	80 e2       	ldi	r24, 0x20	; 32
 30e:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
	lcd_SendCmdSignals();
 312:	0e 94 df 00 	call	0x1be	; 0x1be <lcd_SendCmdSignals>
 316:	af e1       	ldi	r26, 0x1F	; 31
 318:	b3 e0       	ldi	r27, 0x03	; 3
 31a:	11 97       	sbiw	r26, 0x01	; 1
 31c:	f1 f7       	brne	.-4      	; 0x31a <LCD_Init+0xa2>
 31e:	00 c0       	rjmp	.+0      	; 0x320 <LCD_Init+0xa8>
 320:	00 00       	nop
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 322:	88 e2       	ldi	r24, 0x28	; 40
 324:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 328:	8e e0       	ldi	r24, 0x0E	; 14
 32a:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 32e:	0e 94 35 01 	call	0x26a	; 0x26a <LCD_Clear>
}
 332:	08 95       	ret

00000334 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 334:	cf 93       	push	r28
 336:	c8 2f       	mov	r28, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 338:	90 91 25 01 	lds	r25, 0x0125
 33c:	80 91 22 01 	lds	r24, 0x0122
 340:	89 17       	cp	r24, r25
 342:	18 f4       	brcc	.+6      	; 0x34a <LCD_DisplayChar+0x16>
 344:	ca 30       	cpi	r28, 0x0A	; 10
 346:	29 f4       	brne	.+10     	; 0x352 <LCD_DisplayChar+0x1e>
 348:	22 c0       	rjmp	.+68     	; 0x38e <LCD_DisplayChar+0x5a>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 34a:	0e 94 0d 01 	call	0x21a	; 0x21a <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 34e:	ca 30       	cpi	r28, 0x0A	; 10
 350:	01 f1       	breq	.+64     	; 0x392 <LCD_DisplayChar+0x5e>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 352:	0e 94 be 00 	call	0x17c	; 0x17c <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 356:	80 91 26 01 	lds	r24, 0x0126
 35a:	88 30       	cpi	r24, 0x08	; 8
 35c:	21 f4       	brne	.+8      	; 0x366 <LCD_DisplayChar+0x32>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 35e:	c5 bb       	out	0x15, r28	; 21
		lcd_SendDataSignals();  // Signals for data write operation
 360:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <lcd_SendDataSignals>
 364:	0e c0       	rjmp	.+28     	; 0x382 <LCD_DisplayChar+0x4e>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 366:	84 30       	cpi	r24, 0x04	; 4
 368:	61 f4       	brne	.+24     	; 0x382 <LCD_DisplayChar+0x4e>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 36a:	8c 2f       	mov	r24, r28
 36c:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 370:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 374:	8c 2f       	mov	r24, r28
 376:	82 95       	swap	r24
 378:	80 7f       	andi	r24, 0xF0	; 240
 37a:	0e 94 a8 00 	call	0x150	; 0x150 <lcd_SendNibble>
		lcd_SendDataSignals();
 37e:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 382:	80 91 22 01 	lds	r24, 0x0122
 386:	8f 5f       	subi	r24, 0xFF	; 255
 388:	80 93 22 01 	sts	0x0122, r24
 38c:	02 c0       	rjmp	.+4      	; 0x392 <LCD_DisplayChar+0x5e>
{
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 38e:	0e 94 0d 01 	call	0x21a	; 0x21a <LCD_GoToNextLine>
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
	}
}
 392:	cf 91       	pop	r28
 394:	08 95       	ret

00000396 <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
 396:	cf 93       	push	r28
 398:	df 93       	push	r29
 39a:	ec 01       	movw	r28, r24
	while((*ptr_stringPointer_u8)!=0)
 39c:	88 81       	ld	r24, Y
 39e:	88 23       	and	r24, r24
 3a0:	31 f0       	breq	.+12     	; 0x3ae <LCD_DisplayString+0x18>
                 1.The ptr_stringPointer_u8 points to the first char of the string
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
 3a2:	21 96       	adiw	r28, 0x01	; 1
{
	while((*ptr_stringPointer_u8)!=0)
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 3a4:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
	while((*ptr_stringPointer_u8)!=0)
 3a8:	89 91       	ld	r24, Y+
 3aa:	88 23       	and	r24, r24
 3ac:	d9 f7       	brne	.-10     	; 0x3a4 <LCD_DisplayString+0xe>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
 3ae:	df 91       	pop	r29
 3b0:	cf 91       	pop	r28
 3b2:	08 95       	ret

000003b4 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
 3b4:	8f 92       	push	r8
 3b6:	9f 92       	push	r9
 3b8:	af 92       	push	r10
 3ba:	bf 92       	push	r11
 3bc:	ef 92       	push	r14
 3be:	ff 92       	push	r15
 3c0:	0f 93       	push	r16
 3c2:	1f 93       	push	r17
 3c4:	cf 93       	push	r28
 3c6:	df 93       	push	r29
 3c8:	cd b7       	in	r28, 0x3d	; 61
 3ca:	de b7       	in	r29, 0x3e	; 62
 3cc:	2a 97       	sbiw	r28, 0x0a	; 10
 3ce:	0f b6       	in	r0, 0x3f	; 63
 3d0:	f8 94       	cli
 3d2:	de bf       	out	0x3e, r29	; 62
 3d4:	0f be       	out	0x3f, r0	; 63
 3d6:	cd bf       	out	0x3d, r28	; 61
 3d8:	dc 01       	movw	r26, r24
 3da:	cb 01       	movw	r24, r22
 3dc:	04 2f       	mov	r16, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 3de:	00 97       	sbiw	r24, 0x00	; 0
 3e0:	a1 05       	cpc	r26, r1
 3e2:	b1 05       	cpc	r27, r1
 3e4:	19 f0       	breq	.+6      	; 0x3ec <LCD_DisplayDecimalNumber+0x38>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 3e6:	44 23       	and	r20, r20
 3e8:	71 f4       	brne	.+28     	; 0x406 <LCD_DisplayDecimalNumber+0x52>
 3ea:	43 c0       	rjmp	.+134    	; 0x472 <LCD_DisplayDecimalNumber+0xbe>
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 3ec:	44 23       	and	r20, r20
 3ee:	09 f4       	brne	.+2      	; 0x3f2 <LCD_DisplayDecimalNumber+0x3e>
 3f0:	40 c0       	rjmp	.+128    	; 0x472 <LCD_DisplayDecimalNumber+0xbe>
 3f2:	fe 01       	movw	r30, r28
 3f4:	31 96       	adiw	r30, 0x01	; 1
 3f6:	10 e0       	ldi	r17, 0x00	; 0
	    	a[i] = 0x00;
 3f8:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 3fa:	1f 5f       	subi	r17, 0xFF	; 255
 3fc:	10 17       	cp	r17, r16
 3fe:	81 f1       	breq	.+96     	; 0x460 <LCD_DisplayDecimalNumber+0xac>
 400:	1a 30       	cpi	r17, 0x0A	; 10
 402:	d1 f7       	brne	.-12     	; 0x3f8 <LCD_DisplayDecimalNumber+0x44>
 404:	2d c0       	rjmp	.+90     	; 0x460 <LCD_DisplayDecimalNumber+0xac>
 406:	7e 01       	movw	r14, r28
 408:	08 94       	sec
 40a:	e1 1c       	adc	r14, r1
 40c:	f1 1c       	adc	r15, r1
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 40e:	10 e0       	ldi	r17, 0x00	; 0
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 410:	0f 2e       	mov	r0, r31
 412:	fa e0       	ldi	r31, 0x0A	; 10
 414:	8f 2e       	mov	r8, r31
 416:	f0 e0       	ldi	r31, 0x00	; 0
 418:	9f 2e       	mov	r9, r31
 41a:	f0 e0       	ldi	r31, 0x00	; 0
 41c:	af 2e       	mov	r10, r31
 41e:	f0 e0       	ldi	r31, 0x00	; 0
 420:	bf 2e       	mov	r11, r31
 422:	f0 2d       	mov	r31, r0
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
 424:	00 97       	sbiw	r24, 0x00	; 0
 426:	a1 05       	cpc	r26, r1
 428:	b1 05       	cpc	r27, r1
 42a:	69 f0       	breq	.+26     	; 0x446 <LCD_DisplayDecimalNumber+0x92>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 42c:	bc 01       	movw	r22, r24
 42e:	cd 01       	movw	r24, r26
 430:	a5 01       	movw	r20, r10
 432:	94 01       	movw	r18, r8
 434:	0e 94 67 03 	call	0x6ce	; 0x6ce <__udivmodsi4>
 438:	f7 01       	movw	r30, r14
 43a:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
 43c:	82 2f       	mov	r24, r18
 43e:	93 2f       	mov	r25, r19
 440:	a4 2f       	mov	r26, r20
 442:	b5 2f       	mov	r27, r21
 444:	04 c0       	rjmp	.+8      	; 0x44e <LCD_DisplayDecimalNumber+0x9a>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 446:	0b 30       	cpi	r16, 0x0B	; 11
 448:	48 f4       	brcc	.+18     	; 0x45c <LCD_DisplayDecimalNumber+0xa8>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 44a:	f7 01       	movw	r30, r14
 44c:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 44e:	1f 5f       	subi	r17, 0xFF	; 255
 450:	08 94       	sec
 452:	e1 1c       	adc	r14, r1
 454:	f1 1c       	adc	r15, r1
 456:	10 17       	cp	r17, r16
 458:	29 f7       	brne	.-54     	; 0x424 <LCD_DisplayDecimalNumber+0x70>
 45a:	02 c0       	rjmp	.+4      	; 0x460 <LCD_DisplayDecimalNumber+0xac>
			}
		}
	}


	while(i)
 45c:	11 23       	and	r17, r17
 45e:	49 f0       	breq	.+18     	; 0x472 <LCD_DisplayDecimalNumber+0xbe>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
 460:	fe 01       	movw	r30, r28
 462:	e1 0f       	add	r30, r17
 464:	f1 1d       	adc	r31, r1
 466:	80 81       	ld	r24, Z
 468:	80 5d       	subi	r24, 0xD0	; 208
 46a:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>
		i--;
 46e:	11 50       	subi	r17, 0x01	; 1
			}
		}
	}


	while(i)
 470:	b9 f7       	brne	.-18     	; 0x460 <LCD_DisplayDecimalNumber+0xac>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
 472:	2a 96       	adiw	r28, 0x0a	; 10
 474:	0f b6       	in	r0, 0x3f	; 63
 476:	f8 94       	cli
 478:	de bf       	out	0x3e, r29	; 62
 47a:	0f be       	out	0x3f, r0	; 63
 47c:	cd bf       	out	0x3d, r28	; 61
 47e:	df 91       	pop	r29
 480:	cf 91       	pop	r28
 482:	1f 91       	pop	r17
 484:	0f 91       	pop	r16
 486:	ff 90       	pop	r15
 488:	ef 90       	pop	r14
 48a:	bf 90       	pop	r11
 48c:	af 90       	pop	r10
 48e:	9f 90       	pop	r9
 490:	8f 90       	pop	r8
 492:	08 95       	ret

00000494 <LCD_Printf>:
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 494:	6f 92       	push	r6
 496:	7f 92       	push	r7
 498:	8f 92       	push	r8
 49a:	9f 92       	push	r9
 49c:	af 92       	push	r10
 49e:	bf 92       	push	r11
 4a0:	cf 92       	push	r12
 4a2:	df 92       	push	r13
 4a4:	ef 92       	push	r14
 4a6:	ff 92       	push	r15
 4a8:	0f 93       	push	r16
 4aa:	1f 93       	push	r17
 4ac:	cf 93       	push	r28
 4ae:	df 93       	push	r29
 4b0:	cd b7       	in	r28, 0x3d	; 61
 4b2:	de b7       	in	r29, 0x3e	; 62
 4b4:	0f 2e       	mov	r0, r31
 4b6:	f1 e1       	ldi	r31, 0x11	; 17
 4b8:	ef 2e       	mov	r14, r31
 4ba:	ff 24       	eor	r15, r15
 4bc:	f0 2d       	mov	r31, r0
 4be:	ec 0e       	add	r14, r28
 4c0:	fd 1e       	adc	r15, r29
 4c2:	d7 01       	movw	r26, r14
 4c4:	ed 91       	ld	r30, X+
 4c6:	fd 91       	ld	r31, X+
 4c8:	7d 01       	movw	r14, r26
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 4ca:	80 81       	ld	r24, Z
 4cc:	88 23       	and	r24, r24
 4ce:	09 f4       	brne	.+2      	; 0x4d2 <LCD_Printf+0x3e>
 4d0:	ef c0       	rjmp	.+478    	; 0x6b0 <LCD_Printf+0x21c>
 4d2:	6f 01       	movw	r12, r30
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 4d4:	99 24       	eor	r9, r9
 4d6:	9a 94       	dec	r9
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 4d8:	88 24       	eor	r8, r8
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 4da:	85 32       	cpi	r24, 0x25	; 37
 4dc:	09 f0       	breq	.+2      	; 0x4e0 <LCD_Printf+0x4c>
 4de:	dc c0       	rjmp	.+440    	; 0x698 <LCD_Printf+0x204>
		{
		    ptr++;
 4e0:	56 01       	movw	r10, r12
 4e2:	08 94       	sec
 4e4:	a1 1c       	adc	r10, r1
 4e6:	b1 1c       	adc	r11, r1
		    ch = *ptr;
 4e8:	f6 01       	movw	r30, r12
 4ea:	81 81       	ldd	r24, Z+1	; 0x01
		   if((ch>=0x30) && (ch<=0x39))
 4ec:	98 2f       	mov	r25, r24
 4ee:	90 53       	subi	r25, 0x30	; 48
 4f0:	9a 30       	cpi	r25, 0x0A	; 10
 4f2:	80 f4       	brcc	.+32     	; 0x514 <LCD_Printf+0x80>
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 4f4:	32 96       	adiw	r30, 0x02	; 2
 4f6:	08 2d       	mov	r16, r8
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 4f8:	00 0f       	add	r16, r16
 4fa:	90 2f       	mov	r25, r16
 4fc:	99 0f       	add	r25, r25
 4fe:	99 0f       	add	r25, r25
 500:	09 0f       	add	r16, r25
 502:	80 53       	subi	r24, 0x30	; 48
 504:	08 0f       	add	r16, r24
				   ptr++;
 506:	5f 01       	movw	r10, r30
				   ch = *ptr;
 508:	81 91       	ld	r24, Z+
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 50a:	98 2f       	mov	r25, r24
 50c:	90 53       	subi	r25, 0x30	; 48
 50e:	9a 30       	cpi	r25, 0x0A	; 10
 510:	98 f3       	brcs	.-26     	; 0x4f8 <LCD_Printf+0x64>
 512:	01 c0       	rjmp	.+2      	; 0x516 <LCD_Printf+0x82>
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 514:	09 2d       	mov	r16, r9
			}				


			switch(ch)       /* Decode the type of the argument */
 516:	88 35       	cpi	r24, 0x58	; 88
 518:	09 f4       	brne	.+2      	; 0x51c <LCD_Printf+0x88>
 51a:	9c c0       	rjmp	.+312    	; 0x654 <LCD_Printf+0x1c0>
 51c:	89 35       	cpi	r24, 0x59	; 89
 51e:	c0 f4       	brcc	.+48     	; 0x550 <LCD_Printf+0xbc>
 520:	84 34       	cpi	r24, 0x44	; 68
 522:	09 f4       	brne	.+2      	; 0x526 <LCD_Printf+0x92>
 524:	51 c0       	rjmp	.+162    	; 0x5c8 <LCD_Printf+0x134>
 526:	85 34       	cpi	r24, 0x45	; 69
 528:	48 f4       	brcc	.+18     	; 0x53c <LCD_Printf+0xa8>
 52a:	82 34       	cpi	r24, 0x42	; 66
 52c:	09 f4       	brne	.+2      	; 0x530 <LCD_Printf+0x9c>
 52e:	9c c0       	rjmp	.+312    	; 0x668 <LCD_Printf+0x1d4>
 530:	83 34       	cpi	r24, 0x43	; 67
 532:	28 f5       	brcc	.+74     	; 0x57e <LCD_Printf+0xea>
 534:	85 32       	cpi	r24, 0x25	; 37
 536:	09 f0       	breq	.+2      	; 0x53a <LCD_Printf+0xa6>
 538:	b2 c0       	rjmp	.+356    	; 0x69e <LCD_Printf+0x20a>
 53a:	aa c0       	rjmp	.+340    	; 0x690 <LCD_Printf+0x1fc>
 53c:	83 35       	cpi	r24, 0x53	; 83
 53e:	09 f4       	brne	.+2      	; 0x542 <LCD_Printf+0xae>
 540:	9d c0       	rjmp	.+314    	; 0x67c <LCD_Printf+0x1e8>
 542:	85 35       	cpi	r24, 0x55	; 85
 544:	09 f4       	brne	.+2      	; 0x548 <LCD_Printf+0xb4>
 546:	71 c0       	rjmp	.+226    	; 0x62a <LCD_Printf+0x196>
 548:	86 34       	cpi	r24, 0x46	; 70
 54a:	09 f0       	breq	.+2      	; 0x54e <LCD_Printf+0xba>
 54c:	a8 c0       	rjmp	.+336    	; 0x69e <LCD_Printf+0x20a>
 54e:	91 c0       	rjmp	.+290    	; 0x672 <LCD_Printf+0x1de>
 550:	86 36       	cpi	r24, 0x66	; 102
 552:	09 f4       	brne	.+2      	; 0x556 <LCD_Printf+0xc2>
 554:	8e c0       	rjmp	.+284    	; 0x672 <LCD_Printf+0x1de>
 556:	87 36       	cpi	r24, 0x67	; 103
 558:	40 f4       	brcc	.+16     	; 0x56a <LCD_Printf+0xd6>
 55a:	83 36       	cpi	r24, 0x63	; 99
 55c:	81 f0       	breq	.+32     	; 0x57e <LCD_Printf+0xea>
 55e:	84 36       	cpi	r24, 0x64	; 100
 560:	b9 f0       	breq	.+46     	; 0x590 <LCD_Printf+0xfc>
 562:	82 36       	cpi	r24, 0x62	; 98
 564:	09 f0       	breq	.+2      	; 0x568 <LCD_Printf+0xd4>
 566:	9b c0       	rjmp	.+310    	; 0x69e <LCD_Printf+0x20a>
 568:	7a c0       	rjmp	.+244    	; 0x65e <LCD_Printf+0x1ca>
 56a:	85 37       	cpi	r24, 0x75	; 117
 56c:	09 f4       	brne	.+2      	; 0x570 <LCD_Printf+0xdc>
 56e:	4c c0       	rjmp	.+152    	; 0x608 <LCD_Printf+0x174>
 570:	88 37       	cpi	r24, 0x78	; 120
 572:	09 f4       	brne	.+2      	; 0x576 <LCD_Printf+0xe2>
 574:	6a c0       	rjmp	.+212    	; 0x64a <LCD_Printf+0x1b6>
 576:	83 37       	cpi	r24, 0x73	; 115
 578:	09 f0       	breq	.+2      	; 0x57c <LCD_Printf+0xe8>
 57a:	91 c0       	rjmp	.+290    	; 0x69e <LCD_Printf+0x20a>
 57c:	7f c0       	rjmp	.+254    	; 0x67c <LCD_Printf+0x1e8>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 57e:	87 01       	movw	r16, r14
 580:	0e 5f       	subi	r16, 0xFE	; 254
 582:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 584:	d7 01       	movw	r26, r14
 586:	8c 91       	ld	r24, X
 588:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>

			switch(ch)       /* Decode the type of the argument */
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 58c:	78 01       	movw	r14, r16
				LCD_DisplayChar(ch);
				break;
 58e:	87 c0       	rjmp	.+270    	; 0x69e <LCD_Printf+0x20a>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 590:	66 24       	eor	r6, r6
 592:	77 24       	eor	r7, r7
 594:	68 94       	set
 596:	61 f8       	bld	r6, 1
 598:	6e 0c       	add	r6, r14
 59a:	7f 1c       	adc	r7, r15
 59c:	f7 01       	movw	r30, r14
 59e:	c0 80       	ld	r12, Z
 5a0:	d1 80       	ldd	r13, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
 5a2:	dd 20       	and	r13, r13
 5a4:	3c f4       	brge	.+14     	; 0x5b4 <LCD_Printf+0x120>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
 5a6:	d0 94       	com	r13
 5a8:	c1 94       	neg	r12
 5aa:	d1 08       	sbc	r13, r1
 5ac:	d3 94       	inc	r13
				   LCD_DisplayChar('-');
 5ae:	8d e2       	ldi	r24, 0x2D	; 45
 5b0:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
 5b4:	b6 01       	movw	r22, r12
 5b6:	88 27       	eor	r24, r24
 5b8:	77 fd       	sbrc	r23, 7
 5ba:	80 95       	com	r24
 5bc:	98 2f       	mov	r25, r24
 5be:	40 2f       	mov	r20, r16
 5c0:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCD_DisplayDecimalNumber>
				ch = va_arg(argp, uint16_t);
				LCD_DisplayChar(ch);
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 5c4:	73 01       	movw	r14, r6
				   var_num_s16 = -var_num_s16;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
 5c6:	6b c0       	rjmp	.+214    	; 0x69e <LCD_Printf+0x20a>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 5c8:	66 24       	eor	r6, r6
 5ca:	77 24       	eor	r7, r7
 5cc:	68 94       	set
 5ce:	62 f8       	bld	r6, 2
 5d0:	6e 0c       	add	r6, r14
 5d2:	7f 1c       	adc	r7, r15
 5d4:	d7 01       	movw	r26, r14
 5d6:	cd 90       	ld	r12, X+
 5d8:	dd 90       	ld	r13, X+
 5da:	ed 90       	ld	r14, X+
 5dc:	fc 90       	ld	r15, X
 5de:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
 5e0:	ff 20       	and	r15, r15
 5e2:	5c f4       	brge	.+22     	; 0x5fa <LCD_Printf+0x166>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
 5e4:	f0 94       	com	r15
 5e6:	e0 94       	com	r14
 5e8:	d0 94       	com	r13
 5ea:	c0 94       	com	r12
 5ec:	c1 1c       	adc	r12, r1
 5ee:	d1 1c       	adc	r13, r1
 5f0:	e1 1c       	adc	r14, r1
 5f2:	f1 1c       	adc	r15, r1
				   LCD_DisplayChar('-');
 5f4:	8d e2       	ldi	r24, 0x2D	; 45
 5f6:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
 5fa:	c7 01       	movw	r24, r14
 5fc:	b6 01       	movw	r22, r12
 5fe:	40 2f       	mov	r20, r16
 600:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 604:	73 01       	movw	r14, r6
				   var_num_s32 = -var_num_s32;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	
 606:	4b c0       	rjmp	.+150    	; 0x69e <LCD_Printf+0x20a>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 608:	cc 24       	eor	r12, r12
 60a:	dd 24       	eor	r13, r13
 60c:	68 94       	set
 60e:	c1 f8       	bld	r12, 1
 610:	ce 0c       	add	r12, r14
 612:	df 1c       	adc	r13, r15
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 614:	f7 01       	movw	r30, r14
 616:	80 81       	ld	r24, Z
 618:	91 81       	ldd	r25, Z+1	; 0x01
 61a:	bc 01       	movw	r22, r24
 61c:	80 e0       	ldi	r24, 0x00	; 0
 61e:	90 e0       	ldi	r25, 0x00	; 0
 620:	40 2f       	mov	r20, r16
 622:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 626:	76 01       	movw	r14, r12
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 628:	3a c0       	rjmp	.+116    	; 0x69e <LCD_Printf+0x20a>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 62a:	cc 24       	eor	r12, r12
 62c:	dd 24       	eor	r13, r13
 62e:	68 94       	set
 630:	c2 f8       	bld	r12, 2
 632:	ce 0c       	add	r12, r14
 634:	df 1c       	adc	r13, r15
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 636:	d7 01       	movw	r26, r14
 638:	6d 91       	ld	r22, X+
 63a:	7d 91       	ld	r23, X+
 63c:	8d 91       	ld	r24, X+
 63e:	9c 91       	ld	r25, X
 640:	40 2f       	mov	r20, r16
 642:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 646:	76 01       	movw	r14, r12
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			
 648:	2a c0       	rjmp	.+84     	; 0x69e <LCD_Printf+0x20a>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
 64a:	e2 e0       	ldi	r30, 0x02	; 2
 64c:	f0 e0       	ldi	r31, 0x00	; 0
 64e:	ee 0e       	add	r14, r30
 650:	ff 1e       	adc	r15, r31
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 652:	25 c0       	rjmp	.+74     	; 0x69e <LCD_Printf+0x20a>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
 654:	84 e0       	ldi	r24, 0x04	; 4
 656:	90 e0       	ldi	r25, 0x00	; 0
 658:	e8 0e       	add	r14, r24
 65a:	f9 1e       	adc	r15, r25
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;
 65c:	20 c0       	rjmp	.+64     	; 0x69e <LCD_Printf+0x20a>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 65e:	a2 e0       	ldi	r26, 0x02	; 2
 660:	b0 e0       	ldi	r27, 0x00	; 0
 662:	ea 0e       	add	r14, r26
 664:	fb 1e       	adc	r15, r27
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 666:	1b c0       	rjmp	.+54     	; 0x69e <LCD_Printf+0x20a>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 668:	e4 e0       	ldi	r30, 0x04	; 4
 66a:	f0 e0       	ldi	r31, 0x00	; 0
 66c:	ee 0e       	add	r14, r30
 66e:	ff 1e       	adc	r15, r31
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;				
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
#endif				
				break;
 670:	16 c0       	rjmp	.+44     	; 0x69e <LCD_Printf+0x20a>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 672:	84 e0       	ldi	r24, 0x04	; 4
 674:	90 e0       	ldi	r25, 0x00	; 0
 676:	e8 0e       	add	r14, r24
 678:	f9 1e       	adc	r15, r25
#if (Enable_LCD_DisplayFloatNumber == 1)				
				LCD_DisplayFloatNumber(var_floatNum_f32);
#endif
				break;
 67a:	11 c0       	rjmp	.+34     	; 0x69e <LCD_Printf+0x20a>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 67c:	f7 01       	movw	r30, r14
 67e:	a2 e0       	ldi	r26, 0x02	; 2
 680:	b0 e0       	ldi	r27, 0x00	; 0
 682:	ea 0e       	add	r14, r26
 684:	fb 1e       	adc	r15, r27
#if (Enable_LCD_DisplayString == 1)
				LCD_DisplayString(str);
 686:	80 81       	ld	r24, Z
 688:	91 81       	ldd	r25, Z+1	; 0x01
 68a:	0e 94 cb 01 	call	0x396	; 0x396 <LCD_DisplayString>
#endif				
				break;
 68e:	07 c0       	rjmp	.+14     	; 0x69e <LCD_Printf+0x20a>

			case '%':
				LCD_DisplayChar('%');
 690:	85 e2       	ldi	r24, 0x25	; 37
 692:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>
				break;
 696:	03 c0       	rjmp	.+6      	; 0x69e <LCD_Printf+0x20a>
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 698:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_DisplayChar>
 69c:	56 01       	movw	r10, r12
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 69e:	65 01       	movw	r12, r10
 6a0:	08 94       	sec
 6a2:	c1 1c       	adc	r12, r1
 6a4:	d1 1c       	adc	r13, r1
 6a6:	f5 01       	movw	r30, r10
 6a8:	81 81       	ldd	r24, Z+1	; 0x01
 6aa:	88 23       	and	r24, r24
 6ac:	09 f0       	breq	.+2      	; 0x6b0 <LCD_Printf+0x21c>
 6ae:	15 cf       	rjmp	.-470    	; 0x4da <LCD_Printf+0x46>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 6b0:	df 91       	pop	r29
 6b2:	cf 91       	pop	r28
 6b4:	1f 91       	pop	r17
 6b6:	0f 91       	pop	r16
 6b8:	ff 90       	pop	r15
 6ba:	ef 90       	pop	r14
 6bc:	df 90       	pop	r13
 6be:	cf 90       	pop	r12
 6c0:	bf 90       	pop	r11
 6c2:	af 90       	pop	r10
 6c4:	9f 90       	pop	r9
 6c6:	8f 90       	pop	r8
 6c8:	7f 90       	pop	r7
 6ca:	6f 90       	pop	r6
 6cc:	08 95       	ret

000006ce <__udivmodsi4>:
 6ce:	a1 e2       	ldi	r26, 0x21	; 33
 6d0:	1a 2e       	mov	r1, r26
 6d2:	aa 1b       	sub	r26, r26
 6d4:	bb 1b       	sub	r27, r27
 6d6:	fd 01       	movw	r30, r26
 6d8:	0d c0       	rjmp	.+26     	; 0x6f4 <__udivmodsi4_ep>

000006da <__udivmodsi4_loop>:
 6da:	aa 1f       	adc	r26, r26
 6dc:	bb 1f       	adc	r27, r27
 6de:	ee 1f       	adc	r30, r30
 6e0:	ff 1f       	adc	r31, r31
 6e2:	a2 17       	cp	r26, r18
 6e4:	b3 07       	cpc	r27, r19
 6e6:	e4 07       	cpc	r30, r20
 6e8:	f5 07       	cpc	r31, r21
 6ea:	20 f0       	brcs	.+8      	; 0x6f4 <__udivmodsi4_ep>
 6ec:	a2 1b       	sub	r26, r18
 6ee:	b3 0b       	sbc	r27, r19
 6f0:	e4 0b       	sbc	r30, r20
 6f2:	f5 0b       	sbc	r31, r21

000006f4 <__udivmodsi4_ep>:
 6f4:	66 1f       	adc	r22, r22
 6f6:	77 1f       	adc	r23, r23
 6f8:	88 1f       	adc	r24, r24
 6fa:	99 1f       	adc	r25, r25
 6fc:	1a 94       	dec	r1
 6fe:	69 f7       	brne	.-38     	; 0x6da <__udivmodsi4_loop>
 700:	60 95       	com	r22
 702:	70 95       	com	r23
 704:	80 95       	com	r24
 706:	90 95       	com	r25
 708:	9b 01       	movw	r18, r22
 70a:	ac 01       	movw	r20, r24
 70c:	bd 01       	movw	r22, r26
 70e:	cf 01       	movw	r24, r30
 710:	08 95       	ret

00000712 <_exit>:
 712:	f8 94       	cli

00000714 <__stop_program>:
 714:	ff cf       	rjmp	.-2      	; 0x714 <__stop_program>
