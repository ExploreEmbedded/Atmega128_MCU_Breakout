
lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00000956  000009ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000956  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  00800126  00800126  00000a10  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000a10  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  000010dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e0  00000000  00000000  00001168  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e94  00000000  00000000  00001248  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000003f0  00000000  00000000  000020dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000008a2  00000000  00000000  000024cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000294  00000000  00000000  00002d70  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000542  00000000  00000000  00003004  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000d1c  00000000  00000000  00003546  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 e5       	ldi	r30, 0x56	; 86
  a0:	f9 e0       	ldi	r31, 0x09	; 9
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a6 32       	cpi	r26, 0x26	; 38
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a6 e2       	ldi	r26, 0x26	; 38
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ab 32       	cpi	r26, 0x2B	; 43
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 68 04 	call	0x8d0	; 0x8d0 <main>
  c6:	0c 94 a9 04 	jmp	0x952	; 0x952 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
  ce:	98 2f       	mov	r25, r24
  d0:	84 ff       	sbrs	r24, 4
  d2:	02 c0       	rjmp	.+4      	; 0xd8 <lcd_SendNibble+0xa>
  d4:	94 9a       	sbi	0x12, 4	; 18
  d6:	01 c0       	rjmp	.+2      	; 0xda <lcd_SendNibble+0xc>
  d8:	94 98       	cbi	0x12, 4	; 18
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
  da:	95 ff       	sbrs	r25, 5
  dc:	02 c0       	rjmp	.+4      	; 0xe2 <lcd_SendNibble+0x14>
  de:	95 9a       	sbi	0x12, 5	; 18
  e0:	01 c0       	rjmp	.+2      	; 0xe4 <lcd_SendNibble+0x16>
  e2:	95 98       	cbi	0x12, 5	; 18
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
  e4:	96 ff       	sbrs	r25, 6
  e6:	02 c0       	rjmp	.+4      	; 0xec <lcd_SendNibble+0x1e>
  e8:	96 9a       	sbi	0x12, 6	; 18
  ea:	01 c0       	rjmp	.+2      	; 0xee <lcd_SendNibble+0x20>
  ec:	96 98       	cbi	0x12, 6	; 18
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
  ee:	88 23       	and	r24, r24
  f0:	14 f4       	brge	.+4      	; 0xf6 <lcd_SendNibble+0x28>
  f2:	97 9a       	sbi	0x12, 7	; 18
  f4:	08 95       	ret
  f6:	97 98       	cbi	0x12, 7	; 18
  f8:	08 95       	ret

000000fa <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
  fa:	8f 98       	cbi	0x11, 7	; 17
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
  fc:	90 98       	cbi	0x12, 0	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
  fe:	91 9a       	sbi	0x12, 1	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 100:	ea e2       	ldi	r30, 0x2A	; 42
 102:	f1 e0       	ldi	r31, 0x01	; 1
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
 104:	92 98       	cbi	0x12, 2	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 106:	85 e3       	ldi	r24, 0x35	; 53
 108:	8a 95       	dec	r24
 10a:	f1 f7       	brne	.-4      	; 0x108 <lcd_BusyCheck+0xe>
 10c:	00 00       	nop
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
 10e:	92 9a       	sbi	0x12, 2	; 18
 110:	95 e3       	ldi	r25, 0x35	; 53
 112:	9a 95       	dec	r25
 114:	f1 f7       	brne	.-4      	; 0x112 <lcd_BusyCheck+0x18>
 116:	00 00       	nop
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
 118:	80 b3       	in	r24, 0x10	; 16


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 11a:	90 81       	ld	r25, Z
 11c:	94 30       	cpi	r25, 0x04	; 4
 11e:	51 f4       	brne	.+20     	; 0x134 <lcd_BusyCheck+0x3a>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
 120:	92 98       	cbi	0x12, 2	; 18
 122:	95 e3       	ldi	r25, 0x35	; 53
 124:	9a 95       	dec	r25
 126:	f1 f7       	brne	.-4      	; 0x124 <lcd_BusyCheck+0x2a>
 128:	00 00       	nop
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
 12a:	92 9a       	sbi	0x12, 2	; 18
 12c:	95 e3       	ldi	r25, 0x35	; 53
 12e:	9a 95       	dec	r25
 130:	f1 f7       	brne	.-4      	; 0x12e <lcd_BusyCheck+0x34>
 132:	00 00       	nop
			DELAY_us(10);
		}	
	}while(busyflag);
 134:	88 23       	and	r24, r24
 136:	34 f3       	brlt	.-52     	; 0x104 <lcd_BusyCheck+0xa>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
 138:	8f 9a       	sbi	0x11, 7	; 17
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
 13a:	08 95       	ret

0000013c <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 13c:	90 98       	cbi	0x12, 0	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 13e:	91 98       	cbi	0x12, 1	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 140:	92 9a       	sbi	0x12, 2	; 18
 142:	85 e3       	ldi	r24, 0x35	; 53
 144:	8a 95       	dec	r24
 146:	f1 f7       	brne	.-4      	; 0x144 <lcd_SendCmdSignals+0x8>
 148:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 14a:	92 98       	cbi	0x12, 2	; 18
}
 14c:	08 95       	ret

0000014e <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 14e:	90 9a       	sbi	0x12, 0	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 150:	91 98       	cbi	0x12, 1	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 152:	92 9a       	sbi	0x12, 2	; 18
 154:	85 e3       	ldi	r24, 0x35	; 53
 156:	8a 95       	dec	r24
 158:	f1 f7       	brne	.-4      	; 0x156 <lcd_SendDataSignals+0x8>
 15a:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 15c:	92 98       	cbi	0x12, 2	; 18
}
 15e:	08 95       	ret

00000160 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 160:	cf 93       	push	r28
 162:	c8 2f       	mov	r28, r24
	lcd_BusyCheck();
 164:	0e 94 7d 00 	call	0xfa	; 0xfa <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 168:	80 91 2a 01 	lds	r24, 0x012A
 16c:	88 30       	cpi	r24, 0x08	; 8
 16e:	21 f4       	brne	.+8      	; 0x178 <LCD_CmdWrite+0x18>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 170:	c2 bb       	out	0x12, r28	; 18
		lcd_SendCmdSignals();  // Signals for command write operation
 172:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_SendCmdSignals>
 176:	0e c0       	rjmp	.+28     	; 0x194 <LCD_CmdWrite+0x34>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 178:	84 30       	cpi	r24, 0x04	; 4
 17a:	61 f4       	brne	.+24     	; 0x194 <LCD_CmdWrite+0x34>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 17c:	8c 2f       	mov	r24, r28
 17e:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 182:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 186:	8c 2f       	mov	r24, r28
 188:	82 95       	swap	r24
 18a:	80 7f       	andi	r24, 0xF0	; 240
 18c:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
		lcd_SendCmdSignals();
 190:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_SendCmdSignals>
	}
}
 194:	cf 91       	pop	r28
 196:	08 95       	ret

00000198 <LCD_SetCursor>:
 ***************************************************************************************************/
#if ( Enable_LCD_SetCursor    == 1 )
void LCD_SetCursor(uint8_t var_lineNumber_u8, uint8_t var_charNumber_u8)
{

	if((var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8) &&
 198:	90 91 28 01 	lds	r25, 0x0128
 19c:	98 17       	cp	r25, r24
 19e:	80 f0       	brcs	.+32     	; 0x1c0 <LCD_SetCursor+0x28>
 1a0:	90 91 29 01 	lds	r25, 0x0129
 1a4:	69 17       	cp	r22, r25
 1a6:	60 f4       	brcc	.+24     	; 0x1c0 <LCD_SetCursor+0x28>
			(var_charNumber_u8< STK_LCDConfig.mvar_MaxSupportedChars_U8))
	{
		/*If the line number and char are in range then
		   move the Cursor to specified Position*/
		VAR_LcdTrackCursorPos_U8 = var_charNumber_u8;
 1a8:	60 93 26 01 	sts	0x0126, r22
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 1ac:	80 93 27 01 	sts	0x0127, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]+var_charNumber_u8);
 1b0:	e0 e0       	ldi	r30, 0x00	; 0
 1b2:	f1 e0       	ldi	r31, 0x01	; 1
 1b4:	e8 0f       	add	r30, r24
 1b6:	f1 1d       	adc	r31, r1
 1b8:	80 81       	ld	r24, Z
 1ba:	86 0f       	add	r24, r22
 1bc:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
 1c0:	08 95       	ret

000001c2 <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 1c2:	80 91 27 01 	lds	r24, 0x0127
 1c6:	8f 5f       	subi	r24, 0xFF	; 255
 1c8:	80 93 27 01 	sts	0x0127, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 1cc:	10 92 26 01 	sts	0x0126, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1d0:	90 91 28 01 	lds	r25, 0x0128
 1d4:	98 17       	cp	r25, r24
 1d6:	18 f4       	brcc	.+6      	; 0x1de <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 1d8:	81 e0       	ldi	r24, 0x01	; 1
 1da:	80 93 27 01 	sts	0x0127, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 1de:	80 91 27 01 	lds	r24, 0x0127
 1e2:	e0 e0       	ldi	r30, 0x00	; 0
 1e4:	f1 e0       	ldi	r31, 0x01	; 1
 1e6:	e8 0f       	add	r30, r24
 1e8:	f1 1d       	adc	r31, r1
 1ea:	80 81       	ld	r24, Z
 1ec:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
}
 1f0:	08 95       	ret

000001f2 <LCD_GoToLine>:
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1f2:	90 91 28 01 	lds	r25, 0x0128
 1f6:	98 17       	cp	r25, r24
 1f8:	58 f0       	brcs	.+22     	; 0x210 <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 1fa:	10 92 26 01 	sts	0x0126, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 1fe:	80 93 27 01 	sts	0x0127, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 202:	e0 e0       	ldi	r30, 0x00	; 0
 204:	f1 e0       	ldi	r31, 0x01	; 1
 206:	e8 0f       	add	r30, r24
 208:	f1 1d       	adc	r31, r1
 20a:	80 81       	ld	r24, Z
 20c:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
 210:	08 95       	ret

00000212 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 212:	81 e0       	ldi	r24, 0x01	; 1
 214:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <LCD_GoToLine>
}
 21e:	08 95       	ret

00000220 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 220:	9f ef       	ldi	r25, 0xFF	; 255
 222:	91 bb       	out	0x11, r25	; 17
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 224:	91 bb       	out	0x11, r25	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 226:	80 93 2a 01 	sts	0x012A, r24
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 22a:	40 93 29 01 	sts	0x0129, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 22e:	60 93 28 01 	sts	0x0128, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 232:	63 30       	cpi	r22, 0x03	; 3
 234:	40 f0       	brcs	.+16     	; 0x246 <LCD_Init+0x26>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 236:	4f 70       	andi	r20, 0x0F	; 15
 238:	84 2f       	mov	r24, r20
 23a:	80 57       	subi	r24, 0x70	; 112
 23c:	80 93 03 01 	sts	0x0103, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 240:	40 53       	subi	r20, 0x30	; 48
 242:	40 93 04 01 	sts	0x0104, r20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 246:	8f ef       	ldi	r24, 0xFF	; 255
 248:	91 ee       	ldi	r25, 0xE1	; 225
 24a:	a4 e0       	ldi	r26, 0x04	; 4
 24c:	81 50       	subi	r24, 0x01	; 1
 24e:	90 40       	sbci	r25, 0x00	; 0
 250:	a0 40       	sbci	r26, 0x00	; 0
 252:	e1 f7       	brne	.-8      	; 0x24c <LCD_Init+0x2c>
 254:	00 c0       	rjmp	.+0      	; 0x256 <LCD_Init+0x36>
 256:	00 00       	nop
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 258:	80 91 2a 01 	lds	r24, 0x012A
 25c:	88 30       	cpi	r24, 0x08	; 8
 25e:	21 f4       	brne	.+8      	; 0x268 <LCD_Init+0x48>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 260:	88 e3       	ldi	r24, 0x38	; 56
 262:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
 266:	34 c0       	rjmp	.+104    	; 0x2d0 <LCD_Init+0xb0>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 268:	84 30       	cpi	r24, 0x04	; 4
 26a:	91 f5       	brne	.+100    	; 0x2d0 <LCD_Init+0xb0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 26c:	80 e3       	ldi	r24, 0x30	; 48
 26e:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
	lcd_SendCmdSignals();
 272:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_SendCmdSignals>
 276:	8f ef       	ldi	r24, 0xFF	; 255
 278:	91 ee       	ldi	r25, 0xE1	; 225
 27a:	a4 e0       	ldi	r26, 0x04	; 4
 27c:	81 50       	subi	r24, 0x01	; 1
 27e:	90 40       	sbci	r25, 0x00	; 0
 280:	a0 40       	sbci	r26, 0x00	; 0
 282:	e1 f7       	brne	.-8      	; 0x27c <LCD_Init+0x5c>
 284:	00 c0       	rjmp	.+0      	; 0x286 <LCD_Init+0x66>
 286:	00 00       	nop
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 288:	80 e3       	ldi	r24, 0x30	; 48
 28a:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
	lcd_SendCmdSignals();
 28e:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_SendCmdSignals>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 292:	af e1       	ldi	r26, 0x1F	; 31
 294:	b3 e0       	ldi	r27, 0x03	; 3
 296:	11 97       	sbiw	r26, 0x01	; 1
 298:	f1 f7       	brne	.-4      	; 0x296 <LCD_Init+0x76>
 29a:	00 c0       	rjmp	.+0      	; 0x29c <LCD_Init+0x7c>
 29c:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x30);
 29e:	80 e3       	ldi	r24, 0x30	; 48
 2a0:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
	lcd_SendCmdSignals();
 2a4:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_SendCmdSignals>
 2a8:	8f e1       	ldi	r24, 0x1F	; 31
 2aa:	93 e0       	ldi	r25, 0x03	; 3
 2ac:	01 97       	sbiw	r24, 0x01	; 1
 2ae:	f1 f7       	brne	.-4      	; 0x2ac <LCD_Init+0x8c>
 2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <LCD_Init+0x92>
 2b2:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x20);
 2b4:	80 e2       	ldi	r24, 0x20	; 32
 2b6:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
	lcd_SendCmdSignals();
 2ba:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_SendCmdSignals>
 2be:	af e1       	ldi	r26, 0x1F	; 31
 2c0:	b3 e0       	ldi	r27, 0x03	; 3
 2c2:	11 97       	sbiw	r26, 0x01	; 1
 2c4:	f1 f7       	brne	.-4      	; 0x2c2 <LCD_Init+0xa2>
 2c6:	00 c0       	rjmp	.+0      	; 0x2c8 <LCD_Init+0xa8>
 2c8:	00 00       	nop
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 2ca:	88 e2       	ldi	r24, 0x28	; 40
 2cc:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 2d0:	8e e0       	ldi	r24, 0x0E	; 14
 2d2:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 2d6:	0e 94 09 01 	call	0x212	; 0x212 <LCD_Clear>
}
 2da:	08 95       	ret

000002dc <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 2dc:	cf 93       	push	r28
 2de:	c8 2f       	mov	r28, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 2e0:	90 91 29 01 	lds	r25, 0x0129
 2e4:	80 91 26 01 	lds	r24, 0x0126
 2e8:	89 17       	cp	r24, r25
 2ea:	18 f4       	brcc	.+6      	; 0x2f2 <LCD_DisplayChar+0x16>
 2ec:	ca 30       	cpi	r28, 0x0A	; 10
 2ee:	29 f4       	brne	.+10     	; 0x2fa <LCD_DisplayChar+0x1e>
 2f0:	22 c0       	rjmp	.+68     	; 0x336 <LCD_DisplayChar+0x5a>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 2f2:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 2f6:	ca 30       	cpi	r28, 0x0A	; 10
 2f8:	01 f1       	breq	.+64     	; 0x33a <LCD_DisplayChar+0x5e>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 2fa:	0e 94 7d 00 	call	0xfa	; 0xfa <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 2fe:	80 91 2a 01 	lds	r24, 0x012A
 302:	88 30       	cpi	r24, 0x08	; 8
 304:	21 f4       	brne	.+8      	; 0x30e <LCD_DisplayChar+0x32>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 306:	c2 bb       	out	0x12, r28	; 18
		lcd_SendDataSignals();  // Signals for data write operation
 308:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_SendDataSignals>
 30c:	0e c0       	rjmp	.+28     	; 0x32a <LCD_DisplayChar+0x4e>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 30e:	84 30       	cpi	r24, 0x04	; 4
 310:	61 f4       	brne	.+24     	; 0x32a <LCD_DisplayChar+0x4e>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 312:	8c 2f       	mov	r24, r28
 314:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 318:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 31c:	8c 2f       	mov	r24, r28
 31e:	82 95       	swap	r24
 320:	80 7f       	andi	r24, 0xF0	; 240
 322:	0e 94 67 00 	call	0xce	; 0xce <lcd_SendNibble>
		lcd_SendDataSignals();
 326:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 32a:	80 91 26 01 	lds	r24, 0x0126
 32e:	8f 5f       	subi	r24, 0xFF	; 255
 330:	80 93 26 01 	sts	0x0126, r24
 334:	02 c0       	rjmp	.+4      	; 0x33a <LCD_DisplayChar+0x5e>
{
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 336:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <LCD_GoToNextLine>
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
	}
}
 33a:	cf 91       	pop	r28
 33c:	08 95       	ret

0000033e <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
 33e:	cf 93       	push	r28
 340:	df 93       	push	r29
 342:	ec 01       	movw	r28, r24
	while((*ptr_stringPointer_u8)!=0)
 344:	88 81       	ld	r24, Y
 346:	88 23       	and	r24, r24
 348:	31 f0       	breq	.+12     	; 0x356 <LCD_DisplayString+0x18>
                 1.The ptr_stringPointer_u8 points to the first char of the string
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
 34a:	21 96       	adiw	r28, 0x01	; 1
{
	while((*ptr_stringPointer_u8)!=0)
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 34c:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
	while((*ptr_stringPointer_u8)!=0)
 350:	89 91       	ld	r24, Y+
 352:	88 23       	and	r24, r24
 354:	d9 f7       	brne	.-10     	; 0x34c <LCD_DisplayString+0xe>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
 356:	df 91       	pop	r29
 358:	cf 91       	pop	r28
 35a:	08 95       	ret

0000035c <LCD_ScrollMessage>:
                 If the specified line number is out of range then the message
				 will be scrolled on first line
 ***************************************************************************************************/
#if ( Enable_LCD_ScrollMessage  == 1 )
void LCD_ScrollMessage(uint8_t var_lineNumber_u8, char *ptr_msgPointer_u8)
{
 35c:	af 92       	push	r10
 35e:	bf 92       	push	r11
 360:	cf 92       	push	r12
 362:	df 92       	push	r13
 364:	ef 92       	push	r14
 366:	ff 92       	push	r15
 368:	0f 93       	push	r16
 36a:	1f 93       	push	r17
 36c:	cf 93       	push	r28
 36e:	df 93       	push	r29
 370:	b8 2e       	mov	r11, r24
 372:	6b 01       	movw	r12, r22
	unsigned char i,j;


	if(var_lineNumber_u8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 374:	80 91 28 01 	lds	r24, 0x0128
 378:	8b 15       	cp	r24, r11
 37a:	10 f4       	brcc	.+4      	; 0x380 <LCD_ScrollMessage+0x24>
		var_lineNumber_u8 = mENUM_LcdLineOne; // Select first line if the var_lineNumber_u8 is out of range
 37c:	bb 24       	eor	r11, r11
 37e:	b3 94       	inc	r11

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);			 //Disable the Cursor
 380:	8c e0       	ldi	r24, 0x0C	; 12
 382:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>

	for(i=0;ptr_msgPointer_u8[i];i++)
 386:	d6 01       	movw	r26, r12
 388:	8c 91       	ld	r24, X
 38a:	88 23       	and	r24, r24
 38c:	d1 f1       	breq	.+116    	; 0x402 <LCD_ScrollMessage+0xa6>
 38e:	d0 e0       	ldi	r29, 0x00	; 0
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 390:	09 e2       	ldi	r16, 0x29	; 41
 392:	11 e0       	ldi	r17, 0x01	; 1
 394:	aa 24       	eor	r10, r10
	{      
		/* Loop to display the complete string,	each time 16 chars are displayed and
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line
 396:	8b 2d       	mov	r24, r11
 398:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <LCD_GoToLine>

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 39c:	f8 01       	movw	r30, r16
 39e:	80 81       	ld	r24, Z
 3a0:	88 23       	and	r24, r24
 3a2:	f9 f0       	breq	.+62     	; 0x3e2 <LCD_ScrollMessage+0x86>
 3a4:	ed 2e       	mov	r14, r29
 3a6:	ff 24       	eor	r15, r15
 3a8:	f6 01       	movw	r30, r12
 3aa:	ee 0d       	add	r30, r14
 3ac:	ff 1d       	adc	r31, r15
 3ae:	80 81       	ld	r24, Z
 3b0:	88 23       	and	r24, r24
 3b2:	a9 f1       	breq	.+106    	; 0x41e <LCD_ScrollMessage+0xc2>
 3b4:	ca 2d       	mov	r28, r10
 3b6:	7f 01       	movw	r14, r30
		{
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
 3b8:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 3bc:	cf 5f       	subi	r28, 0xFF	; 255
 3be:	d8 01       	movw	r26, r16
 3c0:	8c 91       	ld	r24, X
 3c2:	c8 17       	cp	r28, r24
 3c4:	70 f4       	brcc	.+28     	; 0x3e2 <LCD_ScrollMessage+0x86>
 3c6:	f7 01       	movw	r30, r14
 3c8:	ec 0f       	add	r30, r28
 3ca:	f1 1d       	adc	r31, r1
 3cc:	80 81       	ld	r24, Z
 3ce:	88 23       	and	r24, r24
 3d0:	99 f7       	brne	.-26     	; 0x3b8 <LCD_ScrollMessage+0x5c>

		while( j<STK_LCDConfig.mvar_MaxSupportedChars_U8)
		{
			/*If the chars to be scrolled are less than MaxLcdChars,
			  then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
 3d2:	80 e2       	ldi	r24, 0x20	; 32
 3d4:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
			j++;
 3d8:	cf 5f       	subi	r28, 0xFF	; 255
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
		}


		while( j<STK_LCDConfig.mvar_MaxSupportedChars_U8)
 3da:	f8 01       	movw	r30, r16
 3dc:	80 81       	ld	r24, Z
 3de:	c8 17       	cp	r28, r24
 3e0:	c0 f3       	brcs	.-16     	; 0x3d2 <LCD_ScrollMessage+0x76>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3e2:	8f ef       	ldi	r24, 0xFF	; 255
 3e4:	93 ec       	ldi	r25, 0xC3	; 195
 3e6:	a9 e0       	ldi	r26, 0x09	; 9
 3e8:	81 50       	subi	r24, 0x01	; 1
 3ea:	90 40       	sbci	r25, 0x00	; 0
 3ec:	a0 40       	sbci	r26, 0x00	; 0
 3ee:	e1 f7       	brne	.-8      	; 0x3e8 <LCD_ScrollMessage+0x8c>
 3f0:	00 c0       	rjmp	.+0      	; 0x3f2 <LCD_ScrollMessage+0x96>
 3f2:	00 00       	nop
	if(var_lineNumber_u8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
		var_lineNumber_u8 = mENUM_LcdLineOne; // Select first line if the var_lineNumber_u8 is out of range

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);			 //Disable the Cursor

	for(i=0;ptr_msgPointer_u8[i];i++)
 3f4:	df 5f       	subi	r29, 0xFF	; 255
 3f6:	f6 01       	movw	r30, r12
 3f8:	ed 0f       	add	r30, r29
 3fa:	f1 1d       	adc	r31, r1
 3fc:	80 81       	ld	r24, Z
 3fe:	88 23       	and	r24, r24
 400:	51 f6       	brne	.-108    	; 0x396 <LCD_ScrollMessage+0x3a>
			j++;
		}

		DELAY_ms(200);
	}
	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);			  // Finally enable the Cursor
 402:	8e e0       	ldi	r24, 0x0E	; 14
 404:	0e 94 b0 00 	call	0x160	; 0x160 <LCD_CmdWrite>
}
 408:	df 91       	pop	r29
 40a:	cf 91       	pop	r28
 40c:	1f 91       	pop	r17
 40e:	0f 91       	pop	r16
 410:	ff 90       	pop	r15
 412:	ef 90       	pop	r14
 414:	df 90       	pop	r13
 416:	cf 90       	pop	r12
 418:	bf 90       	pop	r11
 41a:	af 90       	pop	r10
 41c:	08 95       	ret
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 41e:	ca 2d       	mov	r28, r10
 420:	d8 cf       	rjmp	.-80     	; 0x3d2 <LCD_ScrollMessage+0x76>

00000422 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
 422:	8f 92       	push	r8
 424:	9f 92       	push	r9
 426:	af 92       	push	r10
 428:	bf 92       	push	r11
 42a:	ef 92       	push	r14
 42c:	ff 92       	push	r15
 42e:	0f 93       	push	r16
 430:	1f 93       	push	r17
 432:	cf 93       	push	r28
 434:	df 93       	push	r29
 436:	cd b7       	in	r28, 0x3d	; 61
 438:	de b7       	in	r29, 0x3e	; 62
 43a:	2a 97       	sbiw	r28, 0x0a	; 10
 43c:	0f b6       	in	r0, 0x3f	; 63
 43e:	f8 94       	cli
 440:	de bf       	out	0x3e, r29	; 62
 442:	0f be       	out	0x3f, r0	; 63
 444:	cd bf       	out	0x3d, r28	; 61
 446:	dc 01       	movw	r26, r24
 448:	cb 01       	movw	r24, r22
 44a:	04 2f       	mov	r16, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 44c:	00 97       	sbiw	r24, 0x00	; 0
 44e:	a1 05       	cpc	r26, r1
 450:	b1 05       	cpc	r27, r1
 452:	19 f0       	breq	.+6      	; 0x45a <LCD_DisplayDecimalNumber+0x38>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 454:	44 23       	and	r20, r20
 456:	71 f4       	brne	.+28     	; 0x474 <LCD_DisplayDecimalNumber+0x52>
 458:	43 c0       	rjmp	.+134    	; 0x4e0 <LCD_DisplayDecimalNumber+0xbe>
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 45a:	44 23       	and	r20, r20
 45c:	09 f4       	brne	.+2      	; 0x460 <LCD_DisplayDecimalNumber+0x3e>
 45e:	40 c0       	rjmp	.+128    	; 0x4e0 <LCD_DisplayDecimalNumber+0xbe>
 460:	fe 01       	movw	r30, r28
 462:	31 96       	adiw	r30, 0x01	; 1
 464:	10 e0       	ldi	r17, 0x00	; 0
	    	a[i] = 0x00;
 466:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 468:	1f 5f       	subi	r17, 0xFF	; 255
 46a:	10 17       	cp	r17, r16
 46c:	81 f1       	breq	.+96     	; 0x4ce <LCD_DisplayDecimalNumber+0xac>
 46e:	1a 30       	cpi	r17, 0x0A	; 10
 470:	d1 f7       	brne	.-12     	; 0x466 <LCD_DisplayDecimalNumber+0x44>
 472:	2d c0       	rjmp	.+90     	; 0x4ce <LCD_DisplayDecimalNumber+0xac>
 474:	7e 01       	movw	r14, r28
 476:	08 94       	sec
 478:	e1 1c       	adc	r14, r1
 47a:	f1 1c       	adc	r15, r1
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 47c:	10 e0       	ldi	r17, 0x00	; 0
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 47e:	0f 2e       	mov	r0, r31
 480:	fa e0       	ldi	r31, 0x0A	; 10
 482:	8f 2e       	mov	r8, r31
 484:	f0 e0       	ldi	r31, 0x00	; 0
 486:	9f 2e       	mov	r9, r31
 488:	f0 e0       	ldi	r31, 0x00	; 0
 48a:	af 2e       	mov	r10, r31
 48c:	f0 e0       	ldi	r31, 0x00	; 0
 48e:	bf 2e       	mov	r11, r31
 490:	f0 2d       	mov	r31, r0
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
 492:	00 97       	sbiw	r24, 0x00	; 0
 494:	a1 05       	cpc	r26, r1
 496:	b1 05       	cpc	r27, r1
 498:	69 f0       	breq	.+26     	; 0x4b4 <LCD_DisplayDecimalNumber+0x92>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 49a:	bc 01       	movw	r22, r24
 49c:	cd 01       	movw	r24, r26
 49e:	a5 01       	movw	r20, r10
 4a0:	94 01       	movw	r18, r8
 4a2:	0e 94 87 04 	call	0x90e	; 0x90e <__udivmodsi4>
 4a6:	f7 01       	movw	r30, r14
 4a8:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
 4aa:	82 2f       	mov	r24, r18
 4ac:	93 2f       	mov	r25, r19
 4ae:	a4 2f       	mov	r26, r20
 4b0:	b5 2f       	mov	r27, r21
 4b2:	04 c0       	rjmp	.+8      	; 0x4bc <LCD_DisplayDecimalNumber+0x9a>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 4b4:	0b 30       	cpi	r16, 0x0B	; 11
 4b6:	48 f4       	brcc	.+18     	; 0x4ca <LCD_DisplayDecimalNumber+0xa8>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 4b8:	f7 01       	movw	r30, r14
 4ba:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 4bc:	1f 5f       	subi	r17, 0xFF	; 255
 4be:	08 94       	sec
 4c0:	e1 1c       	adc	r14, r1
 4c2:	f1 1c       	adc	r15, r1
 4c4:	10 17       	cp	r17, r16
 4c6:	29 f7       	brne	.-54     	; 0x492 <LCD_DisplayDecimalNumber+0x70>
 4c8:	02 c0       	rjmp	.+4      	; 0x4ce <LCD_DisplayDecimalNumber+0xac>
			}
		}
	}


	while(i)
 4ca:	11 23       	and	r17, r17
 4cc:	49 f0       	breq	.+18     	; 0x4e0 <LCD_DisplayDecimalNumber+0xbe>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
 4ce:	fe 01       	movw	r30, r28
 4d0:	e1 0f       	add	r30, r17
 4d2:	f1 1d       	adc	r31, r1
 4d4:	80 81       	ld	r24, Z
 4d6:	80 5d       	subi	r24, 0xD0	; 208
 4d8:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
		i--;
 4dc:	11 50       	subi	r17, 0x01	; 1
			}
		}
	}


	while(i)
 4de:	b9 f7       	brne	.-18     	; 0x4ce <LCD_DisplayDecimalNumber+0xac>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
 4e0:	2a 96       	adiw	r28, 0x0a	; 10
 4e2:	0f b6       	in	r0, 0x3f	; 63
 4e4:	f8 94       	cli
 4e6:	de bf       	out	0x3e, r29	; 62
 4e8:	0f be       	out	0x3f, r0	; 63
 4ea:	cd bf       	out	0x3d, r28	; 61
 4ec:	df 91       	pop	r29
 4ee:	cf 91       	pop	r28
 4f0:	1f 91       	pop	r17
 4f2:	0f 91       	pop	r16
 4f4:	ff 90       	pop	r15
 4f6:	ef 90       	pop	r14
 4f8:	bf 90       	pop	r11
 4fa:	af 90       	pop	r10
 4fc:	9f 90       	pop	r9
 4fe:	8f 90       	pop	r8
 500:	08 95       	ret

00000502 <LCD_DisplayHexNumber>:
				2.(0x12AB,6) then 6-digits ie. 0012AB will be displayed
				3.(0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ***************************************************************************************************/
#if ( Enable_LCD_DisplayHexNumber == 1 ) 
void LCD_DisplayHexNumber(uint32_t var_hexNumber_u32,uint8_t var_numOfDigitsToDisplay_u8)
{
 502:	1f 93       	push	r17
 504:	cf 93       	push	r28
 506:	df 93       	push	r29
 508:	cd b7       	in	r28, 0x3d	; 61
 50a:	de b7       	in	r29, 0x3e	; 62
 50c:	2a 97       	sbiw	r28, 0x0a	; 10
 50e:	0f b6       	in	r0, 0x3f	; 63
 510:	f8 94       	cli
 512:	de bf       	out	0x3e, r29	; 62
 514:	0f be       	out	0x3f, r0	; 63
 516:	cd bf       	out	0x3d, r28	; 61
 518:	dc 01       	movw	r26, r24
 51a:	cb 01       	movw	r24, r22
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
 51c:	00 97       	sbiw	r24, 0x00	; 0
 51e:	a1 05       	cpc	r26, r1
 520:	b1 05       	cpc	r27, r1
 522:	19 f0       	breq	.+6      	; 0x52a <LCD_DisplayHexNumber+0x28>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 524:	44 23       	and	r20, r20
 526:	69 f4       	brne	.+26     	; 0x542 <LCD_DisplayHexNumber+0x40>
 528:	36 c0       	rjmp	.+108    	; 0x596 <LCD_DisplayHexNumber+0x94>
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 52a:	44 23       	and	r20, r20
 52c:	a1 f1       	breq	.+104    	; 0x596 <LCD_DisplayHexNumber+0x94>
 52e:	fe 01       	movw	r30, r28
 530:	31 96       	adiw	r30, 0x01	; 1
 532:	10 e0       	ldi	r17, 0x00	; 0
		    a[i] = 0x00;
 534:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 536:	1f 5f       	subi	r17, 0xFF	; 255
 538:	14 17       	cp	r17, r20
 53a:	01 f1       	breq	.+64     	; 0x57c <LCD_DisplayHexNumber+0x7a>
 53c:	1a 30       	cpi	r17, 0x0A	; 10
 53e:	d1 f7       	brne	.-12     	; 0x534 <LCD_DisplayHexNumber+0x32>
 540:	1d c0       	rjmp	.+58     	; 0x57c <LCD_DisplayHexNumber+0x7a>
 542:	fe 01       	movw	r30, r28
 544:	31 96       	adiw	r30, 0x01	; 1
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 546:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_hexNumber_u32!=0)
 548:	00 97       	sbiw	r24, 0x00	; 0
 54a:	a1 05       	cpc	r26, r1
 54c:	b1 05       	cpc	r27, r1
 54e:	61 f0       	breq	.+24     	; 0x568 <LCD_DisplayHexNumber+0x66>
			{
				/* Extract the digits from the number till it becomes zero.
			   First get the lower nibble and shift the number 4 times.
			   if var_num_u32 = 0xABC then extracted digit will be 0x0C and number will become 0xAB.
			   The process continues till it becomes zero or max digits reached*/
				a[i]=(uint8_t)(var_hexNumber_u32 & 0x0f);
 550:	28 2f       	mov	r18, r24
 552:	2f 70       	andi	r18, 0x0F	; 15
 554:	20 83       	st	Z, r18
				var_hexNumber_u32=var_hexNumber_u32 >> 4;
 556:	68 94       	set
 558:	13 f8       	bld	r1, 3
 55a:	b6 95       	lsr	r27
 55c:	a7 95       	ror	r26
 55e:	97 95       	ror	r25
 560:	87 95       	ror	r24
 562:	16 94       	lsr	r1
 564:	d1 f7       	brne	.-12     	; 0x55a <LCD_DisplayHexNumber+0x58>
 566:	03 c0       	rjmp	.+6      	; 0x56e <LCD_DisplayHexNumber+0x6c>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 568:	4b 30       	cpi	r20, 0x0B	; 11
 56a:	30 f4       	brcc	.+12     	; 0x578 <LCD_DisplayHexNumber+0x76>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
                Ex: var_num_u32 is 0x123 and user wants five digits then 00123 has to be displayed */
				a[i]=0x00;
 56c:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 56e:	1f 5f       	subi	r17, 0xFF	; 255
 570:	31 96       	adiw	r30, 0x01	; 1
 572:	14 17       	cp	r17, r20
 574:	49 f7       	brne	.-46     	; 0x548 <LCD_DisplayHexNumber+0x46>
 576:	02 c0       	rjmp	.+4      	; 0x57c <LCD_DisplayHexNumber+0x7a>
				a[i]=0x00;
			}
		}
	}

	while(i!=0)
 578:	11 23       	and	r17, r17
 57a:	69 f0       	breq	.+26     	; 0x596 <LCD_DisplayHexNumber+0x94>
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
 57c:	fe 01       	movw	r30, r28
 57e:	e1 0f       	add	r30, r17
 580:	f1 1d       	adc	r31, r1
 582:	80 81       	ld	r24, Z
 584:	8a 30       	cpi	r24, 0x0A	; 10
 586:	10 f0       	brcs	.+4      	; 0x58c <LCD_DisplayHexNumber+0x8a>
 588:	89 5c       	subi	r24, 0xC9	; 201
 58a:	01 c0       	rjmp	.+2      	; 0x58e <LCD_DisplayHexNumber+0x8c>
 58c:	80 5d       	subi	r24, 0xD0	; 208
 58e:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
		i--;
 592:	11 50       	subi	r17, 0x01	; 1
				a[i]=0x00;
			}
		}
	}

	while(i!=0)
 594:	99 f7       	brne	.-26     	; 0x57c <LCD_DisplayHexNumber+0x7a>
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
		i--;
	}
}
 596:	2a 96       	adiw	r28, 0x0a	; 10
 598:	0f b6       	in	r0, 0x3f	; 63
 59a:	f8 94       	cli
 59c:	de bf       	out	0x3e, r29	; 62
 59e:	0f be       	out	0x3f, r0	; 63
 5a0:	cd bf       	out	0x3d, r28	; 61
 5a2:	df 91       	pop	r29
 5a4:	cf 91       	pop	r28
 5a6:	1f 91       	pop	r17
 5a8:	08 95       	ret

000005aa <LCD_DisplayBinaryNumber>:
				2.(10,8) then 8-LSB will be displayed ie. 00001010
				3.(10,2) then 2-LSB will be displayed ie. 10
 *************************************************************************************************/
#if (Enable_LCD_DisplayBinaryNumber == 1)
void LCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
 5aa:	bf 92       	push	r11
 5ac:	cf 92       	push	r12
 5ae:	df 92       	push	r13
 5b0:	ef 92       	push	r14
 5b2:	ff 92       	push	r15
 5b4:	0f 93       	push	r16
 5b6:	1f 93       	push	r17
 5b8:	cf 93       	push	r28
 5ba:	df 93       	push	r29
 5bc:	6b 01       	movw	r12, r22
 5be:	7c 01       	movw	r14, r24
 5c0:	c4 2f       	mov	r28, r20
	uint8_t ch;
	  
	while(var_numOfBitsToDisplay_u8!=0)
 5c2:	44 23       	and	r20, r20
 5c4:	19 f1       	breq	.+70     	; 0x60c <LCD_DisplayBinaryNumber+0x62>
	{
		/* Start Extracting the bits from the specified bit positions.
	     Get the Acsii values of the bits and display */
		ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
 5c6:	01 e0       	ldi	r16, 0x01	; 1
 5c8:	10 e0       	ldi	r17, 0x00	; 0
 5ca:	d1 e0       	ldi	r29, 0x01	; 1
 5cc:	bb 24       	eor	r11, r11
 5ce:	4c 2f       	mov	r20, r28
 5d0:	50 e0       	ldi	r21, 0x00	; 0
 5d2:	41 50       	subi	r20, 0x01	; 1
 5d4:	50 40       	sbci	r21, 0x00	; 0
 5d6:	c8 01       	movw	r24, r16
 5d8:	02 c0       	rjmp	.+4      	; 0x5de <LCD_DisplayBinaryNumber+0x34>
 5da:	88 0f       	add	r24, r24
 5dc:	99 1f       	adc	r25, r25
 5de:	4a 95       	dec	r20
 5e0:	e2 f7       	brpl	.-8      	; 0x5da <LCD_DisplayBinaryNumber+0x30>
 5e2:	ac 01       	movw	r20, r24
 5e4:	66 27       	eor	r22, r22
 5e6:	57 fd       	sbrc	r21, 7
 5e8:	60 95       	com	r22
 5ea:	76 2f       	mov	r23, r22
 5ec:	4c 21       	and	r20, r12
 5ee:	5d 21       	and	r21, r13
 5f0:	6e 21       	and	r22, r14
 5f2:	7f 21       	and	r23, r15
 5f4:	8d 2f       	mov	r24, r29
 5f6:	41 15       	cp	r20, r1
 5f8:	51 05       	cpc	r21, r1
 5fa:	61 05       	cpc	r22, r1
 5fc:	71 05       	cpc	r23, r1
 5fe:	09 f4       	brne	.+2      	; 0x602 <LCD_DisplayBinaryNumber+0x58>
 600:	8b 2d       	mov	r24, r11
		LCD_DisplayChar(util_Dec2Ascii(ch));
 602:	80 5d       	subi	r24, 0xD0	; 208
 604:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
		var_numOfBitsToDisplay_u8--;
 608:	c1 50       	subi	r28, 0x01	; 1
#if (Enable_LCD_DisplayBinaryNumber == 1)
void LCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
	uint8_t ch;
	  
	while(var_numOfBitsToDisplay_u8!=0)
 60a:	09 f7       	brne	.-62     	; 0x5ce <LCD_DisplayBinaryNumber+0x24>
	     Get the Acsii values of the bits and display */
		ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
		LCD_DisplayChar(util_Dec2Ascii(ch));
		var_numOfBitsToDisplay_u8--;
	}
}
 60c:	df 91       	pop	r29
 60e:	cf 91       	pop	r28
 610:	1f 91       	pop	r17
 612:	0f 91       	pop	r16
 614:	ff 90       	pop	r15
 616:	ef 90       	pop	r14
 618:	df 90       	pop	r13
 61a:	cf 90       	pop	r12
 61c:	bf 90       	pop	r11
 61e:	08 95       	ret

00000620 <LCD_Printf>:
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 620:	5f 92       	push	r5
 622:	6f 92       	push	r6
 624:	7f 92       	push	r7
 626:	8f 92       	push	r8
 628:	9f 92       	push	r9
 62a:	af 92       	push	r10
 62c:	bf 92       	push	r11
 62e:	cf 92       	push	r12
 630:	df 92       	push	r13
 632:	ef 92       	push	r14
 634:	ff 92       	push	r15
 636:	0f 93       	push	r16
 638:	1f 93       	push	r17
 63a:	cf 93       	push	r28
 63c:	df 93       	push	r29
 63e:	cd b7       	in	r28, 0x3d	; 61
 640:	de b7       	in	r29, 0x3e	; 62
 642:	0f 2e       	mov	r0, r31
 644:	f2 e1       	ldi	r31, 0x12	; 18
 646:	cf 2e       	mov	r12, r31
 648:	dd 24       	eor	r13, r13
 64a:	f0 2d       	mov	r31, r0
 64c:	cc 0e       	add	r12, r28
 64e:	dd 1e       	adc	r13, r29
 650:	d6 01       	movw	r26, r12
 652:	ed 91       	ld	r30, X+
 654:	fd 91       	ld	r31, X+
 656:	6d 01       	movw	r12, r26
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 658:	80 81       	ld	r24, Z
 65a:	88 23       	and	r24, r24
 65c:	09 f4       	brne	.+2      	; 0x660 <LCD_Printf+0x40>
 65e:	28 c1       	rjmp	.+592    	; 0x8b0 <LCD_Printf+0x290>
 660:	8f 01       	movw	r16, r30
			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;
 662:	55 24       	eor	r5, r5
 664:	68 94       	set
 666:	54 f8       	bld	r5, 4
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 668:	99 24       	eor	r9, r9
 66a:	9a 94       	dec	r9
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 66c:	88 24       	eor	r8, r8
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 66e:	85 32       	cpi	r24, 0x25	; 37
 670:	09 f0       	breq	.+2      	; 0x674 <LCD_Printf+0x54>
 672:	11 c1       	rjmp	.+546    	; 0x896 <LCD_Printf+0x276>
		{
		    ptr++;
 674:	58 01       	movw	r10, r16
 676:	08 94       	sec
 678:	a1 1c       	adc	r10, r1
 67a:	b1 1c       	adc	r11, r1
		    ch = *ptr;
 67c:	f8 01       	movw	r30, r16
 67e:	81 81       	ldd	r24, Z+1	; 0x01
		   if((ch>=0x30) && (ch<=0x39))
 680:	98 2f       	mov	r25, r24
 682:	90 53       	subi	r25, 0x30	; 48
 684:	9a 30       	cpi	r25, 0x0A	; 10
 686:	80 f4       	brcc	.+32     	; 0x6a8 <LCD_Printf+0x88>
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 688:	32 96       	adiw	r30, 0x02	; 2
 68a:	18 2d       	mov	r17, r8
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 68c:	11 0f       	add	r17, r17
 68e:	91 2f       	mov	r25, r17
 690:	99 0f       	add	r25, r25
 692:	99 0f       	add	r25, r25
 694:	19 0f       	add	r17, r25
 696:	80 53       	subi	r24, 0x30	; 48
 698:	18 0f       	add	r17, r24
				   ptr++;
 69a:	5f 01       	movw	r10, r30
				   ch = *ptr;
 69c:	81 91       	ld	r24, Z+
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 69e:	98 2f       	mov	r25, r24
 6a0:	90 53       	subi	r25, 0x30	; 48
 6a2:	9a 30       	cpi	r25, 0x0A	; 10
 6a4:	98 f3       	brcs	.-26     	; 0x68c <LCD_Printf+0x6c>
 6a6:	01 c0       	rjmp	.+2      	; 0x6aa <LCD_Printf+0x8a>
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 6a8:	19 2d       	mov	r17, r9
			}				


			switch(ch)       /* Decode the type of the argument */
 6aa:	88 35       	cpi	r24, 0x58	; 88
 6ac:	09 f4       	brne	.+2      	; 0x6b0 <LCD_Printf+0x90>
 6ae:	a8 c0       	rjmp	.+336    	; 0x800 <LCD_Printf+0x1e0>
 6b0:	89 35       	cpi	r24, 0x59	; 89
 6b2:	c0 f4       	brcc	.+48     	; 0x6e4 <LCD_Printf+0xc4>
 6b4:	84 34       	cpi	r24, 0x44	; 68
 6b6:	09 f4       	brne	.+2      	; 0x6ba <LCD_Printf+0x9a>
 6b8:	51 c0       	rjmp	.+162    	; 0x75c <LCD_Printf+0x13c>
 6ba:	85 34       	cpi	r24, 0x45	; 69
 6bc:	48 f4       	brcc	.+18     	; 0x6d0 <LCD_Printf+0xb0>
 6be:	82 34       	cpi	r24, 0x42	; 66
 6c0:	09 f4       	brne	.+2      	; 0x6c4 <LCD_Printf+0xa4>
 6c2:	c2 c0       	rjmp	.+388    	; 0x848 <LCD_Printf+0x228>
 6c4:	83 34       	cpi	r24, 0x43	; 67
 6c6:	28 f5       	brcc	.+74     	; 0x712 <LCD_Printf+0xf2>
 6c8:	85 32       	cpi	r24, 0x25	; 37
 6ca:	09 f0       	breq	.+2      	; 0x6ce <LCD_Printf+0xae>
 6cc:	e7 c0       	rjmp	.+462    	; 0x89c <LCD_Printf+0x27c>
 6ce:	df c0       	rjmp	.+446    	; 0x88e <LCD_Printf+0x26e>
 6d0:	83 35       	cpi	r24, 0x53	; 83
 6d2:	09 f4       	brne	.+2      	; 0x6d6 <LCD_Printf+0xb6>
 6d4:	d2 c0       	rjmp	.+420    	; 0x87a <LCD_Printf+0x25a>
 6d6:	85 35       	cpi	r24, 0x55	; 85
 6d8:	09 f4       	brne	.+2      	; 0x6dc <LCD_Printf+0xbc>
 6da:	71 c0       	rjmp	.+226    	; 0x7be <LCD_Printf+0x19e>
 6dc:	86 34       	cpi	r24, 0x46	; 70
 6de:	09 f0       	breq	.+2      	; 0x6e2 <LCD_Printf+0xc2>
 6e0:	dd c0       	rjmp	.+442    	; 0x89c <LCD_Printf+0x27c>
 6e2:	c6 c0       	rjmp	.+396    	; 0x870 <LCD_Printf+0x250>
 6e4:	86 36       	cpi	r24, 0x66	; 102
 6e6:	09 f4       	brne	.+2      	; 0x6ea <LCD_Printf+0xca>
 6e8:	c3 c0       	rjmp	.+390    	; 0x870 <LCD_Printf+0x250>
 6ea:	87 36       	cpi	r24, 0x67	; 103
 6ec:	40 f4       	brcc	.+16     	; 0x6fe <LCD_Printf+0xde>
 6ee:	83 36       	cpi	r24, 0x63	; 99
 6f0:	81 f0       	breq	.+32     	; 0x712 <LCD_Printf+0xf2>
 6f2:	84 36       	cpi	r24, 0x64	; 100
 6f4:	b9 f0       	breq	.+46     	; 0x724 <LCD_Printf+0x104>
 6f6:	82 36       	cpi	r24, 0x62	; 98
 6f8:	09 f0       	breq	.+2      	; 0x6fc <LCD_Printf+0xdc>
 6fa:	d0 c0       	rjmp	.+416    	; 0x89c <LCD_Printf+0x27c>
 6fc:	91 c0       	rjmp	.+290    	; 0x820 <LCD_Printf+0x200>
 6fe:	85 37       	cpi	r24, 0x75	; 117
 700:	09 f4       	brne	.+2      	; 0x704 <LCD_Printf+0xe4>
 702:	4c c0       	rjmp	.+152    	; 0x79c <LCD_Printf+0x17c>
 704:	88 37       	cpi	r24, 0x78	; 120
 706:	09 f4       	brne	.+2      	; 0x70a <LCD_Printf+0xea>
 708:	6a c0       	rjmp	.+212    	; 0x7de <LCD_Printf+0x1be>
 70a:	83 37       	cpi	r24, 0x73	; 115
 70c:	09 f0       	breq	.+2      	; 0x710 <LCD_Printf+0xf0>
 70e:	c6 c0       	rjmp	.+396    	; 0x89c <LCD_Printf+0x27c>
 710:	b4 c0       	rjmp	.+360    	; 0x87a <LCD_Printf+0x25a>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 712:	86 01       	movw	r16, r12
 714:	0e 5f       	subi	r16, 0xFE	; 254
 716:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 718:	d6 01       	movw	r26, r12
 71a:	8c 91       	ld	r24, X
 71c:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>

			switch(ch)       /* Decode the type of the argument */
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 720:	68 01       	movw	r12, r16
				LCD_DisplayChar(ch);
				break;
 722:	bc c0       	rjmp	.+376    	; 0x89c <LCD_Printf+0x27c>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 724:	ee 24       	eor	r14, r14
 726:	ff 24       	eor	r15, r15
 728:	68 94       	set
 72a:	e1 f8       	bld	r14, 1
 72c:	ec 0c       	add	r14, r12
 72e:	fd 1c       	adc	r15, r13
 730:	f6 01       	movw	r30, r12
 732:	c0 80       	ld	r12, Z
 734:	d1 80       	ldd	r13, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
 736:	dd 20       	and	r13, r13
 738:	3c f4       	brge	.+14     	; 0x748 <LCD_Printf+0x128>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
 73a:	d0 94       	com	r13
 73c:	c1 94       	neg	r12
 73e:	d1 08       	sbc	r13, r1
 740:	d3 94       	inc	r13
				   LCD_DisplayChar('-');
 742:	8d e2       	ldi	r24, 0x2D	; 45
 744:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
 748:	b6 01       	movw	r22, r12
 74a:	88 27       	eor	r24, r24
 74c:	77 fd       	sbrc	r23, 7
 74e:	80 95       	com	r24
 750:	98 2f       	mov	r25, r24
 752:	41 2f       	mov	r20, r17
 754:	0e 94 11 02 	call	0x422	; 0x422 <LCD_DisplayDecimalNumber>
				ch = va_arg(argp, uint16_t);
				LCD_DisplayChar(ch);
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 758:	67 01       	movw	r12, r14
				   var_num_s16 = -var_num_s16;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
 75a:	a0 c0       	rjmp	.+320    	; 0x89c <LCD_Printf+0x27c>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 75c:	66 24       	eor	r6, r6
 75e:	77 24       	eor	r7, r7
 760:	68 94       	set
 762:	62 f8       	bld	r6, 2
 764:	6c 0c       	add	r6, r12
 766:	7d 1c       	adc	r7, r13
 768:	d6 01       	movw	r26, r12
 76a:	cd 90       	ld	r12, X+
 76c:	dd 90       	ld	r13, X+
 76e:	ed 90       	ld	r14, X+
 770:	fc 90       	ld	r15, X
 772:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
 774:	ff 20       	and	r15, r15
 776:	5c f4       	brge	.+22     	; 0x78e <LCD_Printf+0x16e>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
 778:	f0 94       	com	r15
 77a:	e0 94       	com	r14
 77c:	d0 94       	com	r13
 77e:	c0 94       	com	r12
 780:	c1 1c       	adc	r12, r1
 782:	d1 1c       	adc	r13, r1
 784:	e1 1c       	adc	r14, r1
 786:	f1 1c       	adc	r15, r1
				   LCD_DisplayChar('-');
 788:	8d e2       	ldi	r24, 0x2D	; 45
 78a:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
 78e:	c7 01       	movw	r24, r14
 790:	b6 01       	movw	r22, r12
 792:	41 2f       	mov	r20, r17
 794:	0e 94 11 02 	call	0x422	; 0x422 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 798:	63 01       	movw	r12, r6
				   var_num_s32 = -var_num_s32;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	
 79a:	80 c0       	rjmp	.+256    	; 0x89c <LCD_Printf+0x27c>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 79c:	ee 24       	eor	r14, r14
 79e:	ff 24       	eor	r15, r15
 7a0:	68 94       	set
 7a2:	e1 f8       	bld	r14, 1
 7a4:	ec 0c       	add	r14, r12
 7a6:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 7a8:	f6 01       	movw	r30, r12
 7aa:	80 81       	ld	r24, Z
 7ac:	91 81       	ldd	r25, Z+1	; 0x01
 7ae:	bc 01       	movw	r22, r24
 7b0:	80 e0       	ldi	r24, 0x00	; 0
 7b2:	90 e0       	ldi	r25, 0x00	; 0
 7b4:	41 2f       	mov	r20, r17
 7b6:	0e 94 11 02 	call	0x422	; 0x422 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 7ba:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 7bc:	6f c0       	rjmp	.+222    	; 0x89c <LCD_Printf+0x27c>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 7be:	ee 24       	eor	r14, r14
 7c0:	ff 24       	eor	r15, r15
 7c2:	68 94       	set
 7c4:	e2 f8       	bld	r14, 2
 7c6:	ec 0c       	add	r14, r12
 7c8:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 7ca:	d6 01       	movw	r26, r12
 7cc:	6d 91       	ld	r22, X+
 7ce:	7d 91       	ld	r23, X+
 7d0:	8d 91       	ld	r24, X+
 7d2:	9c 91       	ld	r25, X
 7d4:	41 2f       	mov	r20, r17
 7d6:	0e 94 11 02 	call	0x422	; 0x422 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 7da:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			
 7dc:	5f c0       	rjmp	.+190    	; 0x89c <LCD_Printf+0x27c>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
 7de:	ee 24       	eor	r14, r14
 7e0:	ff 24       	eor	r15, r15
 7e2:	68 94       	set
 7e4:	e1 f8       	bld	r14, 1
 7e6:	ec 0c       	add	r14, r12
 7e8:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 7ea:	f6 01       	movw	r30, r12
 7ec:	80 81       	ld	r24, Z
 7ee:	91 81       	ldd	r25, Z+1	; 0x01
 7f0:	bc 01       	movw	r22, r24
 7f2:	80 e0       	ldi	r24, 0x00	; 0
 7f4:	90 e0       	ldi	r25, 0x00	; 0
 7f6:	41 2f       	mov	r20, r17
 7f8:	0e 94 81 02 	call	0x502	; 0x502 <LCD_DisplayHexNumber>
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
 7fc:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 7fe:	4e c0       	rjmp	.+156    	; 0x89c <LCD_Printf+0x27c>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
 800:	ee 24       	eor	r14, r14
 802:	ff 24       	eor	r15, r15
 804:	68 94       	set
 806:	e2 f8       	bld	r14, 2
 808:	ec 0c       	add	r14, r12
 80a:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 80c:	d6 01       	movw	r26, r12
 80e:	6d 91       	ld	r22, X+
 810:	7d 91       	ld	r23, X+
 812:	8d 91       	ld	r24, X+
 814:	9c 91       	ld	r25, X
 816:	41 2f       	mov	r20, r17
 818:	0e 94 81 02 	call	0x502	; 0x502 <LCD_DisplayHexNumber>
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
 81c:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;
 81e:	3e c0       	rjmp	.+124    	; 0x89c <LCD_Printf+0x27c>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 820:	ee 24       	eor	r14, r14
 822:	ff 24       	eor	r15, r15
 824:	68 94       	set
 826:	e1 f8       	bld	r14, 1
 828:	ec 0c       	add	r14, r12
 82a:	fd 1c       	adc	r15, r13
 82c:	f6 01       	movw	r30, r12
 82e:	80 81       	ld	r24, Z
 830:	91 81       	ldd	r25, Z+1	; 0x01
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
 832:	1f 3f       	cpi	r17, 0xFF	; 255
 834:	09 f4       	brne	.+2      	; 0x838 <LCD_Printf+0x218>
				   var_numOfDigitsToDisp_u8 = 16;
 836:	15 2d       	mov	r17, r5
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 838:	bc 01       	movw	r22, r24
 83a:	80 e0       	ldi	r24, 0x00	; 0
 83c:	90 e0       	ldi	r25, 0x00	; 0
 83e:	41 2f       	mov	r20, r17
 840:	0e 94 d5 02 	call	0x5aa	; 0x5aa <LCD_DisplayBinaryNumber>
#endif				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 844:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 846:	2a c0       	rjmp	.+84     	; 0x89c <LCD_Printf+0x27c>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 848:	ee 24       	eor	r14, r14
 84a:	ff 24       	eor	r15, r15
 84c:	68 94       	set
 84e:	e2 f8       	bld	r14, 2
 850:	ec 0c       	add	r14, r12
 852:	fd 1c       	adc	r15, r13
 854:	d6 01       	movw	r26, r12
 856:	6d 91       	ld	r22, X+
 858:	7d 91       	ld	r23, X+
 85a:	8d 91       	ld	r24, X+
 85c:	9c 91       	ld	r25, X
 85e:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
 860:	1f 3f       	cpi	r17, 0xFF	; 255
 862:	09 f4       	brne	.+2      	; 0x866 <LCD_Printf+0x246>
				   var_numOfDigitsToDisp_u8 = 16;				
 864:	15 2d       	mov	r17, r5
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
 866:	41 2f       	mov	r20, r17
 868:	0e 94 d5 02 	call	0x5aa	; 0x5aa <LCD_DisplayBinaryNumber>
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 86c:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;				
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
#endif				
				break;
 86e:	16 c0       	rjmp	.+44     	; 0x89c <LCD_Printf+0x27c>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 870:	e4 e0       	ldi	r30, 0x04	; 4
 872:	f0 e0       	ldi	r31, 0x00	; 0
 874:	ce 0e       	add	r12, r30
 876:	df 1e       	adc	r13, r31
#if (Enable_LCD_DisplayFloatNumber == 1)				
				LCD_DisplayFloatNumber(var_floatNum_f32);
#endif
				break;
 878:	11 c0       	rjmp	.+34     	; 0x89c <LCD_Printf+0x27c>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 87a:	f6 01       	movw	r30, r12
 87c:	82 e0       	ldi	r24, 0x02	; 2
 87e:	90 e0       	ldi	r25, 0x00	; 0
 880:	c8 0e       	add	r12, r24
 882:	d9 1e       	adc	r13, r25
#if (Enable_LCD_DisplayString == 1)
				LCD_DisplayString(str);
 884:	80 81       	ld	r24, Z
 886:	91 81       	ldd	r25, Z+1	; 0x01
 888:	0e 94 9f 01 	call	0x33e	; 0x33e <LCD_DisplayString>
#endif				
				break;
 88c:	07 c0       	rjmp	.+14     	; 0x89c <LCD_Printf+0x27c>

			case '%':
				LCD_DisplayChar('%');
 88e:	85 e2       	ldi	r24, 0x25	; 37
 890:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
				break;
 894:	03 c0       	rjmp	.+6      	; 0x89c <LCD_Printf+0x27c>
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 896:	0e 94 6e 01 	call	0x2dc	; 0x2dc <LCD_DisplayChar>
 89a:	58 01       	movw	r10, r16
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 89c:	85 01       	movw	r16, r10
 89e:	0f 5f       	subi	r16, 0xFF	; 255
 8a0:	1f 4f       	sbci	r17, 0xFF	; 255
 8a2:	d5 01       	movw	r26, r10
 8a4:	11 96       	adiw	r26, 0x01	; 1
 8a6:	8c 91       	ld	r24, X
 8a8:	11 97       	sbiw	r26, 0x01	; 1
 8aa:	88 23       	and	r24, r24
 8ac:	09 f0       	breq	.+2      	; 0x8b0 <LCD_Printf+0x290>
 8ae:	df ce       	rjmp	.-578    	; 0x66e <LCD_Printf+0x4e>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 8b0:	df 91       	pop	r29
 8b2:	cf 91       	pop	r28
 8b4:	1f 91       	pop	r17
 8b6:	0f 91       	pop	r16
 8b8:	ff 90       	pop	r15
 8ba:	ef 90       	pop	r14
 8bc:	df 90       	pop	r13
 8be:	cf 90       	pop	r12
 8c0:	bf 90       	pop	r11
 8c2:	af 90       	pop	r10
 8c4:	9f 90       	pop	r9
 8c6:	8f 90       	pop	r8
 8c8:	7f 90       	pop	r7
 8ca:	6f 90       	pop	r6
 8cc:	5f 90       	pop	r5
 8ce:	08 95       	ret

000008d0 <main>:
//port configuration is configured in lcd.h


int main(void)
{
	LCD_Init(4,2,16); // 4 bit mode, 2 lines, 16 characters
 8d0:	84 e0       	ldi	r24, 0x04	; 4
 8d2:	62 e0       	ldi	r22, 0x02	; 2
 8d4:	40 e1       	ldi	r20, 0x10	; 16
 8d6:	0e 94 10 01 	call	0x220	; 0x220 <LCD_Init>
	LCD_Printf("ExploreEmbedded\nLet's build. . .");
 8da:	00 d0       	rcall	.+0      	; 0x8dc <main+0xc>
 8dc:	85 e0       	ldi	r24, 0x05	; 5
 8de:	91 e0       	ldi	r25, 0x01	; 1
 8e0:	ed b7       	in	r30, 0x3d	; 61
 8e2:	fe b7       	in	r31, 0x3e	; 62
 8e4:	92 83       	std	Z+2, r25	; 0x02
 8e6:	81 83       	std	Z+1, r24	; 0x01
 8e8:	0e 94 10 03 	call	0x620	; 0x620 <LCD_Printf>
 8ec:	0f 90       	pop	r0
 8ee:	0f 90       	pop	r0
 8f0:	ff cf       	rjmp	.-2      	; 0x8f0 <main+0x20>

000008f2 <DELAY_sec>:
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
 8f2:	00 97       	sbiw	r24, 0x00	; 0
 8f4:	59 f0       	breq	.+22     	; 0x90c <DELAY_sec+0x1a>
 8f6:	2f ef       	ldi	r18, 0xFF	; 255
 8f8:	33 ed       	ldi	r19, 0xD3	; 211
 8fa:	40 e3       	ldi	r20, 0x30	; 48
 8fc:	21 50       	subi	r18, 0x01	; 1
 8fe:	30 40       	sbci	r19, 0x00	; 0
 900:	40 40       	sbci	r20, 0x00	; 0
 902:	e1 f7       	brne	.-8      	; 0x8fc <DELAY_sec+0xa>
 904:	00 c0       	rjmp	.+0      	; 0x906 <DELAY_sec+0x14>
 906:	00 00       	nop
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
 908:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
 90a:	a9 f7       	brne	.-22     	; 0x8f6 <DELAY_sec+0x4>
 90c:	08 95       	ret

0000090e <__udivmodsi4>:
 90e:	a1 e2       	ldi	r26, 0x21	; 33
 910:	1a 2e       	mov	r1, r26
 912:	aa 1b       	sub	r26, r26
 914:	bb 1b       	sub	r27, r27
 916:	fd 01       	movw	r30, r26
 918:	0d c0       	rjmp	.+26     	; 0x934 <__udivmodsi4_ep>

0000091a <__udivmodsi4_loop>:
 91a:	aa 1f       	adc	r26, r26
 91c:	bb 1f       	adc	r27, r27
 91e:	ee 1f       	adc	r30, r30
 920:	ff 1f       	adc	r31, r31
 922:	a2 17       	cp	r26, r18
 924:	b3 07       	cpc	r27, r19
 926:	e4 07       	cpc	r30, r20
 928:	f5 07       	cpc	r31, r21
 92a:	20 f0       	brcs	.+8      	; 0x934 <__udivmodsi4_ep>
 92c:	a2 1b       	sub	r26, r18
 92e:	b3 0b       	sbc	r27, r19
 930:	e4 0b       	sbc	r30, r20
 932:	f5 0b       	sbc	r31, r21

00000934 <__udivmodsi4_ep>:
 934:	66 1f       	adc	r22, r22
 936:	77 1f       	adc	r23, r23
 938:	88 1f       	adc	r24, r24
 93a:	99 1f       	adc	r25, r25
 93c:	1a 94       	dec	r1
 93e:	69 f7       	brne	.-38     	; 0x91a <__udivmodsi4_loop>
 940:	60 95       	com	r22
 942:	70 95       	com	r23
 944:	80 95       	com	r24
 946:	90 95       	com	r25
 948:	9b 01       	movw	r18, r22
 94a:	ac 01       	movw	r20, r24
 94c:	bd 01       	movw	r22, r26
 94e:	cf 01       	movw	r24, r30
 950:	08 95       	ret

00000952 <_exit>:
 952:	f8 94       	cli

00000954 <__stop_program>:
 954:	ff cf       	rjmp	.-2      	; 0x954 <__stop_program>
