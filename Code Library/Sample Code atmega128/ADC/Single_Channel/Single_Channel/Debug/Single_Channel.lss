
Single_Channel.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001a  00800100  00000982  00000a16  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000982  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  0080011a  0080011a  00000a30  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000a30  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  000010fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e0  00000000  00000000  00001188  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e13  00000000  00000000  00001268  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000038f  00000000  00000000  0000207b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000784  00000000  00000000  0000240a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002b0  00000000  00000000  00002b90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000573  00000000  00000000  00002e40  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000d35  00000000  00000000  000033b3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e2 e8       	ldi	r30, 0x82	; 130
  a0:	f9 e0       	ldi	r31, 0x09	; 9
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	aa 31       	cpi	r26, 0x1A	; 26
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	aa e1       	ldi	r26, 0x1A	; 26
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	af 31       	cpi	r26, 0x1F	; 31
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 73 04 	call	0x8e6	; 0x8e6 <main>
  c6:	0c 94 bf 04 	jmp	0x97e	; 0x97e <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <ADC_Init>:
 * description :This function initializes the ADC module.

***************************************************************************************************/
void ADC_Init()
 {
   ADCSRA=(1<<ADEN) | (1<<ADPS0); /* Enable ADC , sampling freq=osc_freq/2 */
  ce:	81 e8       	ldi	r24, 0x81	; 129
  d0:	86 b9       	out	0x06, r24	; 6
   ADMUX=0x00;                    /* Result right justified, select channel zero */
  d2:	17 b8       	out	0x07, r1	; 7
  }
  d4:	08 95       	ret

000000d6 <ADC_GetAdcValue>:
				 For AVR/PIC(10-bit adc) the adc value per lsb will be 5/1023=0048v
***************************************************************************************************/				 
uint16_t ADC_GetAdcValue(uint8_t var_adcChannel_u8)
 {
   
   ADMUX = var_adcChannel_u8;               /* Select the required channel */
  d6:	87 b9       	out	0x07, r24	; 7
   util_BitSet(ADCSRA,ADSC);              /* Start the ADC conversion by setting ADSC bit */
  d8:	36 9a       	sbi	0x06, 6	; 6
   
   while(util_IsBitCleared(ADCSRA,ADIF)); /* Wait till the conversion is over */
  da:	34 9b       	sbis	0x06, 4	; 6
  dc:	fe cf       	rjmp	.-4      	; 0xda <ADC_GetAdcValue+0x4>
                                          /* ADIF will be set once ADC conversion is complete */
     return(ADCW);                        /* Return the 10-bit result */
  de:	84 b1       	in	r24, 0x04	; 4
  e0:	95 b1       	in	r25, 0x05	; 5
 }
  e2:	08 95       	ret

000000e4 <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
  e4:	98 2f       	mov	r25, r24
  e6:	84 ff       	sbrs	r24, 4
  e8:	02 c0       	rjmp	.+4      	; 0xee <lcd_SendNibble+0xa>
  ea:	94 9a       	sbi	0x12, 4	; 18
  ec:	01 c0       	rjmp	.+2      	; 0xf0 <lcd_SendNibble+0xc>
  ee:	94 98       	cbi	0x12, 4	; 18
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
  f0:	95 ff       	sbrs	r25, 5
  f2:	02 c0       	rjmp	.+4      	; 0xf8 <lcd_SendNibble+0x14>
  f4:	95 9a       	sbi	0x12, 5	; 18
  f6:	01 c0       	rjmp	.+2      	; 0xfa <lcd_SendNibble+0x16>
  f8:	95 98       	cbi	0x12, 5	; 18
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
  fa:	96 ff       	sbrs	r25, 6
  fc:	02 c0       	rjmp	.+4      	; 0x102 <lcd_SendNibble+0x1e>
  fe:	96 9a       	sbi	0x12, 6	; 18
 100:	01 c0       	rjmp	.+2      	; 0x104 <lcd_SendNibble+0x20>
 102:	96 98       	cbi	0x12, 6	; 18
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 104:	88 23       	and	r24, r24
 106:	14 f4       	brge	.+4      	; 0x10c <lcd_SendNibble+0x28>
 108:	97 9a       	sbi	0x12, 7	; 18
 10a:	08 95       	ret
 10c:	97 98       	cbi	0x12, 7	; 18
 10e:	08 95       	ret

00000110 <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
 110:	8f 98       	cbi	0x11, 7	; 17
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 112:	90 98       	cbi	0x12, 0	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
 114:	91 9a       	sbi	0x12, 1	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 116:	ee e1       	ldi	r30, 0x1E	; 30
 118:	f1 e0       	ldi	r31, 0x01	; 1
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
 11a:	92 98       	cbi	0x12, 2	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 11c:	85 e3       	ldi	r24, 0x35	; 53
 11e:	8a 95       	dec	r24
 120:	f1 f7       	brne	.-4      	; 0x11e <lcd_BusyCheck+0xe>
 122:	00 00       	nop
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
 124:	92 9a       	sbi	0x12, 2	; 18
 126:	95 e3       	ldi	r25, 0x35	; 53
 128:	9a 95       	dec	r25
 12a:	f1 f7       	brne	.-4      	; 0x128 <lcd_BusyCheck+0x18>
 12c:	00 00       	nop
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
 12e:	80 b3       	in	r24, 0x10	; 16


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 130:	90 81       	ld	r25, Z
 132:	94 30       	cpi	r25, 0x04	; 4
 134:	51 f4       	brne	.+20     	; 0x14a <lcd_BusyCheck+0x3a>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
 136:	92 98       	cbi	0x12, 2	; 18
 138:	95 e3       	ldi	r25, 0x35	; 53
 13a:	9a 95       	dec	r25
 13c:	f1 f7       	brne	.-4      	; 0x13a <lcd_BusyCheck+0x2a>
 13e:	00 00       	nop
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
 140:	92 9a       	sbi	0x12, 2	; 18
 142:	95 e3       	ldi	r25, 0x35	; 53
 144:	9a 95       	dec	r25
 146:	f1 f7       	brne	.-4      	; 0x144 <lcd_BusyCheck+0x34>
 148:	00 00       	nop
			DELAY_us(10);
		}	
	}while(busyflag);
 14a:	88 23       	and	r24, r24
 14c:	34 f3       	brlt	.-52     	; 0x11a <lcd_BusyCheck+0xa>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
 14e:	8f 9a       	sbi	0x11, 7	; 17
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
 150:	08 95       	ret

00000152 <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 152:	90 98       	cbi	0x12, 0	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 154:	91 98       	cbi	0x12, 1	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 156:	92 9a       	sbi	0x12, 2	; 18
 158:	85 e3       	ldi	r24, 0x35	; 53
 15a:	8a 95       	dec	r24
 15c:	f1 f7       	brne	.-4      	; 0x15a <lcd_SendCmdSignals+0x8>
 15e:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 160:	92 98       	cbi	0x12, 2	; 18
}
 162:	08 95       	ret

00000164 <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 164:	90 9a       	sbi	0x12, 0	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 166:	91 98       	cbi	0x12, 1	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 168:	92 9a       	sbi	0x12, 2	; 18
 16a:	85 e3       	ldi	r24, 0x35	; 53
 16c:	8a 95       	dec	r24
 16e:	f1 f7       	brne	.-4      	; 0x16c <lcd_SendDataSignals+0x8>
 170:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 172:	92 98       	cbi	0x12, 2	; 18
}
 174:	08 95       	ret

00000176 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 176:	cf 93       	push	r28
 178:	c8 2f       	mov	r28, r24
	lcd_BusyCheck();
 17a:	0e 94 88 00 	call	0x110	; 0x110 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 17e:	80 91 1e 01 	lds	r24, 0x011E
 182:	88 30       	cpi	r24, 0x08	; 8
 184:	21 f4       	brne	.+8      	; 0x18e <LCD_CmdWrite+0x18>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 186:	c2 bb       	out	0x12, r28	; 18
		lcd_SendCmdSignals();  // Signals for command write operation
 188:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_SendCmdSignals>
 18c:	0e c0       	rjmp	.+28     	; 0x1aa <LCD_CmdWrite+0x34>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 18e:	84 30       	cpi	r24, 0x04	; 4
 190:	61 f4       	brne	.+24     	; 0x1aa <LCD_CmdWrite+0x34>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 192:	8c 2f       	mov	r24, r28
 194:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 198:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 19c:	8c 2f       	mov	r24, r28
 19e:	82 95       	swap	r24
 1a0:	80 7f       	andi	r24, 0xF0	; 240
 1a2:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
		lcd_SendCmdSignals();
 1a6:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_SendCmdSignals>
	}
}
 1aa:	cf 91       	pop	r28
 1ac:	08 95       	ret

000001ae <LCD_SetCursor>:
 ***************************************************************************************************/
#if ( Enable_LCD_SetCursor    == 1 )
void LCD_SetCursor(uint8_t var_lineNumber_u8, uint8_t var_charNumber_u8)
{

	if((var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8) &&
 1ae:	90 91 1c 01 	lds	r25, 0x011C
 1b2:	98 17       	cp	r25, r24
 1b4:	80 f0       	brcs	.+32     	; 0x1d6 <LCD_SetCursor+0x28>
 1b6:	90 91 1d 01 	lds	r25, 0x011D
 1ba:	69 17       	cp	r22, r25
 1bc:	60 f4       	brcc	.+24     	; 0x1d6 <LCD_SetCursor+0x28>
			(var_charNumber_u8< STK_LCDConfig.mvar_MaxSupportedChars_U8))
	{
		/*If the line number and char are in range then
		   move the Cursor to specified Position*/
		VAR_LcdTrackCursorPos_U8 = var_charNumber_u8;
 1be:	60 93 1a 01 	sts	0x011A, r22
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 1c2:	80 93 1b 01 	sts	0x011B, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]+var_charNumber_u8);
 1c6:	e0 e0       	ldi	r30, 0x00	; 0
 1c8:	f1 e0       	ldi	r31, 0x01	; 1
 1ca:	e8 0f       	add	r30, r24
 1cc:	f1 1d       	adc	r31, r1
 1ce:	80 81       	ld	r24, Z
 1d0:	86 0f       	add	r24, r22
 1d2:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
 1d6:	08 95       	ret

000001d8 <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 1d8:	80 91 1b 01 	lds	r24, 0x011B
 1dc:	8f 5f       	subi	r24, 0xFF	; 255
 1de:	80 93 1b 01 	sts	0x011B, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 1e2:	10 92 1a 01 	sts	0x011A, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1e6:	90 91 1c 01 	lds	r25, 0x011C
 1ea:	98 17       	cp	r25, r24
 1ec:	18 f4       	brcc	.+6      	; 0x1f4 <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	80 93 1b 01 	sts	0x011B, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 1f4:	80 91 1b 01 	lds	r24, 0x011B
 1f8:	e0 e0       	ldi	r30, 0x00	; 0
 1fa:	f1 e0       	ldi	r31, 0x01	; 1
 1fc:	e8 0f       	add	r30, r24
 1fe:	f1 1d       	adc	r31, r1
 200:	80 81       	ld	r24, Z
 202:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
}
 206:	08 95       	ret

00000208 <LCD_GoToLine>:
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 208:	90 91 1c 01 	lds	r25, 0x011C
 20c:	98 17       	cp	r25, r24
 20e:	58 f0       	brcs	.+22     	; 0x226 <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 210:	10 92 1a 01 	sts	0x011A, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 214:	80 93 1b 01 	sts	0x011B, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 218:	e0 e0       	ldi	r30, 0x00	; 0
 21a:	f1 e0       	ldi	r31, 0x01	; 1
 21c:	e8 0f       	add	r30, r24
 21e:	f1 1d       	adc	r31, r1
 220:	80 81       	ld	r24, Z
 222:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
 226:	08 95       	ret

00000228 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 228:	81 e0       	ldi	r24, 0x01	; 1
 22a:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	0e 94 04 01 	call	0x208	; 0x208 <LCD_GoToLine>
}
 234:	08 95       	ret

00000236 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 236:	9f ef       	ldi	r25, 0xFF	; 255
 238:	91 bb       	out	0x11, r25	; 17
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 23a:	91 bb       	out	0x11, r25	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 23c:	80 93 1e 01 	sts	0x011E, r24
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 240:	40 93 1d 01 	sts	0x011D, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 244:	60 93 1c 01 	sts	0x011C, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 248:	63 30       	cpi	r22, 0x03	; 3
 24a:	40 f0       	brcs	.+16     	; 0x25c <LCD_Init+0x26>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 24c:	4f 70       	andi	r20, 0x0F	; 15
 24e:	84 2f       	mov	r24, r20
 250:	80 57       	subi	r24, 0x70	; 112
 252:	80 93 03 01 	sts	0x0103, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 256:	40 53       	subi	r20, 0x30	; 48
 258:	40 93 04 01 	sts	0x0104, r20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 25c:	8f ef       	ldi	r24, 0xFF	; 255
 25e:	91 ee       	ldi	r25, 0xE1	; 225
 260:	a4 e0       	ldi	r26, 0x04	; 4
 262:	81 50       	subi	r24, 0x01	; 1
 264:	90 40       	sbci	r25, 0x00	; 0
 266:	a0 40       	sbci	r26, 0x00	; 0
 268:	e1 f7       	brne	.-8      	; 0x262 <LCD_Init+0x2c>
 26a:	00 c0       	rjmp	.+0      	; 0x26c <LCD_Init+0x36>
 26c:	00 00       	nop
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 26e:	80 91 1e 01 	lds	r24, 0x011E
 272:	88 30       	cpi	r24, 0x08	; 8
 274:	21 f4       	brne	.+8      	; 0x27e <LCD_Init+0x48>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 276:	88 e3       	ldi	r24, 0x38	; 56
 278:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
 27c:	34 c0       	rjmp	.+104    	; 0x2e6 <LCD_Init+0xb0>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 27e:	84 30       	cpi	r24, 0x04	; 4
 280:	91 f5       	brne	.+100    	; 0x2e6 <LCD_Init+0xb0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 282:	80 e3       	ldi	r24, 0x30	; 48
 284:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
	lcd_SendCmdSignals();
 288:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_SendCmdSignals>
 28c:	8f ef       	ldi	r24, 0xFF	; 255
 28e:	91 ee       	ldi	r25, 0xE1	; 225
 290:	a4 e0       	ldi	r26, 0x04	; 4
 292:	81 50       	subi	r24, 0x01	; 1
 294:	90 40       	sbci	r25, 0x00	; 0
 296:	a0 40       	sbci	r26, 0x00	; 0
 298:	e1 f7       	brne	.-8      	; 0x292 <LCD_Init+0x5c>
 29a:	00 c0       	rjmp	.+0      	; 0x29c <LCD_Init+0x66>
 29c:	00 00       	nop
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 29e:	80 e3       	ldi	r24, 0x30	; 48
 2a0:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2a4:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_SendCmdSignals>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2a8:	af e1       	ldi	r26, 0x1F	; 31
 2aa:	b3 e0       	ldi	r27, 0x03	; 3
 2ac:	11 97       	sbiw	r26, 0x01	; 1
 2ae:	f1 f7       	brne	.-4      	; 0x2ac <LCD_Init+0x76>
 2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <LCD_Init+0x7c>
 2b2:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x30);
 2b4:	80 e3       	ldi	r24, 0x30	; 48
 2b6:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2ba:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_SendCmdSignals>
 2be:	8f e1       	ldi	r24, 0x1F	; 31
 2c0:	93 e0       	ldi	r25, 0x03	; 3
 2c2:	01 97       	sbiw	r24, 0x01	; 1
 2c4:	f1 f7       	brne	.-4      	; 0x2c2 <LCD_Init+0x8c>
 2c6:	00 c0       	rjmp	.+0      	; 0x2c8 <LCD_Init+0x92>
 2c8:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x20);
 2ca:	80 e2       	ldi	r24, 0x20	; 32
 2cc:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2d0:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_SendCmdSignals>
 2d4:	af e1       	ldi	r26, 0x1F	; 31
 2d6:	b3 e0       	ldi	r27, 0x03	; 3
 2d8:	11 97       	sbiw	r26, 0x01	; 1
 2da:	f1 f7       	brne	.-4      	; 0x2d8 <LCD_Init+0xa2>
 2dc:	00 c0       	rjmp	.+0      	; 0x2de <LCD_Init+0xa8>
 2de:	00 00       	nop
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 2e0:	88 e2       	ldi	r24, 0x28	; 40
 2e2:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 2e6:	8e e0       	ldi	r24, 0x0E	; 14
 2e8:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 2ec:	0e 94 14 01 	call	0x228	; 0x228 <LCD_Clear>
}
 2f0:	08 95       	ret

000002f2 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 2f2:	cf 93       	push	r28
 2f4:	c8 2f       	mov	r28, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 2f6:	90 91 1d 01 	lds	r25, 0x011D
 2fa:	80 91 1a 01 	lds	r24, 0x011A
 2fe:	89 17       	cp	r24, r25
 300:	18 f4       	brcc	.+6      	; 0x308 <LCD_DisplayChar+0x16>
 302:	ca 30       	cpi	r28, 0x0A	; 10
 304:	29 f4       	brne	.+10     	; 0x310 <LCD_DisplayChar+0x1e>
 306:	22 c0       	rjmp	.+68     	; 0x34c <LCD_DisplayChar+0x5a>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 308:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 30c:	ca 30       	cpi	r28, 0x0A	; 10
 30e:	01 f1       	breq	.+64     	; 0x350 <LCD_DisplayChar+0x5e>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 310:	0e 94 88 00 	call	0x110	; 0x110 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 314:	80 91 1e 01 	lds	r24, 0x011E
 318:	88 30       	cpi	r24, 0x08	; 8
 31a:	21 f4       	brne	.+8      	; 0x324 <LCD_DisplayChar+0x32>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 31c:	c2 bb       	out	0x12, r28	; 18
		lcd_SendDataSignals();  // Signals for data write operation
 31e:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_SendDataSignals>
 322:	0e c0       	rjmp	.+28     	; 0x340 <LCD_DisplayChar+0x4e>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 324:	84 30       	cpi	r24, 0x04	; 4
 326:	61 f4       	brne	.+24     	; 0x340 <LCD_DisplayChar+0x4e>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 328:	8c 2f       	mov	r24, r28
 32a:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 32e:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 332:	8c 2f       	mov	r24, r28
 334:	82 95       	swap	r24
 336:	80 7f       	andi	r24, 0xF0	; 240
 338:	0e 94 72 00 	call	0xe4	; 0xe4 <lcd_SendNibble>
		lcd_SendDataSignals();
 33c:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 340:	80 91 1a 01 	lds	r24, 0x011A
 344:	8f 5f       	subi	r24, 0xFF	; 255
 346:	80 93 1a 01 	sts	0x011A, r24
 34a:	02 c0       	rjmp	.+4      	; 0x350 <LCD_DisplayChar+0x5e>
{
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 34c:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <LCD_GoToNextLine>
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
	}
}
 350:	cf 91       	pop	r28
 352:	08 95       	ret

00000354 <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
 354:	cf 93       	push	r28
 356:	df 93       	push	r29
 358:	ec 01       	movw	r28, r24
	while((*ptr_stringPointer_u8)!=0)
 35a:	88 81       	ld	r24, Y
 35c:	88 23       	and	r24, r24
 35e:	31 f0       	breq	.+12     	; 0x36c <LCD_DisplayString+0x18>
                 1.The ptr_stringPointer_u8 points to the first char of the string
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
 360:	21 96       	adiw	r28, 0x01	; 1
{
	while((*ptr_stringPointer_u8)!=0)
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 362:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
	while((*ptr_stringPointer_u8)!=0)
 366:	89 91       	ld	r24, Y+
 368:	88 23       	and	r24, r24
 36a:	d9 f7       	brne	.-10     	; 0x362 <LCD_DisplayString+0xe>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
 36c:	df 91       	pop	r29
 36e:	cf 91       	pop	r28
 370:	08 95       	ret

00000372 <LCD_ScrollMessage>:
                 If the specified line number is out of range then the message
				 will be scrolled on first line
 ***************************************************************************************************/
#if ( Enable_LCD_ScrollMessage  == 1 )
void LCD_ScrollMessage(uint8_t var_lineNumber_u8, char *ptr_msgPointer_u8)
{
 372:	af 92       	push	r10
 374:	bf 92       	push	r11
 376:	cf 92       	push	r12
 378:	df 92       	push	r13
 37a:	ef 92       	push	r14
 37c:	ff 92       	push	r15
 37e:	0f 93       	push	r16
 380:	1f 93       	push	r17
 382:	cf 93       	push	r28
 384:	df 93       	push	r29
 386:	b8 2e       	mov	r11, r24
 388:	6b 01       	movw	r12, r22
	unsigned char i,j;


	if(var_lineNumber_u8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 38a:	80 91 1c 01 	lds	r24, 0x011C
 38e:	8b 15       	cp	r24, r11
 390:	10 f4       	brcc	.+4      	; 0x396 <LCD_ScrollMessage+0x24>
		var_lineNumber_u8 = mENUM_LcdLineOne; // Select first line if the var_lineNumber_u8 is out of range
 392:	bb 24       	eor	r11, r11
 394:	b3 94       	inc	r11

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);			 //Disable the Cursor
 396:	8c e0       	ldi	r24, 0x0C	; 12
 398:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>

	for(i=0;ptr_msgPointer_u8[i];i++)
 39c:	d6 01       	movw	r26, r12
 39e:	8c 91       	ld	r24, X
 3a0:	88 23       	and	r24, r24
 3a2:	d1 f1       	breq	.+116    	; 0x418 <LCD_ScrollMessage+0xa6>
 3a4:	d0 e0       	ldi	r29, 0x00	; 0
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 3a6:	0d e1       	ldi	r16, 0x1D	; 29
 3a8:	11 e0       	ldi	r17, 0x01	; 1
 3aa:	aa 24       	eor	r10, r10
	{      
		/* Loop to display the complete string,	each time 16 chars are displayed and
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line
 3ac:	8b 2d       	mov	r24, r11
 3ae:	0e 94 04 01 	call	0x208	; 0x208 <LCD_GoToLine>

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 3b2:	f8 01       	movw	r30, r16
 3b4:	80 81       	ld	r24, Z
 3b6:	88 23       	and	r24, r24
 3b8:	f9 f0       	breq	.+62     	; 0x3f8 <LCD_ScrollMessage+0x86>
 3ba:	ed 2e       	mov	r14, r29
 3bc:	ff 24       	eor	r15, r15
 3be:	f6 01       	movw	r30, r12
 3c0:	ee 0d       	add	r30, r14
 3c2:	ff 1d       	adc	r31, r15
 3c4:	80 81       	ld	r24, Z
 3c6:	88 23       	and	r24, r24
 3c8:	a9 f1       	breq	.+106    	; 0x434 <LCD_ScrollMessage+0xc2>
 3ca:	ca 2d       	mov	r28, r10
 3cc:	7f 01       	movw	r14, r30
		{
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
 3ce:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 3d2:	cf 5f       	subi	r28, 0xFF	; 255
 3d4:	d8 01       	movw	r26, r16
 3d6:	8c 91       	ld	r24, X
 3d8:	c8 17       	cp	r28, r24
 3da:	70 f4       	brcc	.+28     	; 0x3f8 <LCD_ScrollMessage+0x86>
 3dc:	f7 01       	movw	r30, r14
 3de:	ec 0f       	add	r30, r28
 3e0:	f1 1d       	adc	r31, r1
 3e2:	80 81       	ld	r24, Z
 3e4:	88 23       	and	r24, r24
 3e6:	99 f7       	brne	.-26     	; 0x3ce <LCD_ScrollMessage+0x5c>

		while( j<STK_LCDConfig.mvar_MaxSupportedChars_U8)
		{
			/*If the chars to be scrolled are less than MaxLcdChars,
			  then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
 3e8:	80 e2       	ldi	r24, 0x20	; 32
 3ea:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
			j++;
 3ee:	cf 5f       	subi	r28, 0xFF	; 255
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
		}


		while( j<STK_LCDConfig.mvar_MaxSupportedChars_U8)
 3f0:	f8 01       	movw	r30, r16
 3f2:	80 81       	ld	r24, Z
 3f4:	c8 17       	cp	r28, r24
 3f6:	c0 f3       	brcs	.-16     	; 0x3e8 <LCD_ScrollMessage+0x76>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3f8:	8f ef       	ldi	r24, 0xFF	; 255
 3fa:	93 ec       	ldi	r25, 0xC3	; 195
 3fc:	a9 e0       	ldi	r26, 0x09	; 9
 3fe:	81 50       	subi	r24, 0x01	; 1
 400:	90 40       	sbci	r25, 0x00	; 0
 402:	a0 40       	sbci	r26, 0x00	; 0
 404:	e1 f7       	brne	.-8      	; 0x3fe <LCD_ScrollMessage+0x8c>
 406:	00 c0       	rjmp	.+0      	; 0x408 <LCD_ScrollMessage+0x96>
 408:	00 00       	nop
	if(var_lineNumber_u8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
		var_lineNumber_u8 = mENUM_LcdLineOne; // Select first line if the var_lineNumber_u8 is out of range

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);			 //Disable the Cursor

	for(i=0;ptr_msgPointer_u8[i];i++)
 40a:	df 5f       	subi	r29, 0xFF	; 255
 40c:	f6 01       	movw	r30, r12
 40e:	ed 0f       	add	r30, r29
 410:	f1 1d       	adc	r31, r1
 412:	80 81       	ld	r24, Z
 414:	88 23       	and	r24, r24
 416:	51 f6       	brne	.-108    	; 0x3ac <LCD_ScrollMessage+0x3a>
			j++;
		}

		DELAY_ms(200);
	}
	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);			  // Finally enable the Cursor
 418:	8e e0       	ldi	r24, 0x0E	; 14
 41a:	0e 94 bb 00 	call	0x176	; 0x176 <LCD_CmdWrite>
}
 41e:	df 91       	pop	r29
 420:	cf 91       	pop	r28
 422:	1f 91       	pop	r17
 424:	0f 91       	pop	r16
 426:	ff 90       	pop	r15
 428:	ef 90       	pop	r14
 42a:	df 90       	pop	r13
 42c:	cf 90       	pop	r12
 42e:	bf 90       	pop	r11
 430:	af 90       	pop	r10
 432:	08 95       	ret
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
 434:	ca 2d       	mov	r28, r10
 436:	d8 cf       	rjmp	.-80     	; 0x3e8 <LCD_ScrollMessage+0x76>

00000438 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
 438:	8f 92       	push	r8
 43a:	9f 92       	push	r9
 43c:	af 92       	push	r10
 43e:	bf 92       	push	r11
 440:	ef 92       	push	r14
 442:	ff 92       	push	r15
 444:	0f 93       	push	r16
 446:	1f 93       	push	r17
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
 44c:	cd b7       	in	r28, 0x3d	; 61
 44e:	de b7       	in	r29, 0x3e	; 62
 450:	2a 97       	sbiw	r28, 0x0a	; 10
 452:	0f b6       	in	r0, 0x3f	; 63
 454:	f8 94       	cli
 456:	de bf       	out	0x3e, r29	; 62
 458:	0f be       	out	0x3f, r0	; 63
 45a:	cd bf       	out	0x3d, r28	; 61
 45c:	dc 01       	movw	r26, r24
 45e:	cb 01       	movw	r24, r22
 460:	04 2f       	mov	r16, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 462:	00 97       	sbiw	r24, 0x00	; 0
 464:	a1 05       	cpc	r26, r1
 466:	b1 05       	cpc	r27, r1
 468:	19 f0       	breq	.+6      	; 0x470 <LCD_DisplayDecimalNumber+0x38>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 46a:	44 23       	and	r20, r20
 46c:	71 f4       	brne	.+28     	; 0x48a <LCD_DisplayDecimalNumber+0x52>
 46e:	43 c0       	rjmp	.+134    	; 0x4f6 <LCD_DisplayDecimalNumber+0xbe>
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 470:	44 23       	and	r20, r20
 472:	09 f4       	brne	.+2      	; 0x476 <LCD_DisplayDecimalNumber+0x3e>
 474:	40 c0       	rjmp	.+128    	; 0x4f6 <LCD_DisplayDecimalNumber+0xbe>
 476:	fe 01       	movw	r30, r28
 478:	31 96       	adiw	r30, 0x01	; 1
 47a:	10 e0       	ldi	r17, 0x00	; 0
	    	a[i] = 0x00;
 47c:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 47e:	1f 5f       	subi	r17, 0xFF	; 255
 480:	10 17       	cp	r17, r16
 482:	81 f1       	breq	.+96     	; 0x4e4 <LCD_DisplayDecimalNumber+0xac>
 484:	1a 30       	cpi	r17, 0x0A	; 10
 486:	d1 f7       	brne	.-12     	; 0x47c <LCD_DisplayDecimalNumber+0x44>
 488:	2d c0       	rjmp	.+90     	; 0x4e4 <LCD_DisplayDecimalNumber+0xac>
 48a:	7e 01       	movw	r14, r28
 48c:	08 94       	sec
 48e:	e1 1c       	adc	r14, r1
 490:	f1 1c       	adc	r15, r1
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 492:	10 e0       	ldi	r17, 0x00	; 0
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 494:	0f 2e       	mov	r0, r31
 496:	fa e0       	ldi	r31, 0x0A	; 10
 498:	8f 2e       	mov	r8, r31
 49a:	f0 e0       	ldi	r31, 0x00	; 0
 49c:	9f 2e       	mov	r9, r31
 49e:	f0 e0       	ldi	r31, 0x00	; 0
 4a0:	af 2e       	mov	r10, r31
 4a2:	f0 e0       	ldi	r31, 0x00	; 0
 4a4:	bf 2e       	mov	r11, r31
 4a6:	f0 2d       	mov	r31, r0
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
 4a8:	00 97       	sbiw	r24, 0x00	; 0
 4aa:	a1 05       	cpc	r26, r1
 4ac:	b1 05       	cpc	r27, r1
 4ae:	69 f0       	breq	.+26     	; 0x4ca <LCD_DisplayDecimalNumber+0x92>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 4b0:	bc 01       	movw	r22, r24
 4b2:	cd 01       	movw	r24, r26
 4b4:	a5 01       	movw	r20, r10
 4b6:	94 01       	movw	r18, r8
 4b8:	0e 94 9d 04 	call	0x93a	; 0x93a <__udivmodsi4>
 4bc:	f7 01       	movw	r30, r14
 4be:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
 4c0:	82 2f       	mov	r24, r18
 4c2:	93 2f       	mov	r25, r19
 4c4:	a4 2f       	mov	r26, r20
 4c6:	b5 2f       	mov	r27, r21
 4c8:	04 c0       	rjmp	.+8      	; 0x4d2 <LCD_DisplayDecimalNumber+0x9a>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 4ca:	0b 30       	cpi	r16, 0x0B	; 11
 4cc:	48 f4       	brcc	.+18     	; 0x4e0 <LCD_DisplayDecimalNumber+0xa8>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 4ce:	f7 01       	movw	r30, r14
 4d0:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 4d2:	1f 5f       	subi	r17, 0xFF	; 255
 4d4:	08 94       	sec
 4d6:	e1 1c       	adc	r14, r1
 4d8:	f1 1c       	adc	r15, r1
 4da:	10 17       	cp	r17, r16
 4dc:	29 f7       	brne	.-54     	; 0x4a8 <LCD_DisplayDecimalNumber+0x70>
 4de:	02 c0       	rjmp	.+4      	; 0x4e4 <LCD_DisplayDecimalNumber+0xac>
			}
		}
	}


	while(i)
 4e0:	11 23       	and	r17, r17
 4e2:	49 f0       	breq	.+18     	; 0x4f6 <LCD_DisplayDecimalNumber+0xbe>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
 4e4:	fe 01       	movw	r30, r28
 4e6:	e1 0f       	add	r30, r17
 4e8:	f1 1d       	adc	r31, r1
 4ea:	80 81       	ld	r24, Z
 4ec:	80 5d       	subi	r24, 0xD0	; 208
 4ee:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
		i--;
 4f2:	11 50       	subi	r17, 0x01	; 1
			}
		}
	}


	while(i)
 4f4:	b9 f7       	brne	.-18     	; 0x4e4 <LCD_DisplayDecimalNumber+0xac>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
 4f6:	2a 96       	adiw	r28, 0x0a	; 10
 4f8:	0f b6       	in	r0, 0x3f	; 63
 4fa:	f8 94       	cli
 4fc:	de bf       	out	0x3e, r29	; 62
 4fe:	0f be       	out	0x3f, r0	; 63
 500:	cd bf       	out	0x3d, r28	; 61
 502:	df 91       	pop	r29
 504:	cf 91       	pop	r28
 506:	1f 91       	pop	r17
 508:	0f 91       	pop	r16
 50a:	ff 90       	pop	r15
 50c:	ef 90       	pop	r14
 50e:	bf 90       	pop	r11
 510:	af 90       	pop	r10
 512:	9f 90       	pop	r9
 514:	8f 90       	pop	r8
 516:	08 95       	ret

00000518 <LCD_DisplayHexNumber>:
				2.(0x12AB,6) then 6-digits ie. 0012AB will be displayed
				3.(0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ***************************************************************************************************/
#if ( Enable_LCD_DisplayHexNumber == 1 ) 
void LCD_DisplayHexNumber(uint32_t var_hexNumber_u32,uint8_t var_numOfDigitsToDisplay_u8)
{
 518:	1f 93       	push	r17
 51a:	cf 93       	push	r28
 51c:	df 93       	push	r29
 51e:	cd b7       	in	r28, 0x3d	; 61
 520:	de b7       	in	r29, 0x3e	; 62
 522:	2a 97       	sbiw	r28, 0x0a	; 10
 524:	0f b6       	in	r0, 0x3f	; 63
 526:	f8 94       	cli
 528:	de bf       	out	0x3e, r29	; 62
 52a:	0f be       	out	0x3f, r0	; 63
 52c:	cd bf       	out	0x3d, r28	; 61
 52e:	dc 01       	movw	r26, r24
 530:	cb 01       	movw	r24, r22
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
 532:	00 97       	sbiw	r24, 0x00	; 0
 534:	a1 05       	cpc	r26, r1
 536:	b1 05       	cpc	r27, r1
 538:	19 f0       	breq	.+6      	; 0x540 <LCD_DisplayHexNumber+0x28>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 53a:	44 23       	and	r20, r20
 53c:	69 f4       	brne	.+26     	; 0x558 <LCD_DisplayHexNumber+0x40>
 53e:	36 c0       	rjmp	.+108    	; 0x5ac <LCD_DisplayHexNumber+0x94>
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 540:	44 23       	and	r20, r20
 542:	a1 f1       	breq	.+104    	; 0x5ac <LCD_DisplayHexNumber+0x94>
 544:	fe 01       	movw	r30, r28
 546:	31 96       	adiw	r30, 0x01	; 1
 548:	10 e0       	ldi	r17, 0x00	; 0
		    a[i] = 0x00;
 54a:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 54c:	1f 5f       	subi	r17, 0xFF	; 255
 54e:	14 17       	cp	r17, r20
 550:	01 f1       	breq	.+64     	; 0x592 <LCD_DisplayHexNumber+0x7a>
 552:	1a 30       	cpi	r17, 0x0A	; 10
 554:	d1 f7       	brne	.-12     	; 0x54a <LCD_DisplayHexNumber+0x32>
 556:	1d c0       	rjmp	.+58     	; 0x592 <LCD_DisplayHexNumber+0x7a>
 558:	fe 01       	movw	r30, r28
 55a:	31 96       	adiw	r30, 0x01	; 1
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 55c:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_hexNumber_u32!=0)
 55e:	00 97       	sbiw	r24, 0x00	; 0
 560:	a1 05       	cpc	r26, r1
 562:	b1 05       	cpc	r27, r1
 564:	61 f0       	breq	.+24     	; 0x57e <LCD_DisplayHexNumber+0x66>
			{
				/* Extract the digits from the number till it becomes zero.
			   First get the lower nibble and shift the number 4 times.
			   if var_num_u32 = 0xABC then extracted digit will be 0x0C and number will become 0xAB.
			   The process continues till it becomes zero or max digits reached*/
				a[i]=(uint8_t)(var_hexNumber_u32 & 0x0f);
 566:	28 2f       	mov	r18, r24
 568:	2f 70       	andi	r18, 0x0F	; 15
 56a:	20 83       	st	Z, r18
				var_hexNumber_u32=var_hexNumber_u32 >> 4;
 56c:	68 94       	set
 56e:	13 f8       	bld	r1, 3
 570:	b6 95       	lsr	r27
 572:	a7 95       	ror	r26
 574:	97 95       	ror	r25
 576:	87 95       	ror	r24
 578:	16 94       	lsr	r1
 57a:	d1 f7       	brne	.-12     	; 0x570 <LCD_DisplayHexNumber+0x58>
 57c:	03 c0       	rjmp	.+6      	; 0x584 <LCD_DisplayHexNumber+0x6c>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 57e:	4b 30       	cpi	r20, 0x0B	; 11
 580:	30 f4       	brcc	.+12     	; 0x58e <LCD_DisplayHexNumber+0x76>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
                Ex: var_num_u32 is 0x123 and user wants five digits then 00123 has to be displayed */
				a[i]=0x00;
 582:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 584:	1f 5f       	subi	r17, 0xFF	; 255
 586:	31 96       	adiw	r30, 0x01	; 1
 588:	14 17       	cp	r17, r20
 58a:	49 f7       	brne	.-46     	; 0x55e <LCD_DisplayHexNumber+0x46>
 58c:	02 c0       	rjmp	.+4      	; 0x592 <LCD_DisplayHexNumber+0x7a>
				a[i]=0x00;
			}
		}
	}

	while(i!=0)
 58e:	11 23       	and	r17, r17
 590:	69 f0       	breq	.+26     	; 0x5ac <LCD_DisplayHexNumber+0x94>
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
 592:	fe 01       	movw	r30, r28
 594:	e1 0f       	add	r30, r17
 596:	f1 1d       	adc	r31, r1
 598:	80 81       	ld	r24, Z
 59a:	8a 30       	cpi	r24, 0x0A	; 10
 59c:	10 f0       	brcs	.+4      	; 0x5a2 <LCD_DisplayHexNumber+0x8a>
 59e:	89 5c       	subi	r24, 0xC9	; 201
 5a0:	01 c0       	rjmp	.+2      	; 0x5a4 <LCD_DisplayHexNumber+0x8c>
 5a2:	80 5d       	subi	r24, 0xD0	; 208
 5a4:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
		i--;
 5a8:	11 50       	subi	r17, 0x01	; 1
				a[i]=0x00;
			}
		}
	}

	while(i!=0)
 5aa:	99 f7       	brne	.-26     	; 0x592 <LCD_DisplayHexNumber+0x7a>
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
		i--;
	}
}
 5ac:	2a 96       	adiw	r28, 0x0a	; 10
 5ae:	0f b6       	in	r0, 0x3f	; 63
 5b0:	f8 94       	cli
 5b2:	de bf       	out	0x3e, r29	; 62
 5b4:	0f be       	out	0x3f, r0	; 63
 5b6:	cd bf       	out	0x3d, r28	; 61
 5b8:	df 91       	pop	r29
 5ba:	cf 91       	pop	r28
 5bc:	1f 91       	pop	r17
 5be:	08 95       	ret

000005c0 <LCD_DisplayBinaryNumber>:
				2.(10,8) then 8-LSB will be displayed ie. 00001010
				3.(10,2) then 2-LSB will be displayed ie. 10
 *************************************************************************************************/
#if (Enable_LCD_DisplayBinaryNumber == 1)
void LCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
 5c0:	bf 92       	push	r11
 5c2:	cf 92       	push	r12
 5c4:	df 92       	push	r13
 5c6:	ef 92       	push	r14
 5c8:	ff 92       	push	r15
 5ca:	0f 93       	push	r16
 5cc:	1f 93       	push	r17
 5ce:	cf 93       	push	r28
 5d0:	df 93       	push	r29
 5d2:	6b 01       	movw	r12, r22
 5d4:	7c 01       	movw	r14, r24
 5d6:	c4 2f       	mov	r28, r20
	uint8_t ch;
	  
	while(var_numOfBitsToDisplay_u8!=0)
 5d8:	44 23       	and	r20, r20
 5da:	19 f1       	breq	.+70     	; 0x622 <LCD_DisplayBinaryNumber+0x62>
	{
		/* Start Extracting the bits from the specified bit positions.
	     Get the Acsii values of the bits and display */
		ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
 5dc:	01 e0       	ldi	r16, 0x01	; 1
 5de:	10 e0       	ldi	r17, 0x00	; 0
 5e0:	d1 e0       	ldi	r29, 0x01	; 1
 5e2:	bb 24       	eor	r11, r11
 5e4:	4c 2f       	mov	r20, r28
 5e6:	50 e0       	ldi	r21, 0x00	; 0
 5e8:	41 50       	subi	r20, 0x01	; 1
 5ea:	50 40       	sbci	r21, 0x00	; 0
 5ec:	c8 01       	movw	r24, r16
 5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <LCD_DisplayBinaryNumber+0x34>
 5f0:	88 0f       	add	r24, r24
 5f2:	99 1f       	adc	r25, r25
 5f4:	4a 95       	dec	r20
 5f6:	e2 f7       	brpl	.-8      	; 0x5f0 <LCD_DisplayBinaryNumber+0x30>
 5f8:	ac 01       	movw	r20, r24
 5fa:	66 27       	eor	r22, r22
 5fc:	57 fd       	sbrc	r21, 7
 5fe:	60 95       	com	r22
 600:	76 2f       	mov	r23, r22
 602:	4c 21       	and	r20, r12
 604:	5d 21       	and	r21, r13
 606:	6e 21       	and	r22, r14
 608:	7f 21       	and	r23, r15
 60a:	8d 2f       	mov	r24, r29
 60c:	41 15       	cp	r20, r1
 60e:	51 05       	cpc	r21, r1
 610:	61 05       	cpc	r22, r1
 612:	71 05       	cpc	r23, r1
 614:	09 f4       	brne	.+2      	; 0x618 <LCD_DisplayBinaryNumber+0x58>
 616:	8b 2d       	mov	r24, r11
		LCD_DisplayChar(util_Dec2Ascii(ch));
 618:	80 5d       	subi	r24, 0xD0	; 208
 61a:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
		var_numOfBitsToDisplay_u8--;
 61e:	c1 50       	subi	r28, 0x01	; 1
#if (Enable_LCD_DisplayBinaryNumber == 1)
void LCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
	uint8_t ch;
	  
	while(var_numOfBitsToDisplay_u8!=0)
 620:	09 f7       	brne	.-62     	; 0x5e4 <LCD_DisplayBinaryNumber+0x24>
	     Get the Acsii values of the bits and display */
		ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
		LCD_DisplayChar(util_Dec2Ascii(ch));
		var_numOfBitsToDisplay_u8--;
	}
}
 622:	df 91       	pop	r29
 624:	cf 91       	pop	r28
 626:	1f 91       	pop	r17
 628:	0f 91       	pop	r16
 62a:	ff 90       	pop	r15
 62c:	ef 90       	pop	r14
 62e:	df 90       	pop	r13
 630:	cf 90       	pop	r12
 632:	bf 90       	pop	r11
 634:	08 95       	ret

00000636 <LCD_Printf>:
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 636:	5f 92       	push	r5
 638:	6f 92       	push	r6
 63a:	7f 92       	push	r7
 63c:	8f 92       	push	r8
 63e:	9f 92       	push	r9
 640:	af 92       	push	r10
 642:	bf 92       	push	r11
 644:	cf 92       	push	r12
 646:	df 92       	push	r13
 648:	ef 92       	push	r14
 64a:	ff 92       	push	r15
 64c:	0f 93       	push	r16
 64e:	1f 93       	push	r17
 650:	cf 93       	push	r28
 652:	df 93       	push	r29
 654:	cd b7       	in	r28, 0x3d	; 61
 656:	de b7       	in	r29, 0x3e	; 62
 658:	0f 2e       	mov	r0, r31
 65a:	f2 e1       	ldi	r31, 0x12	; 18
 65c:	cf 2e       	mov	r12, r31
 65e:	dd 24       	eor	r13, r13
 660:	f0 2d       	mov	r31, r0
 662:	cc 0e       	add	r12, r28
 664:	dd 1e       	adc	r13, r29
 666:	d6 01       	movw	r26, r12
 668:	ed 91       	ld	r30, X+
 66a:	fd 91       	ld	r31, X+
 66c:	6d 01       	movw	r12, r26
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 66e:	80 81       	ld	r24, Z
 670:	88 23       	and	r24, r24
 672:	09 f4       	brne	.+2      	; 0x676 <LCD_Printf+0x40>
 674:	28 c1       	rjmp	.+592    	; 0x8c6 <LCD_Printf+0x290>
 676:	8f 01       	movw	r16, r30
			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;
 678:	55 24       	eor	r5, r5
 67a:	68 94       	set
 67c:	54 f8       	bld	r5, 4
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 67e:	99 24       	eor	r9, r9
 680:	9a 94       	dec	r9
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 682:	88 24       	eor	r8, r8
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 684:	85 32       	cpi	r24, 0x25	; 37
 686:	09 f0       	breq	.+2      	; 0x68a <LCD_Printf+0x54>
 688:	11 c1       	rjmp	.+546    	; 0x8ac <LCD_Printf+0x276>
		{
		    ptr++;
 68a:	58 01       	movw	r10, r16
 68c:	08 94       	sec
 68e:	a1 1c       	adc	r10, r1
 690:	b1 1c       	adc	r11, r1
		    ch = *ptr;
 692:	f8 01       	movw	r30, r16
 694:	81 81       	ldd	r24, Z+1	; 0x01
		   if((ch>=0x30) && (ch<=0x39))
 696:	98 2f       	mov	r25, r24
 698:	90 53       	subi	r25, 0x30	; 48
 69a:	9a 30       	cpi	r25, 0x0A	; 10
 69c:	80 f4       	brcc	.+32     	; 0x6be <LCD_Printf+0x88>
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 69e:	32 96       	adiw	r30, 0x02	; 2
 6a0:	18 2d       	mov	r17, r8
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 6a2:	11 0f       	add	r17, r17
 6a4:	91 2f       	mov	r25, r17
 6a6:	99 0f       	add	r25, r25
 6a8:	99 0f       	add	r25, r25
 6aa:	19 0f       	add	r17, r25
 6ac:	80 53       	subi	r24, 0x30	; 48
 6ae:	18 0f       	add	r17, r24
				   ptr++;
 6b0:	5f 01       	movw	r10, r30
				   ch = *ptr;
 6b2:	81 91       	ld	r24, Z+
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 6b4:	98 2f       	mov	r25, r24
 6b6:	90 53       	subi	r25, 0x30	; 48
 6b8:	9a 30       	cpi	r25, 0x0A	; 10
 6ba:	98 f3       	brcs	.-26     	; 0x6a2 <LCD_Printf+0x6c>
 6bc:	01 c0       	rjmp	.+2      	; 0x6c0 <LCD_Printf+0x8a>
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 6be:	19 2d       	mov	r17, r9
			}				


			switch(ch)       /* Decode the type of the argument */
 6c0:	88 35       	cpi	r24, 0x58	; 88
 6c2:	09 f4       	brne	.+2      	; 0x6c6 <LCD_Printf+0x90>
 6c4:	a8 c0       	rjmp	.+336    	; 0x816 <LCD_Printf+0x1e0>
 6c6:	89 35       	cpi	r24, 0x59	; 89
 6c8:	c0 f4       	brcc	.+48     	; 0x6fa <LCD_Printf+0xc4>
 6ca:	84 34       	cpi	r24, 0x44	; 68
 6cc:	09 f4       	brne	.+2      	; 0x6d0 <LCD_Printf+0x9a>
 6ce:	51 c0       	rjmp	.+162    	; 0x772 <LCD_Printf+0x13c>
 6d0:	85 34       	cpi	r24, 0x45	; 69
 6d2:	48 f4       	brcc	.+18     	; 0x6e6 <LCD_Printf+0xb0>
 6d4:	82 34       	cpi	r24, 0x42	; 66
 6d6:	09 f4       	brne	.+2      	; 0x6da <LCD_Printf+0xa4>
 6d8:	c2 c0       	rjmp	.+388    	; 0x85e <LCD_Printf+0x228>
 6da:	83 34       	cpi	r24, 0x43	; 67
 6dc:	28 f5       	brcc	.+74     	; 0x728 <LCD_Printf+0xf2>
 6de:	85 32       	cpi	r24, 0x25	; 37
 6e0:	09 f0       	breq	.+2      	; 0x6e4 <LCD_Printf+0xae>
 6e2:	e7 c0       	rjmp	.+462    	; 0x8b2 <LCD_Printf+0x27c>
 6e4:	df c0       	rjmp	.+446    	; 0x8a4 <LCD_Printf+0x26e>
 6e6:	83 35       	cpi	r24, 0x53	; 83
 6e8:	09 f4       	brne	.+2      	; 0x6ec <LCD_Printf+0xb6>
 6ea:	d2 c0       	rjmp	.+420    	; 0x890 <LCD_Printf+0x25a>
 6ec:	85 35       	cpi	r24, 0x55	; 85
 6ee:	09 f4       	brne	.+2      	; 0x6f2 <LCD_Printf+0xbc>
 6f0:	71 c0       	rjmp	.+226    	; 0x7d4 <LCD_Printf+0x19e>
 6f2:	86 34       	cpi	r24, 0x46	; 70
 6f4:	09 f0       	breq	.+2      	; 0x6f8 <LCD_Printf+0xc2>
 6f6:	dd c0       	rjmp	.+442    	; 0x8b2 <LCD_Printf+0x27c>
 6f8:	c6 c0       	rjmp	.+396    	; 0x886 <LCD_Printf+0x250>
 6fa:	86 36       	cpi	r24, 0x66	; 102
 6fc:	09 f4       	brne	.+2      	; 0x700 <LCD_Printf+0xca>
 6fe:	c3 c0       	rjmp	.+390    	; 0x886 <LCD_Printf+0x250>
 700:	87 36       	cpi	r24, 0x67	; 103
 702:	40 f4       	brcc	.+16     	; 0x714 <LCD_Printf+0xde>
 704:	83 36       	cpi	r24, 0x63	; 99
 706:	81 f0       	breq	.+32     	; 0x728 <LCD_Printf+0xf2>
 708:	84 36       	cpi	r24, 0x64	; 100
 70a:	b9 f0       	breq	.+46     	; 0x73a <LCD_Printf+0x104>
 70c:	82 36       	cpi	r24, 0x62	; 98
 70e:	09 f0       	breq	.+2      	; 0x712 <LCD_Printf+0xdc>
 710:	d0 c0       	rjmp	.+416    	; 0x8b2 <LCD_Printf+0x27c>
 712:	91 c0       	rjmp	.+290    	; 0x836 <LCD_Printf+0x200>
 714:	85 37       	cpi	r24, 0x75	; 117
 716:	09 f4       	brne	.+2      	; 0x71a <LCD_Printf+0xe4>
 718:	4c c0       	rjmp	.+152    	; 0x7b2 <LCD_Printf+0x17c>
 71a:	88 37       	cpi	r24, 0x78	; 120
 71c:	09 f4       	brne	.+2      	; 0x720 <LCD_Printf+0xea>
 71e:	6a c0       	rjmp	.+212    	; 0x7f4 <LCD_Printf+0x1be>
 720:	83 37       	cpi	r24, 0x73	; 115
 722:	09 f0       	breq	.+2      	; 0x726 <LCD_Printf+0xf0>
 724:	c6 c0       	rjmp	.+396    	; 0x8b2 <LCD_Printf+0x27c>
 726:	b4 c0       	rjmp	.+360    	; 0x890 <LCD_Printf+0x25a>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 728:	86 01       	movw	r16, r12
 72a:	0e 5f       	subi	r16, 0xFE	; 254
 72c:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 72e:	d6 01       	movw	r26, r12
 730:	8c 91       	ld	r24, X
 732:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>

			switch(ch)       /* Decode the type of the argument */
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 736:	68 01       	movw	r12, r16
				LCD_DisplayChar(ch);
				break;
 738:	bc c0       	rjmp	.+376    	; 0x8b2 <LCD_Printf+0x27c>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 73a:	ee 24       	eor	r14, r14
 73c:	ff 24       	eor	r15, r15
 73e:	68 94       	set
 740:	e1 f8       	bld	r14, 1
 742:	ec 0c       	add	r14, r12
 744:	fd 1c       	adc	r15, r13
 746:	f6 01       	movw	r30, r12
 748:	c0 80       	ld	r12, Z
 74a:	d1 80       	ldd	r13, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
 74c:	dd 20       	and	r13, r13
 74e:	3c f4       	brge	.+14     	; 0x75e <LCD_Printf+0x128>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
 750:	d0 94       	com	r13
 752:	c1 94       	neg	r12
 754:	d1 08       	sbc	r13, r1
 756:	d3 94       	inc	r13
				   LCD_DisplayChar('-');
 758:	8d e2       	ldi	r24, 0x2D	; 45
 75a:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
 75e:	b6 01       	movw	r22, r12
 760:	88 27       	eor	r24, r24
 762:	77 fd       	sbrc	r23, 7
 764:	80 95       	com	r24
 766:	98 2f       	mov	r25, r24
 768:	41 2f       	mov	r20, r17
 76a:	0e 94 1c 02 	call	0x438	; 0x438 <LCD_DisplayDecimalNumber>
				ch = va_arg(argp, uint16_t);
				LCD_DisplayChar(ch);
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 76e:	67 01       	movw	r12, r14
				   var_num_s16 = -var_num_s16;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
 770:	a0 c0       	rjmp	.+320    	; 0x8b2 <LCD_Printf+0x27c>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 772:	66 24       	eor	r6, r6
 774:	77 24       	eor	r7, r7
 776:	68 94       	set
 778:	62 f8       	bld	r6, 2
 77a:	6c 0c       	add	r6, r12
 77c:	7d 1c       	adc	r7, r13
 77e:	d6 01       	movw	r26, r12
 780:	cd 90       	ld	r12, X+
 782:	dd 90       	ld	r13, X+
 784:	ed 90       	ld	r14, X+
 786:	fc 90       	ld	r15, X
 788:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
 78a:	ff 20       	and	r15, r15
 78c:	5c f4       	brge	.+22     	; 0x7a4 <LCD_Printf+0x16e>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
 78e:	f0 94       	com	r15
 790:	e0 94       	com	r14
 792:	d0 94       	com	r13
 794:	c0 94       	com	r12
 796:	c1 1c       	adc	r12, r1
 798:	d1 1c       	adc	r13, r1
 79a:	e1 1c       	adc	r14, r1
 79c:	f1 1c       	adc	r15, r1
				   LCD_DisplayChar('-');
 79e:	8d e2       	ldi	r24, 0x2D	; 45
 7a0:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
 7a4:	c7 01       	movw	r24, r14
 7a6:	b6 01       	movw	r22, r12
 7a8:	41 2f       	mov	r20, r17
 7aa:	0e 94 1c 02 	call	0x438	; 0x438 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 7ae:	63 01       	movw	r12, r6
				   var_num_s32 = -var_num_s32;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	
 7b0:	80 c0       	rjmp	.+256    	; 0x8b2 <LCD_Printf+0x27c>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 7b2:	ee 24       	eor	r14, r14
 7b4:	ff 24       	eor	r15, r15
 7b6:	68 94       	set
 7b8:	e1 f8       	bld	r14, 1
 7ba:	ec 0c       	add	r14, r12
 7bc:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 7be:	f6 01       	movw	r30, r12
 7c0:	80 81       	ld	r24, Z
 7c2:	91 81       	ldd	r25, Z+1	; 0x01
 7c4:	bc 01       	movw	r22, r24
 7c6:	80 e0       	ldi	r24, 0x00	; 0
 7c8:	90 e0       	ldi	r25, 0x00	; 0
 7ca:	41 2f       	mov	r20, r17
 7cc:	0e 94 1c 02 	call	0x438	; 0x438 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 7d0:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 7d2:	6f c0       	rjmp	.+222    	; 0x8b2 <LCD_Printf+0x27c>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 7d4:	ee 24       	eor	r14, r14
 7d6:	ff 24       	eor	r15, r15
 7d8:	68 94       	set
 7da:	e2 f8       	bld	r14, 2
 7dc:	ec 0c       	add	r14, r12
 7de:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 7e0:	d6 01       	movw	r26, r12
 7e2:	6d 91       	ld	r22, X+
 7e4:	7d 91       	ld	r23, X+
 7e6:	8d 91       	ld	r24, X+
 7e8:	9c 91       	ld	r25, X
 7ea:	41 2f       	mov	r20, r17
 7ec:	0e 94 1c 02 	call	0x438	; 0x438 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 7f0:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			
 7f2:	5f c0       	rjmp	.+190    	; 0x8b2 <LCD_Printf+0x27c>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
 7f4:	ee 24       	eor	r14, r14
 7f6:	ff 24       	eor	r15, r15
 7f8:	68 94       	set
 7fa:	e1 f8       	bld	r14, 1
 7fc:	ec 0c       	add	r14, r12
 7fe:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 800:	f6 01       	movw	r30, r12
 802:	80 81       	ld	r24, Z
 804:	91 81       	ldd	r25, Z+1	; 0x01
 806:	bc 01       	movw	r22, r24
 808:	80 e0       	ldi	r24, 0x00	; 0
 80a:	90 e0       	ldi	r25, 0x00	; 0
 80c:	41 2f       	mov	r20, r17
 80e:	0e 94 8c 02 	call	0x518	; 0x518 <LCD_DisplayHexNumber>
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
 812:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 814:	4e c0       	rjmp	.+156    	; 0x8b2 <LCD_Printf+0x27c>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
 816:	ee 24       	eor	r14, r14
 818:	ff 24       	eor	r15, r15
 81a:	68 94       	set
 81c:	e2 f8       	bld	r14, 2
 81e:	ec 0c       	add	r14, r12
 820:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 822:	d6 01       	movw	r26, r12
 824:	6d 91       	ld	r22, X+
 826:	7d 91       	ld	r23, X+
 828:	8d 91       	ld	r24, X+
 82a:	9c 91       	ld	r25, X
 82c:	41 2f       	mov	r20, r17
 82e:	0e 94 8c 02 	call	0x518	; 0x518 <LCD_DisplayHexNumber>
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
 832:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;
 834:	3e c0       	rjmp	.+124    	; 0x8b2 <LCD_Printf+0x27c>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 836:	ee 24       	eor	r14, r14
 838:	ff 24       	eor	r15, r15
 83a:	68 94       	set
 83c:	e1 f8       	bld	r14, 1
 83e:	ec 0c       	add	r14, r12
 840:	fd 1c       	adc	r15, r13
 842:	f6 01       	movw	r30, r12
 844:	80 81       	ld	r24, Z
 846:	91 81       	ldd	r25, Z+1	; 0x01
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
 848:	1f 3f       	cpi	r17, 0xFF	; 255
 84a:	09 f4       	brne	.+2      	; 0x84e <LCD_Printf+0x218>
				   var_numOfDigitsToDisp_u8 = 16;
 84c:	15 2d       	mov	r17, r5
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 84e:	bc 01       	movw	r22, r24
 850:	80 e0       	ldi	r24, 0x00	; 0
 852:	90 e0       	ldi	r25, 0x00	; 0
 854:	41 2f       	mov	r20, r17
 856:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <LCD_DisplayBinaryNumber>
#endif				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 85a:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 85c:	2a c0       	rjmp	.+84     	; 0x8b2 <LCD_Printf+0x27c>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 85e:	ee 24       	eor	r14, r14
 860:	ff 24       	eor	r15, r15
 862:	68 94       	set
 864:	e2 f8       	bld	r14, 2
 866:	ec 0c       	add	r14, r12
 868:	fd 1c       	adc	r15, r13
 86a:	d6 01       	movw	r26, r12
 86c:	6d 91       	ld	r22, X+
 86e:	7d 91       	ld	r23, X+
 870:	8d 91       	ld	r24, X+
 872:	9c 91       	ld	r25, X
 874:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
 876:	1f 3f       	cpi	r17, 0xFF	; 255
 878:	09 f4       	brne	.+2      	; 0x87c <LCD_Printf+0x246>
				   var_numOfDigitsToDisp_u8 = 16;				
 87a:	15 2d       	mov	r17, r5
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
 87c:	41 2f       	mov	r20, r17
 87e:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <LCD_DisplayBinaryNumber>
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 882:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;				
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
#endif				
				break;
 884:	16 c0       	rjmp	.+44     	; 0x8b2 <LCD_Printf+0x27c>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 886:	e4 e0       	ldi	r30, 0x04	; 4
 888:	f0 e0       	ldi	r31, 0x00	; 0
 88a:	ce 0e       	add	r12, r30
 88c:	df 1e       	adc	r13, r31
#if (Enable_LCD_DisplayFloatNumber == 1)				
				LCD_DisplayFloatNumber(var_floatNum_f32);
#endif
				break;
 88e:	11 c0       	rjmp	.+34     	; 0x8b2 <LCD_Printf+0x27c>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 890:	f6 01       	movw	r30, r12
 892:	82 e0       	ldi	r24, 0x02	; 2
 894:	90 e0       	ldi	r25, 0x00	; 0
 896:	c8 0e       	add	r12, r24
 898:	d9 1e       	adc	r13, r25
#if (Enable_LCD_DisplayString == 1)
				LCD_DisplayString(str);
 89a:	80 81       	ld	r24, Z
 89c:	91 81       	ldd	r25, Z+1	; 0x01
 89e:	0e 94 aa 01 	call	0x354	; 0x354 <LCD_DisplayString>
#endif				
				break;
 8a2:	07 c0       	rjmp	.+14     	; 0x8b2 <LCD_Printf+0x27c>

			case '%':
				LCD_DisplayChar('%');
 8a4:	85 e2       	ldi	r24, 0x25	; 37
 8a6:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
				break;
 8aa:	03 c0       	rjmp	.+6      	; 0x8b2 <LCD_Printf+0x27c>
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 8ac:	0e 94 79 01 	call	0x2f2	; 0x2f2 <LCD_DisplayChar>
 8b0:	58 01       	movw	r10, r16
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 8b2:	85 01       	movw	r16, r10
 8b4:	0f 5f       	subi	r16, 0xFF	; 255
 8b6:	1f 4f       	sbci	r17, 0xFF	; 255
 8b8:	d5 01       	movw	r26, r10
 8ba:	11 96       	adiw	r26, 0x01	; 1
 8bc:	8c 91       	ld	r24, X
 8be:	11 97       	sbiw	r26, 0x01	; 1
 8c0:	88 23       	and	r24, r24
 8c2:	09 f0       	breq	.+2      	; 0x8c6 <LCD_Printf+0x290>
 8c4:	df ce       	rjmp	.-578    	; 0x684 <LCD_Printf+0x4e>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 8c6:	df 91       	pop	r29
 8c8:	cf 91       	pop	r28
 8ca:	1f 91       	pop	r17
 8cc:	0f 91       	pop	r16
 8ce:	ff 90       	pop	r15
 8d0:	ef 90       	pop	r14
 8d2:	df 90       	pop	r13
 8d4:	cf 90       	pop	r12
 8d6:	bf 90       	pop	r11
 8d8:	af 90       	pop	r10
 8da:	9f 90       	pop	r9
 8dc:	8f 90       	pop	r8
 8de:	7f 90       	pop	r7
 8e0:	6f 90       	pop	r6
 8e2:	5f 90       	pop	r5
 8e4:	08 95       	ret

000008e6 <main>:
void main() 
{
   uint16_t adc_result;

  /* Initialize the lcd before displaying any thing on the lcd */
    LCD_Init(4,2,16);
 8e6:	84 e0       	ldi	r24, 0x04	; 4
 8e8:	62 e0       	ldi	r22, 0x02	; 2
 8ea:	40 e1       	ldi	r20, 0x10	; 16
 8ec:	0e 94 1b 01 	call	0x236	; 0x236 <LCD_Init>

  /* Initialize the adc before starting the conversion */
    ADC_Init();
 8f0:	0e 94 67 00 	call	0xce	; 0xce <ADC_Init>

  /* Display "ADC Channel zero" on first line*/
  LCD_Printf("ADC Channel zero");
 8f4:	00 d0       	rcall	.+0      	; 0x8f6 <main+0x10>
 8f6:	85 e0       	ldi	r24, 0x05	; 5
 8f8:	91 e0       	ldi	r25, 0x01	; 1
 8fa:	ed b7       	in	r30, 0x3d	; 61
 8fc:	fe b7       	in	r31, 0x3e	; 62
 8fe:	92 83       	std	Z+2, r25	; 0x02
 900:	81 83       	std	Z+1, r24	; 0x01
 902:	0e 94 1b 03 	call	0x636	; 0x636 <LCD_Printf>
 906:	0f 90       	pop	r0
 908:	0f 90       	pop	r0
	     /*Get the adc value of channel zero */
		 adc_result= ADC_GetAdcValue(0);

        /*Go to second line and display the adc value */
         LCD_GoToLine(2);
        LCD_Printf("%u",adc_result);
 90a:	06 e1       	ldi	r16, 0x16	; 22
 90c:	11 e0       	ldi	r17, 0x01	; 1

   /* Display the adc channel zero value continously */ 
   while(1)
    {
	     /*Get the adc value of channel zero */
		 adc_result= ADC_GetAdcValue(0);
 90e:	80 e0       	ldi	r24, 0x00	; 0
 910:	0e 94 6b 00 	call	0xd6	; 0xd6 <ADC_GetAdcValue>
 914:	ec 01       	movw	r28, r24

        /*Go to second line and display the adc value */
         LCD_GoToLine(2);
 916:	82 e0       	ldi	r24, 0x02	; 2
 918:	0e 94 04 01 	call	0x208	; 0x208 <LCD_GoToLine>
        LCD_Printf("%u",adc_result);
 91c:	00 d0       	rcall	.+0      	; 0x91e <main+0x38>
 91e:	00 d0       	rcall	.+0      	; 0x920 <main+0x3a>
 920:	ed b7       	in	r30, 0x3d	; 61
 922:	fe b7       	in	r31, 0x3e	; 62
 924:	12 83       	std	Z+2, r17	; 0x02
 926:	01 83       	std	Z+1, r16	; 0x01
 928:	d4 83       	std	Z+4, r29	; 0x04
 92a:	c3 83       	std	Z+3, r28	; 0x03
 92c:	0e 94 1b 03 	call	0x636	; 0x636 <LCD_Printf>
 930:	0f 90       	pop	r0
 932:	0f 90       	pop	r0
 934:	0f 90       	pop	r0
 936:	0f 90       	pop	r0
 938:	ea cf       	rjmp	.-44     	; 0x90e <main+0x28>

0000093a <__udivmodsi4>:
 93a:	a1 e2       	ldi	r26, 0x21	; 33
 93c:	1a 2e       	mov	r1, r26
 93e:	aa 1b       	sub	r26, r26
 940:	bb 1b       	sub	r27, r27
 942:	fd 01       	movw	r30, r26
 944:	0d c0       	rjmp	.+26     	; 0x960 <__udivmodsi4_ep>

00000946 <__udivmodsi4_loop>:
 946:	aa 1f       	adc	r26, r26
 948:	bb 1f       	adc	r27, r27
 94a:	ee 1f       	adc	r30, r30
 94c:	ff 1f       	adc	r31, r31
 94e:	a2 17       	cp	r26, r18
 950:	b3 07       	cpc	r27, r19
 952:	e4 07       	cpc	r30, r20
 954:	f5 07       	cpc	r31, r21
 956:	20 f0       	brcs	.+8      	; 0x960 <__udivmodsi4_ep>
 958:	a2 1b       	sub	r26, r18
 95a:	b3 0b       	sbc	r27, r19
 95c:	e4 0b       	sbc	r30, r20
 95e:	f5 0b       	sbc	r31, r21

00000960 <__udivmodsi4_ep>:
 960:	66 1f       	adc	r22, r22
 962:	77 1f       	adc	r23, r23
 964:	88 1f       	adc	r24, r24
 966:	99 1f       	adc	r25, r25
 968:	1a 94       	dec	r1
 96a:	69 f7       	brne	.-38     	; 0x946 <__udivmodsi4_loop>
 96c:	60 95       	com	r22
 96e:	70 95       	com	r23
 970:	80 95       	com	r24
 972:	90 95       	com	r25
 974:	9b 01       	movw	r18, r22
 976:	ac 01       	movw	r20, r24
 978:	bd 01       	movw	r22, r26
 97a:	cf 01       	movw	r24, r30
 97c:	08 95       	ret

0000097e <_exit>:
 97e:	f8 94       	cli

00000980 <__stop_program>:
 980:	ff cf       	rjmp	.-2      	; 0x980 <__stop_program>
