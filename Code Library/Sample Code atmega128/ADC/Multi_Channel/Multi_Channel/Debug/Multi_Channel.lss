
Multi_Channel.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  00000726  000007ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000726  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  00800120  00800120  000007da  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000007dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000100  00000000  00000000  00000f30  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000dd2  00000000  00000000  00001030  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000045e  00000000  00000000  00001e02  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000859  00000000  00000000  00002260  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001e4  00000000  00000000  00002abc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004ec  00000000  00000000  00002ca0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000903  00000000  00000000  0000318c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 e2       	ldi	r30, 0x26	; 38
  a0:	f7 e0       	ldi	r31, 0x07	; 7
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 32       	cpi	r26, 0x20	; 32
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a0 e2       	ldi	r26, 0x20	; 32
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a5 32       	cpi	r26, 0x25	; 37
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 2b 03 	call	0x656	; 0x656 <main>
  c6:	0c 94 91 03 	jmp	0x722	; 0x722 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <ADC_Init>:
 * description :This function initializes the ADC module.

***************************************************************************************************/
void ADC_Init()
 {
   ADCSRA=(1<<ADEN) | (1<<ADPS0); /* Enable ADC , sampling freq=osc_freq/2 */
  ce:	81 e8       	ldi	r24, 0x81	; 129
  d0:	86 b9       	out	0x06, r24	; 6
   ADMUX=0x00;                    /* Result right justified, select channel zero */
  d2:	17 b8       	out	0x07, r1	; 7
  }
  d4:	08 95       	ret

000000d6 <ADC_GetAdcValue>:
				 For AVR/PIC(10-bit adc) the adc value per lsb will be 5/1023=0048v
***************************************************************************************************/				 
uint16_t ADC_GetAdcValue(uint8_t var_adcChannel_u8)
 {
   
   ADMUX = var_adcChannel_u8;               /* Select the required channel */
  d6:	87 b9       	out	0x07, r24	; 7
   util_BitSet(ADCSRA,ADSC);              /* Start the ADC conversion by setting ADSC bit */
  d8:	36 9a       	sbi	0x06, 6	; 6
   
   while(util_IsBitCleared(ADCSRA,ADIF)); /* Wait till the conversion is over */
  da:	34 9b       	sbis	0x06, 4	; 6
  dc:	fe cf       	rjmp	.-4      	; 0xda <ADC_GetAdcValue+0x4>
                                          /* ADIF will be set once ADC conversion is complete */
     return(ADCW);                        /* Return the 10-bit result */
  de:	84 b1       	in	r24, 0x04	; 4
  e0:	95 b1       	in	r25, 0x05	; 5
 }
  e2:	08 95       	ret

000000e4 <DELAY_sec>:
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  e4:	00 97       	sbiw	r24, 0x00	; 0
  e6:	59 f0       	breq	.+22     	; 0xfe <DELAY_sec+0x1a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  e8:	2f ef       	ldi	r18, 0xFF	; 255
  ea:	33 ed       	ldi	r19, 0xD3	; 211
  ec:	40 e3       	ldi	r20, 0x30	; 48
  ee:	21 50       	subi	r18, 0x01	; 1
  f0:	30 40       	sbci	r19, 0x00	; 0
  f2:	40 40       	sbci	r20, 0x00	; 0
  f4:	e1 f7       	brne	.-8      	; 0xee <DELAY_sec+0xa>
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <DELAY_sec+0x14>
  f8:	00 00       	nop
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
  fa:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  fc:	a9 f7       	brne	.-22     	; 0xe8 <DELAY_sec+0x4>
  fe:	08 95       	ret

00000100 <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
 100:	98 2f       	mov	r25, r24
 102:	84 ff       	sbrs	r24, 4
 104:	02 c0       	rjmp	.+4      	; 0x10a <lcd_SendNibble+0xa>
 106:	ac 9a       	sbi	0x15, 4	; 21
 108:	01 c0       	rjmp	.+2      	; 0x10c <lcd_SendNibble+0xc>
 10a:	ac 98       	cbi	0x15, 4	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
 10c:	95 ff       	sbrs	r25, 5
 10e:	02 c0       	rjmp	.+4      	; 0x114 <lcd_SendNibble+0x14>
 110:	ad 9a       	sbi	0x15, 5	; 21
 112:	01 c0       	rjmp	.+2      	; 0x116 <lcd_SendNibble+0x16>
 114:	ad 98       	cbi	0x15, 5	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
 116:	96 ff       	sbrs	r25, 6
 118:	02 c0       	rjmp	.+4      	; 0x11e <lcd_SendNibble+0x1e>
 11a:	ae 9a       	sbi	0x15, 6	; 21
 11c:	01 c0       	rjmp	.+2      	; 0x120 <lcd_SendNibble+0x20>
 11e:	ae 98       	cbi	0x15, 6	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 120:	88 23       	and	r24, r24
 122:	14 f4       	brge	.+4      	; 0x128 <lcd_SendNibble+0x28>
 124:	af 9a       	sbi	0x15, 7	; 21
 126:	08 95       	ret
 128:	af 98       	cbi	0x15, 7	; 21
 12a:	08 95       	ret

0000012c <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
 12c:	a7 98       	cbi	0x14, 7	; 20
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 12e:	95 98       	cbi	0x12, 5	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
 130:	96 9a       	sbi	0x12, 6	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 132:	e4 e2       	ldi	r30, 0x24	; 36
 134:	f1 e0       	ldi	r31, 0x01	; 1
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
 136:	97 98       	cbi	0x12, 7	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 138:	85 e3       	ldi	r24, 0x35	; 53
 13a:	8a 95       	dec	r24
 13c:	f1 f7       	brne	.-4      	; 0x13a <lcd_BusyCheck+0xe>
 13e:	00 00       	nop
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
 140:	97 9a       	sbi	0x12, 7	; 18
 142:	95 e3       	ldi	r25, 0x35	; 53
 144:	9a 95       	dec	r25
 146:	f1 f7       	brne	.-4      	; 0x144 <lcd_BusyCheck+0x18>
 148:	00 00       	nop
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
 14a:	83 b3       	in	r24, 0x13	; 19


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 14c:	90 81       	ld	r25, Z
 14e:	94 30       	cpi	r25, 0x04	; 4
 150:	51 f4       	brne	.+20     	; 0x166 <lcd_BusyCheck+0x3a>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
 152:	97 98       	cbi	0x12, 7	; 18
 154:	95 e3       	ldi	r25, 0x35	; 53
 156:	9a 95       	dec	r25
 158:	f1 f7       	brne	.-4      	; 0x156 <lcd_BusyCheck+0x2a>
 15a:	00 00       	nop
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
 15c:	97 9a       	sbi	0x12, 7	; 18
 15e:	95 e3       	ldi	r25, 0x35	; 53
 160:	9a 95       	dec	r25
 162:	f1 f7       	brne	.-4      	; 0x160 <lcd_BusyCheck+0x34>
 164:	00 00       	nop
			DELAY_us(10);
		}	
	}while(busyflag);
 166:	88 23       	and	r24, r24
 168:	34 f3       	brlt	.-52     	; 0x136 <lcd_BusyCheck+0xa>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
 16a:	a7 9a       	sbi	0x14, 7	; 20
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
 16c:	08 95       	ret

0000016e <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 16e:	95 98       	cbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 170:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 172:	97 9a       	sbi	0x12, 7	; 18
 174:	85 e3       	ldi	r24, 0x35	; 53
 176:	8a 95       	dec	r24
 178:	f1 f7       	brne	.-4      	; 0x176 <lcd_SendCmdSignals+0x8>
 17a:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 17c:	97 98       	cbi	0x12, 7	; 18
}
 17e:	08 95       	ret

00000180 <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 180:	95 9a       	sbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 182:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 184:	97 9a       	sbi	0x12, 7	; 18
 186:	85 e3       	ldi	r24, 0x35	; 53
 188:	8a 95       	dec	r24
 18a:	f1 f7       	brne	.-4      	; 0x188 <lcd_SendDataSignals+0x8>
 18c:	00 00       	nop
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 18e:	97 98       	cbi	0x12, 7	; 18
}
 190:	08 95       	ret

00000192 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 192:	cf 93       	push	r28
 194:	c8 2f       	mov	r28, r24
	lcd_BusyCheck();
 196:	0e 94 96 00 	call	0x12c	; 0x12c <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 19a:	80 91 24 01 	lds	r24, 0x0124
 19e:	88 30       	cpi	r24, 0x08	; 8
 1a0:	21 f4       	brne	.+8      	; 0x1aa <LCD_CmdWrite+0x18>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 1a2:	c5 bb       	out	0x15, r28	; 21
		lcd_SendCmdSignals();  // Signals for command write operation
 1a4:	0e 94 b7 00 	call	0x16e	; 0x16e <lcd_SendCmdSignals>
 1a8:	0e c0       	rjmp	.+28     	; 0x1c6 <LCD_CmdWrite+0x34>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 1aa:	84 30       	cpi	r24, 0x04	; 4
 1ac:	61 f4       	brne	.+24     	; 0x1c6 <LCD_CmdWrite+0x34>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 1ae:	8c 2f       	mov	r24, r28
 1b0:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 1b4:	0e 94 b7 00 	call	0x16e	; 0x16e <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 1b8:	8c 2f       	mov	r24, r28
 1ba:	82 95       	swap	r24
 1bc:	80 7f       	andi	r24, 0xF0	; 240
 1be:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
		lcd_SendCmdSignals();
 1c2:	0e 94 b7 00 	call	0x16e	; 0x16e <lcd_SendCmdSignals>
	}
}
 1c6:	cf 91       	pop	r28
 1c8:	08 95       	ret

000001ca <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 1ca:	80 91 21 01 	lds	r24, 0x0121
 1ce:	8f 5f       	subi	r24, 0xFF	; 255
 1d0:	80 93 21 01 	sts	0x0121, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 1d4:	10 92 20 01 	sts	0x0120, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1d8:	90 91 22 01 	lds	r25, 0x0122
 1dc:	98 17       	cp	r25, r24
 1de:	18 f4       	brcc	.+6      	; 0x1e6 <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 1e0:	81 e0       	ldi	r24, 0x01	; 1
 1e2:	80 93 21 01 	sts	0x0121, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 1e6:	80 91 21 01 	lds	r24, 0x0121
 1ea:	e0 e0       	ldi	r30, 0x00	; 0
 1ec:	f1 e0       	ldi	r31, 0x01	; 1
 1ee:	e8 0f       	add	r30, r24
 1f0:	f1 1d       	adc	r31, r1
 1f2:	80 81       	ld	r24, Z
 1f4:	0e 94 c9 00 	call	0x192	; 0x192 <LCD_CmdWrite>
}
 1f8:	08 95       	ret

000001fa <LCD_GoToLine>:
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1fa:	90 91 22 01 	lds	r25, 0x0122
 1fe:	98 17       	cp	r25, r24
 200:	58 f0       	brcs	.+22     	; 0x218 <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 202:	10 92 20 01 	sts	0x0120, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 206:	80 93 21 01 	sts	0x0121, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 20a:	e0 e0       	ldi	r30, 0x00	; 0
 20c:	f1 e0       	ldi	r31, 0x01	; 1
 20e:	e8 0f       	add	r30, r24
 210:	f1 1d       	adc	r31, r1
 212:	80 81       	ld	r24, Z
 214:	0e 94 c9 00 	call	0x192	; 0x192 <LCD_CmdWrite>
 218:	08 95       	ret

0000021a <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 21a:	81 e0       	ldi	r24, 0x01	; 1
 21c:	0e 94 c9 00 	call	0x192	; 0x192 <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 220:	81 e0       	ldi	r24, 0x01	; 1
 222:	0e 94 fd 00 	call	0x1fa	; 0x1fa <LCD_GoToLine>
}
 226:	08 95       	ret

00000228 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 228:	9f ef       	ldi	r25, 0xFF	; 255
 22a:	94 bb       	out	0x14, r25	; 20
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 22c:	91 bb       	out	0x11, r25	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 22e:	80 93 24 01 	sts	0x0124, r24
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 232:	40 93 23 01 	sts	0x0123, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 236:	60 93 22 01 	sts	0x0122, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 23a:	63 30       	cpi	r22, 0x03	; 3
 23c:	40 f0       	brcs	.+16     	; 0x24e <LCD_Init+0x26>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 23e:	4f 70       	andi	r20, 0x0F	; 15
 240:	84 2f       	mov	r24, r20
 242:	80 57       	subi	r24, 0x70	; 112
 244:	80 93 03 01 	sts	0x0103, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 248:	40 53       	subi	r20, 0x30	; 48
 24a:	40 93 04 01 	sts	0x0104, r20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 24e:	8f ef       	ldi	r24, 0xFF	; 255
 250:	91 ee       	ldi	r25, 0xE1	; 225
 252:	a4 e0       	ldi	r26, 0x04	; 4
 254:	81 50       	subi	r24, 0x01	; 1
 256:	90 40       	sbci	r25, 0x00	; 0
 258:	a0 40       	sbci	r26, 0x00	; 0
 25a:	e1 f7       	brne	.-8      	; 0x254 <LCD_Init+0x2c>
 25c:	00 c0       	rjmp	.+0      	; 0x25e <LCD_Init+0x36>
 25e:	00 00       	nop
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 260:	80 91 24 01 	lds	r24, 0x0124
 264:	88 30       	cpi	r24, 0x08	; 8
 266:	21 f4       	brne	.+8      	; 0x270 <LCD_Init+0x48>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 268:	88 e3       	ldi	r24, 0x38	; 56
 26a:	0e 94 c9 00 	call	0x192	; 0x192 <LCD_CmdWrite>
 26e:	34 c0       	rjmp	.+104    	; 0x2d8 <LCD_Init+0xb0>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 270:	84 30       	cpi	r24, 0x04	; 4
 272:	91 f5       	brne	.+100    	; 0x2d8 <LCD_Init+0xb0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 274:	80 e3       	ldi	r24, 0x30	; 48
 276:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
	lcd_SendCmdSignals();
 27a:	0e 94 b7 00 	call	0x16e	; 0x16e <lcd_SendCmdSignals>
 27e:	8f ef       	ldi	r24, 0xFF	; 255
 280:	91 ee       	ldi	r25, 0xE1	; 225
 282:	a4 e0       	ldi	r26, 0x04	; 4
 284:	81 50       	subi	r24, 0x01	; 1
 286:	90 40       	sbci	r25, 0x00	; 0
 288:	a0 40       	sbci	r26, 0x00	; 0
 28a:	e1 f7       	brne	.-8      	; 0x284 <LCD_Init+0x5c>
 28c:	00 c0       	rjmp	.+0      	; 0x28e <LCD_Init+0x66>
 28e:	00 00       	nop
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 290:	80 e3       	ldi	r24, 0x30	; 48
 292:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
	lcd_SendCmdSignals();
 296:	0e 94 b7 00 	call	0x16e	; 0x16e <lcd_SendCmdSignals>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 29a:	af e1       	ldi	r26, 0x1F	; 31
 29c:	b3 e0       	ldi	r27, 0x03	; 3
 29e:	11 97       	sbiw	r26, 0x01	; 1
 2a0:	f1 f7       	brne	.-4      	; 0x29e <LCD_Init+0x76>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <LCD_Init+0x7c>
 2a4:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x30);
 2a6:	80 e3       	ldi	r24, 0x30	; 48
 2a8:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2ac:	0e 94 b7 00 	call	0x16e	; 0x16e <lcd_SendCmdSignals>
 2b0:	8f e1       	ldi	r24, 0x1F	; 31
 2b2:	93 e0       	ldi	r25, 0x03	; 3
 2b4:	01 97       	sbiw	r24, 0x01	; 1
 2b6:	f1 f7       	brne	.-4      	; 0x2b4 <LCD_Init+0x8c>
 2b8:	00 c0       	rjmp	.+0      	; 0x2ba <LCD_Init+0x92>
 2ba:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x20);
 2bc:	80 e2       	ldi	r24, 0x20	; 32
 2be:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
	lcd_SendCmdSignals();
 2c2:	0e 94 b7 00 	call	0x16e	; 0x16e <lcd_SendCmdSignals>
 2c6:	af e1       	ldi	r26, 0x1F	; 31
 2c8:	b3 e0       	ldi	r27, 0x03	; 3
 2ca:	11 97       	sbiw	r26, 0x01	; 1
 2cc:	f1 f7       	brne	.-4      	; 0x2ca <LCD_Init+0xa2>
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <LCD_Init+0xa8>
 2d0:	00 00       	nop
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 2d2:	88 e2       	ldi	r24, 0x28	; 40
 2d4:	0e 94 c9 00 	call	0x192	; 0x192 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 2d8:	8e e0       	ldi	r24, 0x0E	; 14
 2da:	0e 94 c9 00 	call	0x192	; 0x192 <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 2de:	0e 94 0d 01 	call	0x21a	; 0x21a <LCD_Clear>
}
 2e2:	08 95       	ret

000002e4 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 2e4:	cf 93       	push	r28
 2e6:	c8 2f       	mov	r28, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 2e8:	90 91 23 01 	lds	r25, 0x0123
 2ec:	80 91 20 01 	lds	r24, 0x0120
 2f0:	89 17       	cp	r24, r25
 2f2:	18 f4       	brcc	.+6      	; 0x2fa <LCD_DisplayChar+0x16>
 2f4:	ca 30       	cpi	r28, 0x0A	; 10
 2f6:	29 f4       	brne	.+10     	; 0x302 <LCD_DisplayChar+0x1e>
 2f8:	22 c0       	rjmp	.+68     	; 0x33e <LCD_DisplayChar+0x5a>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 2fa:	0e 94 e5 00 	call	0x1ca	; 0x1ca <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 2fe:	ca 30       	cpi	r28, 0x0A	; 10
 300:	01 f1       	breq	.+64     	; 0x342 <LCD_DisplayChar+0x5e>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 302:	0e 94 96 00 	call	0x12c	; 0x12c <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 306:	80 91 24 01 	lds	r24, 0x0124
 30a:	88 30       	cpi	r24, 0x08	; 8
 30c:	21 f4       	brne	.+8      	; 0x316 <LCD_DisplayChar+0x32>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 30e:	c5 bb       	out	0x15, r28	; 21
		lcd_SendDataSignals();  // Signals for data write operation
 310:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendDataSignals>
 314:	0e c0       	rjmp	.+28     	; 0x332 <LCD_DisplayChar+0x4e>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 316:	84 30       	cpi	r24, 0x04	; 4
 318:	61 f4       	brne	.+24     	; 0x332 <LCD_DisplayChar+0x4e>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 31a:	8c 2f       	mov	r24, r28
 31c:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 320:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 324:	8c 2f       	mov	r24, r28
 326:	82 95       	swap	r24
 328:	80 7f       	andi	r24, 0xF0	; 240
 32a:	0e 94 80 00 	call	0x100	; 0x100 <lcd_SendNibble>
		lcd_SendDataSignals();
 32e:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 332:	80 91 20 01 	lds	r24, 0x0120
 336:	8f 5f       	subi	r24, 0xFF	; 255
 338:	80 93 20 01 	sts	0x0120, r24
 33c:	02 c0       	rjmp	.+4      	; 0x342 <LCD_DisplayChar+0x5e>
{
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 33e:	0e 94 e5 00 	call	0x1ca	; 0x1ca <LCD_GoToNextLine>
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
	}
}
 342:	cf 91       	pop	r28
 344:	08 95       	ret

00000346 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
 346:	8f 92       	push	r8
 348:	9f 92       	push	r9
 34a:	af 92       	push	r10
 34c:	bf 92       	push	r11
 34e:	ef 92       	push	r14
 350:	ff 92       	push	r15
 352:	0f 93       	push	r16
 354:	1f 93       	push	r17
 356:	cf 93       	push	r28
 358:	df 93       	push	r29
 35a:	cd b7       	in	r28, 0x3d	; 61
 35c:	de b7       	in	r29, 0x3e	; 62
 35e:	2a 97       	sbiw	r28, 0x0a	; 10
 360:	0f b6       	in	r0, 0x3f	; 63
 362:	f8 94       	cli
 364:	de bf       	out	0x3e, r29	; 62
 366:	0f be       	out	0x3f, r0	; 63
 368:	cd bf       	out	0x3d, r28	; 61
 36a:	dc 01       	movw	r26, r24
 36c:	cb 01       	movw	r24, r22
 36e:	04 2f       	mov	r16, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 370:	00 97       	sbiw	r24, 0x00	; 0
 372:	a1 05       	cpc	r26, r1
 374:	b1 05       	cpc	r27, r1
 376:	19 f0       	breq	.+6      	; 0x37e <LCD_DisplayDecimalNumber+0x38>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 378:	44 23       	and	r20, r20
 37a:	71 f4       	brne	.+28     	; 0x398 <LCD_DisplayDecimalNumber+0x52>
 37c:	43 c0       	rjmp	.+134    	; 0x404 <LCD_DisplayDecimalNumber+0xbe>
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 37e:	44 23       	and	r20, r20
 380:	09 f4       	brne	.+2      	; 0x384 <LCD_DisplayDecimalNumber+0x3e>
 382:	40 c0       	rjmp	.+128    	; 0x404 <LCD_DisplayDecimalNumber+0xbe>
 384:	fe 01       	movw	r30, r28
 386:	31 96       	adiw	r30, 0x01	; 1
 388:	10 e0       	ldi	r17, 0x00	; 0
	    	a[i] = 0x00;
 38a:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 38c:	1f 5f       	subi	r17, 0xFF	; 255
 38e:	10 17       	cp	r17, r16
 390:	81 f1       	breq	.+96     	; 0x3f2 <LCD_DisplayDecimalNumber+0xac>
 392:	1a 30       	cpi	r17, 0x0A	; 10
 394:	d1 f7       	brne	.-12     	; 0x38a <LCD_DisplayDecimalNumber+0x44>
 396:	2d c0       	rjmp	.+90     	; 0x3f2 <LCD_DisplayDecimalNumber+0xac>
 398:	7e 01       	movw	r14, r28
 39a:	08 94       	sec
 39c:	e1 1c       	adc	r14, r1
 39e:	f1 1c       	adc	r15, r1
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 3a0:	10 e0       	ldi	r17, 0x00	; 0
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 3a2:	0f 2e       	mov	r0, r31
 3a4:	fa e0       	ldi	r31, 0x0A	; 10
 3a6:	8f 2e       	mov	r8, r31
 3a8:	f0 e0       	ldi	r31, 0x00	; 0
 3aa:	9f 2e       	mov	r9, r31
 3ac:	f0 e0       	ldi	r31, 0x00	; 0
 3ae:	af 2e       	mov	r10, r31
 3b0:	f0 e0       	ldi	r31, 0x00	; 0
 3b2:	bf 2e       	mov	r11, r31
 3b4:	f0 2d       	mov	r31, r0
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
 3b6:	00 97       	sbiw	r24, 0x00	; 0
 3b8:	a1 05       	cpc	r26, r1
 3ba:	b1 05       	cpc	r27, r1
 3bc:	69 f0       	breq	.+26     	; 0x3d8 <LCD_DisplayDecimalNumber+0x92>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 3be:	bc 01       	movw	r22, r24
 3c0:	cd 01       	movw	r24, r26
 3c2:	a5 01       	movw	r20, r10
 3c4:	94 01       	movw	r18, r8
 3c6:	0e 94 6f 03 	call	0x6de	; 0x6de <__udivmodsi4>
 3ca:	f7 01       	movw	r30, r14
 3cc:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
 3ce:	82 2f       	mov	r24, r18
 3d0:	93 2f       	mov	r25, r19
 3d2:	a4 2f       	mov	r26, r20
 3d4:	b5 2f       	mov	r27, r21
 3d6:	04 c0       	rjmp	.+8      	; 0x3e0 <LCD_DisplayDecimalNumber+0x9a>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 3d8:	0b 30       	cpi	r16, 0x0B	; 11
 3da:	48 f4       	brcc	.+18     	; 0x3ee <LCD_DisplayDecimalNumber+0xa8>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 3dc:	f7 01       	movw	r30, r14
 3de:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 3e0:	1f 5f       	subi	r17, 0xFF	; 255
 3e2:	08 94       	sec
 3e4:	e1 1c       	adc	r14, r1
 3e6:	f1 1c       	adc	r15, r1
 3e8:	10 17       	cp	r17, r16
 3ea:	29 f7       	brne	.-54     	; 0x3b6 <LCD_DisplayDecimalNumber+0x70>
 3ec:	02 c0       	rjmp	.+4      	; 0x3f2 <LCD_DisplayDecimalNumber+0xac>
			}
		}
	}


	while(i)
 3ee:	11 23       	and	r17, r17
 3f0:	49 f0       	breq	.+18     	; 0x404 <LCD_DisplayDecimalNumber+0xbe>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
 3f2:	fe 01       	movw	r30, r28
 3f4:	e1 0f       	add	r30, r17
 3f6:	f1 1d       	adc	r31, r1
 3f8:	80 81       	ld	r24, Z
 3fa:	80 5d       	subi	r24, 0xD0	; 208
 3fc:	0e 94 72 01 	call	0x2e4	; 0x2e4 <LCD_DisplayChar>
		i--;
 400:	11 50       	subi	r17, 0x01	; 1
			}
		}
	}


	while(i)
 402:	b9 f7       	brne	.-18     	; 0x3f2 <LCD_DisplayDecimalNumber+0xac>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
 404:	2a 96       	adiw	r28, 0x0a	; 10
 406:	0f b6       	in	r0, 0x3f	; 63
 408:	f8 94       	cli
 40a:	de bf       	out	0x3e, r29	; 62
 40c:	0f be       	out	0x3f, r0	; 63
 40e:	cd bf       	out	0x3d, r28	; 61
 410:	df 91       	pop	r29
 412:	cf 91       	pop	r28
 414:	1f 91       	pop	r17
 416:	0f 91       	pop	r16
 418:	ff 90       	pop	r15
 41a:	ef 90       	pop	r14
 41c:	bf 90       	pop	r11
 41e:	af 90       	pop	r10
 420:	9f 90       	pop	r9
 422:	8f 90       	pop	r8
 424:	08 95       	ret

00000426 <LCD_Printf>:
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 426:	6f 92       	push	r6
 428:	7f 92       	push	r7
 42a:	8f 92       	push	r8
 42c:	9f 92       	push	r9
 42e:	af 92       	push	r10
 430:	bf 92       	push	r11
 432:	cf 92       	push	r12
 434:	df 92       	push	r13
 436:	ef 92       	push	r14
 438:	ff 92       	push	r15
 43a:	0f 93       	push	r16
 43c:	1f 93       	push	r17
 43e:	cf 93       	push	r28
 440:	df 93       	push	r29
 442:	cd b7       	in	r28, 0x3d	; 61
 444:	de b7       	in	r29, 0x3e	; 62
 446:	0f 2e       	mov	r0, r31
 448:	f1 e1       	ldi	r31, 0x11	; 17
 44a:	ef 2e       	mov	r14, r31
 44c:	ff 24       	eor	r15, r15
 44e:	f0 2d       	mov	r31, r0
 450:	ec 0e       	add	r14, r28
 452:	fd 1e       	adc	r15, r29
 454:	d7 01       	movw	r26, r14
 456:	ed 91       	ld	r30, X+
 458:	fd 91       	ld	r31, X+
 45a:	7d 01       	movw	r14, r26
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 45c:	80 81       	ld	r24, Z
 45e:	88 23       	and	r24, r24
 460:	09 f4       	brne	.+2      	; 0x464 <LCD_Printf+0x3e>
 462:	ea c0       	rjmp	.+468    	; 0x638 <LCD_Printf+0x212>
 464:	6f 01       	movw	r12, r30
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 466:	99 24       	eor	r9, r9
 468:	9a 94       	dec	r9
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 46a:	88 24       	eor	r8, r8
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 46c:	85 32       	cpi	r24, 0x25	; 37
 46e:	09 f0       	breq	.+2      	; 0x472 <LCD_Printf+0x4c>
 470:	d7 c0       	rjmp	.+430    	; 0x620 <LCD_Printf+0x1fa>
		{
		    ptr++;
 472:	56 01       	movw	r10, r12
 474:	08 94       	sec
 476:	a1 1c       	adc	r10, r1
 478:	b1 1c       	adc	r11, r1
		    ch = *ptr;
 47a:	f6 01       	movw	r30, r12
 47c:	81 81       	ldd	r24, Z+1	; 0x01
		   if((ch>=0x30) && (ch<=0x39))
 47e:	98 2f       	mov	r25, r24
 480:	90 53       	subi	r25, 0x30	; 48
 482:	9a 30       	cpi	r25, 0x0A	; 10
 484:	80 f4       	brcc	.+32     	; 0x4a6 <LCD_Printf+0x80>
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
		LCD_Printf("num1:%u",(uint16_t)var_Num_u8); 		 
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
 486:	32 96       	adiw	r30, 0x02	; 2
 488:	08 2d       	mov	r16, r8
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 48a:	00 0f       	add	r16, r16
 48c:	90 2f       	mov	r25, r16
 48e:	99 0f       	add	r25, r25
 490:	99 0f       	add	r25, r25
 492:	09 0f       	add	r16, r25
 494:	80 53       	subi	r24, 0x30	; 48
 496:	08 0f       	add	r16, r24
				   ptr++;
 498:	5f 01       	movw	r10, r30
				   ch = *ptr;
 49a:	81 91       	ld	r24, Z+
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 49c:	98 2f       	mov	r25, r24
 49e:	90 53       	subi	r25, 0x30	; 48
 4a0:	9a 30       	cpi	r25, 0x0A	; 10
 4a2:	98 f3       	brcs	.-26     	; 0x48a <LCD_Printf+0x64>
 4a4:	01 c0       	rjmp	.+2      	; 0x4a8 <LCD_Printf+0x82>
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 4a6:	09 2d       	mov	r16, r9
			}				


			switch(ch)       /* Decode the type of the argument */
 4a8:	88 35       	cpi	r24, 0x58	; 88
 4aa:	09 f4       	brne	.+2      	; 0x4ae <LCD_Printf+0x88>
 4ac:	9c c0       	rjmp	.+312    	; 0x5e6 <LCD_Printf+0x1c0>
 4ae:	89 35       	cpi	r24, 0x59	; 89
 4b0:	c0 f4       	brcc	.+48     	; 0x4e2 <LCD_Printf+0xbc>
 4b2:	84 34       	cpi	r24, 0x44	; 68
 4b4:	09 f4       	brne	.+2      	; 0x4b8 <LCD_Printf+0x92>
 4b6:	51 c0       	rjmp	.+162    	; 0x55a <LCD_Printf+0x134>
 4b8:	85 34       	cpi	r24, 0x45	; 69
 4ba:	48 f4       	brcc	.+18     	; 0x4ce <LCD_Printf+0xa8>
 4bc:	82 34       	cpi	r24, 0x42	; 66
 4be:	09 f4       	brne	.+2      	; 0x4c2 <LCD_Printf+0x9c>
 4c0:	9c c0       	rjmp	.+312    	; 0x5fa <LCD_Printf+0x1d4>
 4c2:	83 34       	cpi	r24, 0x43	; 67
 4c4:	28 f5       	brcc	.+74     	; 0x510 <LCD_Printf+0xea>
 4c6:	85 32       	cpi	r24, 0x25	; 37
 4c8:	09 f0       	breq	.+2      	; 0x4cc <LCD_Printf+0xa6>
 4ca:	ad c0       	rjmp	.+346    	; 0x626 <LCD_Printf+0x200>
 4cc:	a5 c0       	rjmp	.+330    	; 0x618 <LCD_Printf+0x1f2>
 4ce:	83 35       	cpi	r24, 0x53	; 83
 4d0:	09 f4       	brne	.+2      	; 0x4d4 <LCD_Printf+0xae>
 4d2:	9d c0       	rjmp	.+314    	; 0x60e <LCD_Printf+0x1e8>
 4d4:	85 35       	cpi	r24, 0x55	; 85
 4d6:	09 f4       	brne	.+2      	; 0x4da <LCD_Printf+0xb4>
 4d8:	71 c0       	rjmp	.+226    	; 0x5bc <LCD_Printf+0x196>
 4da:	86 34       	cpi	r24, 0x46	; 70
 4dc:	09 f0       	breq	.+2      	; 0x4e0 <LCD_Printf+0xba>
 4de:	a3 c0       	rjmp	.+326    	; 0x626 <LCD_Printf+0x200>
 4e0:	91 c0       	rjmp	.+290    	; 0x604 <LCD_Printf+0x1de>
 4e2:	86 36       	cpi	r24, 0x66	; 102
 4e4:	09 f4       	brne	.+2      	; 0x4e8 <LCD_Printf+0xc2>
 4e6:	8e c0       	rjmp	.+284    	; 0x604 <LCD_Printf+0x1de>
 4e8:	87 36       	cpi	r24, 0x67	; 103
 4ea:	40 f4       	brcc	.+16     	; 0x4fc <LCD_Printf+0xd6>
 4ec:	83 36       	cpi	r24, 0x63	; 99
 4ee:	81 f0       	breq	.+32     	; 0x510 <LCD_Printf+0xea>
 4f0:	84 36       	cpi	r24, 0x64	; 100
 4f2:	b9 f0       	breq	.+46     	; 0x522 <LCD_Printf+0xfc>
 4f4:	82 36       	cpi	r24, 0x62	; 98
 4f6:	09 f0       	breq	.+2      	; 0x4fa <LCD_Printf+0xd4>
 4f8:	96 c0       	rjmp	.+300    	; 0x626 <LCD_Printf+0x200>
 4fa:	7a c0       	rjmp	.+244    	; 0x5f0 <LCD_Printf+0x1ca>
 4fc:	85 37       	cpi	r24, 0x75	; 117
 4fe:	09 f4       	brne	.+2      	; 0x502 <LCD_Printf+0xdc>
 500:	4c c0       	rjmp	.+152    	; 0x59a <LCD_Printf+0x174>
 502:	88 37       	cpi	r24, 0x78	; 120
 504:	09 f4       	brne	.+2      	; 0x508 <LCD_Printf+0xe2>
 506:	6a c0       	rjmp	.+212    	; 0x5dc <LCD_Printf+0x1b6>
 508:	83 37       	cpi	r24, 0x73	; 115
 50a:	09 f0       	breq	.+2      	; 0x50e <LCD_Printf+0xe8>
 50c:	8c c0       	rjmp	.+280    	; 0x626 <LCD_Printf+0x200>
 50e:	7f c0       	rjmp	.+254    	; 0x60e <LCD_Printf+0x1e8>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 510:	87 01       	movw	r16, r14
 512:	0e 5f       	subi	r16, 0xFE	; 254
 514:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 516:	d7 01       	movw	r26, r14
 518:	8c 91       	ld	r24, X
 51a:	0e 94 72 01 	call	0x2e4	; 0x2e4 <LCD_DisplayChar>

			switch(ch)       /* Decode the type of the argument */
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 51e:	78 01       	movw	r14, r16
				LCD_DisplayChar(ch);
				break;
 520:	82 c0       	rjmp	.+260    	; 0x626 <LCD_Printf+0x200>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 522:	66 24       	eor	r6, r6
 524:	77 24       	eor	r7, r7
 526:	68 94       	set
 528:	61 f8       	bld	r6, 1
 52a:	6e 0c       	add	r6, r14
 52c:	7f 1c       	adc	r7, r15
 52e:	f7 01       	movw	r30, r14
 530:	c0 80       	ld	r12, Z
 532:	d1 80       	ldd	r13, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
 534:	dd 20       	and	r13, r13
 536:	3c f4       	brge	.+14     	; 0x546 <LCD_Printf+0x120>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
 538:	d0 94       	com	r13
 53a:	c1 94       	neg	r12
 53c:	d1 08       	sbc	r13, r1
 53e:	d3 94       	inc	r13
				   LCD_DisplayChar('-');
 540:	8d e2       	ldi	r24, 0x2D	; 45
 542:	0e 94 72 01 	call	0x2e4	; 0x2e4 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
 546:	b6 01       	movw	r22, r12
 548:	88 27       	eor	r24, r24
 54a:	77 fd       	sbrc	r23, 7
 54c:	80 95       	com	r24
 54e:	98 2f       	mov	r25, r24
 550:	40 2f       	mov	r20, r16
 552:	0e 94 a3 01 	call	0x346	; 0x346 <LCD_DisplayDecimalNumber>
				ch = va_arg(argp, uint16_t);
				LCD_DisplayChar(ch);
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 556:	73 01       	movw	r14, r6
				   var_num_s16 = -var_num_s16;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
 558:	66 c0       	rjmp	.+204    	; 0x626 <LCD_Printf+0x200>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 55a:	66 24       	eor	r6, r6
 55c:	77 24       	eor	r7, r7
 55e:	68 94       	set
 560:	62 f8       	bld	r6, 2
 562:	6e 0c       	add	r6, r14
 564:	7f 1c       	adc	r7, r15
 566:	d7 01       	movw	r26, r14
 568:	cd 90       	ld	r12, X+
 56a:	dd 90       	ld	r13, X+
 56c:	ed 90       	ld	r14, X+
 56e:	fc 90       	ld	r15, X
 570:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
 572:	ff 20       	and	r15, r15
 574:	5c f4       	brge	.+22     	; 0x58c <LCD_Printf+0x166>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
 576:	f0 94       	com	r15
 578:	e0 94       	com	r14
 57a:	d0 94       	com	r13
 57c:	c0 94       	com	r12
 57e:	c1 1c       	adc	r12, r1
 580:	d1 1c       	adc	r13, r1
 582:	e1 1c       	adc	r14, r1
 584:	f1 1c       	adc	r15, r1
				   LCD_DisplayChar('-');
 586:	8d e2       	ldi	r24, 0x2D	; 45
 588:	0e 94 72 01 	call	0x2e4	; 0x2e4 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
 58c:	c7 01       	movw	r24, r14
 58e:	b6 01       	movw	r22, r12
 590:	40 2f       	mov	r20, r16
 592:	0e 94 a3 01 	call	0x346	; 0x346 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 596:	73 01       	movw	r14, r6
				   var_num_s32 = -var_num_s32;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	
 598:	46 c0       	rjmp	.+140    	; 0x626 <LCD_Printf+0x200>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 59a:	cc 24       	eor	r12, r12
 59c:	dd 24       	eor	r13, r13
 59e:	68 94       	set
 5a0:	c1 f8       	bld	r12, 1
 5a2:	ce 0c       	add	r12, r14
 5a4:	df 1c       	adc	r13, r15
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 5a6:	f7 01       	movw	r30, r14
 5a8:	80 81       	ld	r24, Z
 5aa:	91 81       	ldd	r25, Z+1	; 0x01
 5ac:	bc 01       	movw	r22, r24
 5ae:	80 e0       	ldi	r24, 0x00	; 0
 5b0:	90 e0       	ldi	r25, 0x00	; 0
 5b2:	40 2f       	mov	r20, r16
 5b4:	0e 94 a3 01 	call	0x346	; 0x346 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 5b8:	76 01       	movw	r14, r12
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 5ba:	35 c0       	rjmp	.+106    	; 0x626 <LCD_Printf+0x200>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 5bc:	cc 24       	eor	r12, r12
 5be:	dd 24       	eor	r13, r13
 5c0:	68 94       	set
 5c2:	c2 f8       	bld	r12, 2
 5c4:	ce 0c       	add	r12, r14
 5c6:	df 1c       	adc	r13, r15
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 5c8:	d7 01       	movw	r26, r14
 5ca:	6d 91       	ld	r22, X+
 5cc:	7d 91       	ld	r23, X+
 5ce:	8d 91       	ld	r24, X+
 5d0:	9c 91       	ld	r25, X
 5d2:	40 2f       	mov	r20, r16
 5d4:	0e 94 a3 01 	call	0x346	; 0x346 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 5d8:	76 01       	movw	r14, r12
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			
 5da:	25 c0       	rjmp	.+74     	; 0x626 <LCD_Printf+0x200>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
 5dc:	e2 e0       	ldi	r30, 0x02	; 2
 5de:	f0 e0       	ldi	r31, 0x00	; 0
 5e0:	ee 0e       	add	r14, r30
 5e2:	ff 1e       	adc	r15, r31
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 5e4:	20 c0       	rjmp	.+64     	; 0x626 <LCD_Printf+0x200>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
 5e6:	84 e0       	ldi	r24, 0x04	; 4
 5e8:	90 e0       	ldi	r25, 0x00	; 0
 5ea:	e8 0e       	add	r14, r24
 5ec:	f9 1e       	adc	r15, r25
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;
 5ee:	1b c0       	rjmp	.+54     	; 0x626 <LCD_Printf+0x200>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 5f0:	a2 e0       	ldi	r26, 0x02	; 2
 5f2:	b0 e0       	ldi	r27, 0x00	; 0
 5f4:	ea 0e       	add	r14, r26
 5f6:	fb 1e       	adc	r15, r27
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
 5f8:	16 c0       	rjmp	.+44     	; 0x626 <LCD_Printf+0x200>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 5fa:	e4 e0       	ldi	r30, 0x04	; 4
 5fc:	f0 e0       	ldi	r31, 0x00	; 0
 5fe:	ee 0e       	add	r14, r30
 600:	ff 1e       	adc	r15, r31
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;				
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
#endif				
				break;
 602:	11 c0       	rjmp	.+34     	; 0x626 <LCD_Printf+0x200>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 604:	84 e0       	ldi	r24, 0x04	; 4
 606:	90 e0       	ldi	r25, 0x00	; 0
 608:	e8 0e       	add	r14, r24
 60a:	f9 1e       	adc	r15, r25
#if (Enable_LCD_DisplayFloatNumber == 1)				
				LCD_DisplayFloatNumber(var_floatNum_f32);
#endif
				break;
 60c:	0c c0       	rjmp	.+24     	; 0x626 <LCD_Printf+0x200>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 60e:	a2 e0       	ldi	r26, 0x02	; 2
 610:	b0 e0       	ldi	r27, 0x00	; 0
 612:	ea 0e       	add	r14, r26
 614:	fb 1e       	adc	r15, r27
#if (Enable_LCD_DisplayString == 1)
				LCD_DisplayString(str);
#endif				
				break;
 616:	07 c0       	rjmp	.+14     	; 0x626 <LCD_Printf+0x200>

			case '%':
				LCD_DisplayChar('%');
 618:	85 e2       	ldi	r24, 0x25	; 37
 61a:	0e 94 72 01 	call	0x2e4	; 0x2e4 <LCD_DisplayChar>
				break;
 61e:	03 c0       	rjmp	.+6      	; 0x626 <LCD_Printf+0x200>
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 620:	0e 94 72 01 	call	0x2e4	; 0x2e4 <LCD_DisplayChar>
 624:	56 01       	movw	r10, r12
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 626:	65 01       	movw	r12, r10
 628:	08 94       	sec
 62a:	c1 1c       	adc	r12, r1
 62c:	d1 1c       	adc	r13, r1
 62e:	f5 01       	movw	r30, r10
 630:	81 81       	ldd	r24, Z+1	; 0x01
 632:	88 23       	and	r24, r24
 634:	09 f0       	breq	.+2      	; 0x638 <LCD_Printf+0x212>
 636:	1a cf       	rjmp	.-460    	; 0x46c <LCD_Printf+0x46>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 638:	df 91       	pop	r29
 63a:	cf 91       	pop	r28
 63c:	1f 91       	pop	r17
 63e:	0f 91       	pop	r16
 640:	ff 90       	pop	r15
 642:	ef 90       	pop	r14
 644:	df 90       	pop	r13
 646:	cf 90       	pop	r12
 648:	bf 90       	pop	r11
 64a:	af 90       	pop	r10
 64c:	9f 90       	pop	r9
 64e:	8f 90       	pop	r8
 650:	7f 90       	pop	r7
 652:	6f 90       	pop	r6
 654:	08 95       	ret

00000656 <main>:
/* start the main program */
void main() 
{
   uint16_t adc_result0,adc_result1,adc_result2,adc_result3;		

    LCD_Init(4,2,16);	   /* Initialize 2x16lcd in 8-bit mode */    
 656:	84 e0       	ldi	r24, 0x04	; 4
 658:	62 e0       	ldi	r22, 0x02	; 2
 65a:	40 e1       	ldi	r20, 0x10	; 16
 65c:	0e 94 14 01 	call	0x228	; 0x228 <LCD_Init>
    ADC_Init();			   /* Initialize the adc module*/	 
 660:	0e 94 67 00 	call	0xce	; 0xce <ADC_Init>
		 adc_result1= ADC_GetAdcValue(1);
		 adc_result2= ADC_GetAdcValue(2);
		 adc_result3= ADC_GetAdcValue(3);		  
	
		 LCD_GoToLine(1);
         LCD_Printf("C0:%d C1:%d \nC2:%d C3:%d ",adc_result0,adc_result1,adc_result2,adc_result3);         	     
 664:	0f 2e       	mov	r0, r31
 666:	f5 e0       	ldi	r31, 0x05	; 5
 668:	af 2e       	mov	r10, r31
 66a:	f1 e0       	ldi	r31, 0x01	; 1
 66c:	bf 2e       	mov	r11, r31
 66e:	f0 2d       	mov	r31, r0
    ADC_Init();			   /* Initialize the adc module*/	 
    
   while(1)
    {
       	/* Get the adc value of first four channels */
		 adc_result0= ADC_GetAdcValue(0);
 670:	80 e0       	ldi	r24, 0x00	; 0
 672:	0e 94 6b 00 	call	0xd6	; 0xd6 <ADC_GetAdcValue>
 676:	ec 01       	movw	r28, r24
		 adc_result1= ADC_GetAdcValue(1);
 678:	81 e0       	ldi	r24, 0x01	; 1
 67a:	0e 94 6b 00 	call	0xd6	; 0xd6 <ADC_GetAdcValue>
 67e:	8c 01       	movw	r16, r24
		 adc_result2= ADC_GetAdcValue(2);
 680:	82 e0       	ldi	r24, 0x02	; 2
 682:	0e 94 6b 00 	call	0xd6	; 0xd6 <ADC_GetAdcValue>
 686:	7c 01       	movw	r14, r24
		 adc_result3= ADC_GetAdcValue(3);		  
 688:	83 e0       	ldi	r24, 0x03	; 3
 68a:	0e 94 6b 00 	call	0xd6	; 0xd6 <ADC_GetAdcValue>
 68e:	6c 01       	movw	r12, r24
	
		 LCD_GoToLine(1);
 690:	81 e0       	ldi	r24, 0x01	; 1
 692:	0e 94 fd 00 	call	0x1fa	; 0x1fa <LCD_GoToLine>
         LCD_Printf("C0:%d C1:%d \nC2:%d C3:%d ",adc_result0,adc_result1,adc_result2,adc_result3);         	     
 696:	8d b7       	in	r24, 0x3d	; 61
 698:	9e b7       	in	r25, 0x3e	; 62
 69a:	0a 97       	sbiw	r24, 0x0a	; 10
 69c:	0f b6       	in	r0, 0x3f	; 63
 69e:	f8 94       	cli
 6a0:	9e bf       	out	0x3e, r25	; 62
 6a2:	0f be       	out	0x3f, r0	; 63
 6a4:	8d bf       	out	0x3d, r24	; 61
 6a6:	ed b7       	in	r30, 0x3d	; 61
 6a8:	fe b7       	in	r31, 0x3e	; 62
 6aa:	31 96       	adiw	r30, 0x01	; 1
 6ac:	ad b7       	in	r26, 0x3d	; 61
 6ae:	be b7       	in	r27, 0x3e	; 62
 6b0:	12 96       	adiw	r26, 0x02	; 2
 6b2:	bc 92       	st	X, r11
 6b4:	ae 92       	st	-X, r10
 6b6:	11 97       	sbiw	r26, 0x01	; 1
 6b8:	d3 83       	std	Z+3, r29	; 0x03
 6ba:	c2 83       	std	Z+2, r28	; 0x02
 6bc:	15 83       	std	Z+5, r17	; 0x05
 6be:	04 83       	std	Z+4, r16	; 0x04
 6c0:	f7 82       	std	Z+7, r15	; 0x07
 6c2:	e6 82       	std	Z+6, r14	; 0x06
 6c4:	d1 86       	std	Z+9, r13	; 0x09
 6c6:	c0 86       	std	Z+8, r12	; 0x08
 6c8:	0e 94 13 02 	call	0x426	; 0x426 <LCD_Printf>
 6cc:	8d b7       	in	r24, 0x3d	; 61
 6ce:	9e b7       	in	r25, 0x3e	; 62
 6d0:	0a 96       	adiw	r24, 0x0a	; 10
 6d2:	0f b6       	in	r0, 0x3f	; 63
 6d4:	f8 94       	cli
 6d6:	9e bf       	out	0x3e, r25	; 62
 6d8:	0f be       	out	0x3f, r0	; 63
 6da:	8d bf       	out	0x3d, r24	; 61
 6dc:	c9 cf       	rjmp	.-110    	; 0x670 <main+0x1a>

000006de <__udivmodsi4>:
 6de:	a1 e2       	ldi	r26, 0x21	; 33
 6e0:	1a 2e       	mov	r1, r26
 6e2:	aa 1b       	sub	r26, r26
 6e4:	bb 1b       	sub	r27, r27
 6e6:	fd 01       	movw	r30, r26
 6e8:	0d c0       	rjmp	.+26     	; 0x704 <__udivmodsi4_ep>

000006ea <__udivmodsi4_loop>:
 6ea:	aa 1f       	adc	r26, r26
 6ec:	bb 1f       	adc	r27, r27
 6ee:	ee 1f       	adc	r30, r30
 6f0:	ff 1f       	adc	r31, r31
 6f2:	a2 17       	cp	r26, r18
 6f4:	b3 07       	cpc	r27, r19
 6f6:	e4 07       	cpc	r30, r20
 6f8:	f5 07       	cpc	r31, r21
 6fa:	20 f0       	brcs	.+8      	; 0x704 <__udivmodsi4_ep>
 6fc:	a2 1b       	sub	r26, r18
 6fe:	b3 0b       	sbc	r27, r19
 700:	e4 0b       	sbc	r30, r20
 702:	f5 0b       	sbc	r31, r21

00000704 <__udivmodsi4_ep>:
 704:	66 1f       	adc	r22, r22
 706:	77 1f       	adc	r23, r23
 708:	88 1f       	adc	r24, r24
 70a:	99 1f       	adc	r25, r25
 70c:	1a 94       	dec	r1
 70e:	69 f7       	brne	.-38     	; 0x6ea <__udivmodsi4_loop>
 710:	60 95       	com	r22
 712:	70 95       	com	r23
 714:	80 95       	com	r24
 716:	90 95       	com	r25
 718:	9b 01       	movw	r18, r22
 71a:	ac 01       	movw	r20, r24
 71c:	bd 01       	movw	r22, r26
 71e:	cf 01       	movw	r24, r30
 720:	08 95       	ret

00000722 <_exit>:
 722:	f8 94       	cli

00000724 <__stop_program>:
 724:	ff cf       	rjmp	.-2      	; 0x724 <__stop_program>
